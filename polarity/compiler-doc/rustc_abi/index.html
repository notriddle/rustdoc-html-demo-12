<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="ABI handling for rustc"><title>rustc_abi - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rustc_abi" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-dev" data-channel="nightly" data-search-js="search-38ac1f3e.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate rustc_abi</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../rustc_abi/index.html"><img class="rust-logo" src="../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../rustc_abi/index.html">rustc_<wbr>abi</a><span class="version">1.91.0-dev</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#what-is-an-abi" title="What is an “ABI”?">What is an “ABI”?</a></li><li><a href="#crate-goal" title="Crate Goal">Crate Goal</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#constants" title="Constants">Constants</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rustc_<wbr>abi</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rustc_abi/lib.rs.html#2-2211">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>ABI handling for rustc</p>
<h3 id="what-is-an-abi"><a class="doc-anchor" href="#what-is-an-abi">§</a>What is an “ABI”?</h3>
<p>Literally, “application binary interface”, which means it is everything about how code interacts,
at the machine level, with other code. This means it technically covers all of the following:</p>
<ul>
<li>object binary format for e.g. relocations or offset tables</li>
<li>in-memory layout of types</li>
<li>procedure calling conventions</li>
</ul>
<p>When we discuss “ABI” in the context of rustc, we are probably discussing calling conventions.
To describe those <code>rustc_abi</code> also covers type layout, as it must for values passed on the stack.
Despite <code>rustc_abi</code> being about calling conventions, it is good to remember these usages exist.
You will encounter all of them and more if you study target-specific codegen enough!
Even in general conversation, when someone says “the Rust ABI is unstable”, it may allude to
either or both of</p>
<ul>
<li><code>repr(Rust)</code> types have a mostly-unspecified layout</li>
<li><code>extern "Rust" fn(A) -&gt; R</code> has an unspecified calling convention</li>
</ul>
<h3 id="crate-goal"><a class="doc-anchor" href="#crate-goal">§</a>Crate Goal</h3>
<p>ABI is a foundational concept, so the <code>rustc_abi</code> crate serves as an equally foundational crate.
It cannot carry all details relevant to an ABI: those permeate code generation and linkage.
Instead, <code>rustc_abi</code> is intended to provide the interface for reasoning about the binary interface.
It should contain traits and types that other crates then use in their implementation.
For example, a platform’s <code>extern "C" fn</code> calling convention will be implemented in <code>rustc_target</code>
but <code>rustc_abi</code> contains the types for calculating layout and describing register-passing.
This makes it easier to describe things in the same way across targets, codegen backends, and
even other Rust compilers, such as rust-analyzer!</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="callconv/index.html" title="mod rustc_abi::callconv">callconv</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="mod" href="canon_abi/index.html" title="mod rustc_abi::canon_abi">canon_<wbr>abi</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="mod" href="extern_abi/index.html" title="mod rustc_abi::extern_abi">extern_<wbr>abi</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="mod" href="layout/index.html" title="mod rustc_abi::layout">layout</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AbiAlign.html" title="struct rustc_abi::AbiAlign">AbiAlign</a></dt><dd>A pair of alignments, ABI-mandated and preferred.</dd><dt><a class="struct" href="struct.AddressSpace.html" title="struct rustc_abi::AddressSpace">Address<wbr>Space</a></dt><dd>An identifier that specifies the address space that some operation
should operate on. Special address spaces have an effect on code generation,
depending on the target and the address spaces it implements.</dd><dt><a class="struct" href="struct.Align.html" title="struct rustc_abi::Align">Align</a></dt><dd>Alignment of a type in bytes (always a power of two).</dd><dt><a class="struct" href="struct.FieldIdx.html" title="struct rustc_abi::FieldIdx">Field<wbr>Idx</a></dt><dd>The <em>source-order</em> index of a field in a variant.</dd><dt><a class="struct" href="struct.Heterogeneous.html" title="struct rustc_abi::Heterogeneous">Heterogeneous</a></dt><dd>Error from the <code>homogeneous_aggregate</code> test function, indicating
there are distinct leaf fields passed in different ways,
or this is uninhabited.</dd><dt><a class="struct" href="struct.Layout.html" title="struct rustc_abi::Layout">Layout</a></dt><dt><a class="struct" href="struct.LayoutCalculator.html" title="struct rustc_abi::LayoutCalculator">Layout<wbr>Calculator</a></dt><dt><a class="struct" href="struct.LayoutData.html" title="struct rustc_abi::LayoutData">Layout<wbr>Data</a></dt><dt><a class="struct" href="struct.Niche.html" title="struct rustc_abi::Niche">Niche</a></dt><dt><a class="struct" href="struct.PointeeInfo.html" title="struct rustc_abi::PointeeInfo">Pointee<wbr>Info</a></dt><dd>Encodes extra information we have about a pointer.
Note that this information is advisory only, and backends are free to ignore it:
if the information is wrong, that can cause UB, but if the information is absent,
that must always be okay.</dd><dt><a class="struct" href="struct.PointerSpec.html" title="struct rustc_abi::PointerSpec">Pointer<wbr>Spec</a></dt><dd>How pointers are represented in a given address space</dd><dt><a class="struct" href="struct.Reg.html" title="struct rustc_abi::Reg">Reg</a></dt><dt><a class="struct" href="struct.ReprFlags.html" title="struct rustc_abi::ReprFlags">Repr<wbr>Flags</a></dt><dt><a class="struct" href="struct.ReprOptions.html" title="struct rustc_abi::ReprOptions">Repr<wbr>Options</a></dt><dd>Represents the repr options provided by the user.</dd><dt><a class="struct" href="struct.Size.html" title="struct rustc_abi::Size">Size</a></dt><dd>Size of a type in bytes.</dd><dt><a class="struct" href="struct.TargetDataLayout.html" title="struct rustc_abi::TargetDataLayout">Target<wbr>Data<wbr>Layout</a></dt><dd>Parsed <a href="https://llvm.org/docs/LangRef.html#data-layout">Data layout</a>
for a target, which contains everything needed to compute layouts.</dd><dt><a class="struct" href="struct.TyAndLayout.html" title="struct rustc_abi::TyAndLayout">TyAnd<wbr>Layout</a></dt><dd>The layout of a type, alongside the type itself.
Provides various type traversal APIs (e.g., recursing into fields).</dd><dt><a class="struct" href="struct.VariantIdx.html" title="struct rustc_abi::VariantIdx">Variant<wbr>Idx</a></dt><dd>The <em>source-order</em> index of a variant in a type.</dd><dt><a class="struct" href="struct.WrappingRange.html" title="struct rustc_abi::WrappingRange">Wrapping<wbr>Range</a></dt><dd>Inclusive wrap-around range of valid values, that is, if
start &gt; end, it represents <code>start..=MAX</code>, followed by <code>0..=end</code>.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AbiFromStrErr.html" title="enum rustc_abi::AbiFromStrErr">AbiFrom<wbr>StrErr</a></dt><dt><a class="enum" href="enum.AlignFromBytesError.html" title="enum rustc_abi::AlignFromBytesError">Align<wbr>From<wbr>Bytes<wbr>Error</a></dt><dt><a class="enum" href="enum.ArmCall.html" title="enum rustc_abi::ArmCall">ArmCall</a></dt><dd>ABIs defined for 32-bit Arm</dd><dt><a class="enum" href="enum.BackendRepr.html" title="enum rustc_abi::BackendRepr">Backend<wbr>Repr</a></dt><dd>The way we represent values to the backend</dd><dt><a class="enum" href="enum.CanonAbi.html" title="enum rustc_abi::CanonAbi">Canon<wbr>Abi</a></dt><dd>Calling convention to determine codegen</dd><dt><a class="enum" href="enum.Endian.html" title="enum rustc_abi::Endian">Endian</a></dt><dd>Endianness of the target, which must match cfg(target-endian).</dd><dt><a class="enum" href="enum.ExternAbi.html" title="enum rustc_abi::ExternAbi">Extern<wbr>Abi</a></dt><dd>ABI we expect to see within <code>extern "{abi}"</code></dd><dt><a class="enum" href="enum.FieldsShape.html" title="enum rustc_abi::FieldsShape">Fields<wbr>Shape</a></dt><dd>Describes how the fields of a type are located in memory.</dd><dt><a class="enum" href="enum.Float.html" title="enum rustc_abi::Float">Float</a></dt><dd>Floating-point types.</dd><dt><a class="enum" href="enum.HomogeneousAggregate.html" title="enum rustc_abi::HomogeneousAggregate">Homogeneous<wbr>Aggregate</a></dt><dd>Return value from the <code>homogeneous_aggregate</code> test function.</dd><dt><a class="enum" href="enum.Integer.html" title="enum rustc_abi::Integer">Integer</a></dt><dd>Integers, also used for enum discriminants.</dd><dt><a class="enum" href="enum.IntegerType.html" title="enum rustc_abi::IntegerType">Integer<wbr>Type</a></dt><dt><a class="enum" href="enum.InterruptKind.html" title="enum rustc_abi::InterruptKind">Interrupt<wbr>Kind</a></dt><dd>Callee codegen for interrupts</dd><dt><a class="enum" href="enum.LayoutCalculatorError.html" title="enum rustc_abi::LayoutCalculatorError">Layout<wbr>Calculator<wbr>Error</a></dt><dt><a class="enum" href="enum.PointerKind.html" title="enum rustc_abi::PointerKind">Pointer<wbr>Kind</a></dt><dt><a class="enum" href="enum.Primitive.html" title="enum rustc_abi::Primitive">Primitive</a></dt><dd>Fundamental unit of memory access and layout.</dd><dt><a class="enum" href="enum.RegKind.html" title="enum rustc_abi::RegKind">RegKind</a></dt><dt><a class="enum" href="enum.Scalar.html" title="enum rustc_abi::Scalar">Scalar</a></dt><dd>Information about one scalar component of a Rust type.</dd><dt><a class="enum" href="enum.StructKind.html" title="enum rustc_abi::StructKind">Struct<wbr>Kind</a></dt><dt><a class="enum" href="enum.TagEncoding.html" title="enum rustc_abi::TagEncoding">TagEncoding</a></dt><dt><a class="enum" href="enum.TargetDataLayoutErrors.html" title="enum rustc_abi::TargetDataLayoutErrors">Target<wbr>Data<wbr>Layout<wbr>Errors</a></dt><dt><a class="enum" href="enum.Variants.html" title="enum rustc_abi::Variants">Variants</a></dt><dt><a class="enum" href="enum.X86Call.html" title="enum rustc_abi::X86Call">X86Call</a></dt><dd>ABIs defined for x86-{32,64}</dd></dl><h2 id="constants" class="section-header">Constants<a href="#constants" class="anchor">§</a></h2><dl class="item-table"><dt><a class="constant" href="constant.FIRST_VARIANT.html" title="constant rustc_abi::FIRST_VARIANT">FIRST_<wbr>VARIANT</a></dt><dd>Equivalent to <code>VariantIdx(0)</code>.</dd><dt><a class="constant" href="constant.MAX_SIMD_LANES.html" title="constant rustc_abi::MAX_SIMD_LANES">MAX_<wbr>SIMD_<wbr>LANES</a></dt><dd>The maximum supported number of lanes in a SIMD vector.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.HasDataLayout.html" title="trait rustc_abi::HasDataLayout">HasData<wbr>Layout</a></dt><dt><a class="trait" href="trait.HashStableContext.html" title="trait rustc_abi::HashStableContext">Hash<wbr>Stable<wbr>Context</a></dt><dd>Requirements for a <code>StableHashingContext</code> to be used in this crate.
This is a hack to allow using the <code>HashStable_Generic</code> derive macro
instead of implementing everything in <code>rustc_middle</code>.</dd><dt><a class="trait" href="trait.TyAbiInterface.html" title="trait rustc_abi::TyAbiInterface">TyAbi<wbr>Interface</a></dt><dd>Trait that needs to be implemented by the higher-level type representation
(e.g. <code>rustc_middle::ty::Ty</code>), to provide <code>rustc_target::abi</code> functionality.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.all_names.html" title="fn rustc_abi::all_names">all_<wbr>names</a></dt></dl></section></div></main></body></html>