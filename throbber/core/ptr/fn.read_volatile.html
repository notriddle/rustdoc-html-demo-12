<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Performs a volatile read of the value from `src` without moving it."><title>read_volatile in core::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-54c10573.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="core" data-themes="" data-resource-suffix="1.92.0" data-rustdoc-version="1.92.0-dev" data-channel="nightly" data-search-js="search-6c5c7cca.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items1.92.0.js"></script><script defer src="../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">read_volatile</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../core/index.html"><img class="rust-logo" src="../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../core/index.html">core</a><span class="version">1.92.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">read_<wbr>volatile</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safety" title="Safety">Safety</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In core::<wbr>ptr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">core</a>::<wbr><a href="index.html">ptr</a></div><h1>Function <span class="fn">read_<wbr>volatile</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> · <a class="src" href="../../src/core/ptr/mod.rs.html#2103-2116">Source</a> </span></div><pre class="rust item-decl"><code>pub unsafe fn read_volatile&lt;T&gt;(src: <a class="primitive" href="../primitive.pointer.html">*const T</a>) -&gt; T</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Performs a volatile read of the value from <code>src</code> without moving it.</p>
<p>Volatile operations are intended to act on I/O memory. As such, they are considered externally
observable events (just like syscalls, but less opaque), and are guaranteed to not be elided or
reordered by the compiler across other externally observable events. With this in mind, there
are two cases of usage that need to be distinguished:</p>
<ul>
<li>
<p>When a volatile operation is used for memory inside an <a href="index.html#allocated-object" title="mod core::ptr">allocation</a>, it behaves exactly like
<a href="fn.read.html" title="fn core::ptr::read"><code>read</code></a>, except for the additional guarantee that it won’t be elided or reordered (see
above). This implies that the operation will actually access memory and not e.g. be lowered to
reusing data from a previous read. Other than that, all the usual rules for memory accesses
apply (including provenance).  In particular, just like in C, whether an operation is volatile
has no bearing whatsoever on questions involving concurrent accesses from multiple threads.
Volatile accesses behave exactly like non-atomic accesses in that regard.</p>
</li>
<li>
<p>Volatile operations, however, may also be used to access memory that is <em>outside</em> of any Rust
allocation. In this use-case, the pointer does <em>not</em> have to be <a href="index.html#safety" title="mod core::ptr">valid</a> for reads. This is
typically used for CPU and peripheral registers that must be accessed via an I/O memory
mapping, most commonly at fixed addresses reserved by the hardware. These often have special
semantics associated to their manipulation, and cannot be used as general purpose memory.
Here, any address value is possible, including 0 and <a href="../primitive.usize.html#associatedconstant.MAX" title="associated constant usize::MAX"><code>usize::MAX</code></a>, so long as the semantics
of such a read are well-defined by the target hardware. The provenance of the pointer is
irrelevant, and it can be created with <a href="fn.without_provenance.html" title="fn core::ptr::without_provenance"><code>without_provenance</code></a>. The access must not trap. It
can cause side-effects, but those must not affect Rust-allocated memory in any way. This
access is still not considered <a href="../sync/atomic/index.html#memory-model-for-atomic-accesses" title="mod core::sync::atomic">atomic</a>, and as such it cannot be used for inter-thread
synchronization.</p>
</li>
</ul>
<p>Note that volatile memory operations where T is a zero-sized type are noops and may be ignored.</p>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Like <a href="fn.read.html" title="fn core::ptr::read"><code>read</code></a>, <code>read_volatile</code> creates a bitwise copy of <code>T</code>, regardless of whether <code>T</code> is
<a href="../marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a>. If <code>T</code> is not <a href="../marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a>, using both the returned value and the value at <code>*src</code> can
<a href="fn.read.html#ownership-of-the-returned-value" title="fn core::ptr::read">violate memory safety</a>. However, storing non-<a href="../marker/trait.Copy.html" title="trait core::marker::Copy"><code>Copy</code></a> types in volatile memory
is almost certainly incorrect.</p>
<p>Behavior is undefined if any of the following conditions are violated:</p>
<ul>
<li>
<p><code>src</code> must be either <a href="index.html#safety" title="mod core::ptr">valid</a> for reads, or it must point to memory outside of all Rust
allocations and reading from that memory must:</p>
<ul>
<li>not trap, and</li>
<li>not cause any memory inside a Rust allocation to be modified.</li>
</ul>
</li>
<li>
<p><code>src</code> must be properly aligned.</p>
</li>
<li>
<p>Reading from <code>src</code> must produce a properly initialized value of type <code>T</code>.</p>
</li>
</ul>
<p>Note that even if <code>T</code> has size <code>0</code>, the pointer must be properly aligned.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="number">12</span>;
<span class="kw">let </span>y = <span class="kw-2">&amp;</span>x <span class="kw">as </span><span class="kw-2">*const </span>i32;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(std::ptr::read_volatile(y), <span class="number">12</span>);
}</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0Afn+main()+%7B%0A++++let+x+=+12;%0A++++let+y+=+%26x+as+*const+i32;%0A++++%0A++++unsafe+%7B%0A++++++++assert_eq!(std::ptr::read_volatile(y),+12);%0A++++%7D%0A%7D&amp;edition=2024"></a></div></div></details></section></div></main></body></html>