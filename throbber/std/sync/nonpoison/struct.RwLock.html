<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A reader-writer lock that does not keep track of lock poisoning."><title>RwLock in std::sync::nonpoison - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="std" data-themes="" data-resource-suffix="1.92.0" data-rustdoc-version="1.92.0-dev" data-channel="nightly" data-search-js="search-a5832573.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items1.92.0.js"></script><script defer src="../../../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">RwLock</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../std/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../../std/index.html">std</a><span class="version">1.92.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">RwLock</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.data_ptr" title="data_ptr">data_ptr</a></li><li><a href="#method.get_cloned" title="get_cloned">get_cloned</a></li><li><a href="#method.get_mut" title="get_mut">get_mut</a></li><li><a href="#method.into_inner" title="into_inner">into_inner</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.read" title="read">read</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.set" title="set">set</a></li><li><a href="#method.try_read" title="try_read">try_read</a></li><li><a href="#method.try_write" title="try_write">try_write</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.with_mut" title="with_mut">with_mut</a></li><li><a href="#method.write" title="write">write</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-RwLock%3CT%3E" title="Debug">Debug</a></li><li><a href="#impl-Default-for-RwLock%3CT%3E" title="Default">Default</a></li><li><a href="#impl-From%3CT%3E-for-RwLock%3CT%3E" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Send-for-RwLock%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-RwLock%3CT%3E" title="Sync">Sync</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-RwLock%3CT%3E" title="!Freeze">!Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-RwLock%3CT%3E" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Unpin-for-RwLock%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-RwLock%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-From%3C!%3E-for-T" title="From&#60;!&#62;">From&#60;!&#62;</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In std::<wbr>sync::<wbr>nonpoison</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">std</a>::<wbr><a href="../index.html">sync</a>::<wbr><a href="index.html">nonpoison</a></div><h1>Struct <span class="struct">RwLock</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/std/sync/nonpoison/rwlock.rs.html#43-48">Source</a> </span></div><pre class="rust item-decl"><code>pub struct RwLock&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A reader-writer lock that does not keep track of lock poisoning.</p>
<p>For more information about reader-writer locks, check out the documentation for the poisoning
variant of this lock (which can be found at <a href="../struct.RwLock.html" title="struct std::sync::RwLock"><code>poison::RwLock</code></a>).</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">5</span>);

<span class="comment">// many reader locks can be held at once
</span>{
    <span class="kw">let </span>r1 = lock.read();
    <span class="kw">let </span>r2 = lock.read();
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>r1, <span class="number">5</span>);
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>r2, <span class="number">5</span>);
} <span class="comment">// read locks are dropped at this point

// only one write lock may be held, however
</span>{
    <span class="kw">let </span><span class="kw-2">mut </span>w = lock.write();
    <span class="kw-2">*</span>w += <span class="number">1</span>;
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>w, <span class="number">6</span>);
} <span class="comment">// write lock is dropped here</span></code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(5);%0A++++%0A++++//+many+reader+locks+can+be+held+at+once%0A++++%7B%0A++++++++let+r1+=+lock.read();%0A++++++++let+r2+=+lock.read();%0A++++++++assert_eq!(*r1,+5);%0A++++++++assert_eq!(*r2,+5);%0A++++%7D+//+read+locks+are+dropped+at+this+point%0A++++%0A++++//+only+one+write+lock+may+be+held,+however%0A++++%7B%0A++++++++let+mut+w+=+lock.write();%0A++++++++*w+%2B=+1;%0A++++++++assert_eq!(*w,+6);%0A++++%7D%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">Â§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#192-282">Source</a><a href="#impl-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#206-208">Source</a><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(t: T) -&gt; <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Creates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(5);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_cloned" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#226-231">Source</a><h4 class="code-header">pub fn <a href="#method.get_cloned" class="fn">get_cloned</a>(&amp;self) -&gt; T<div class="where">where
    T: <a class="trait" href="../../clone/trait.Clone.html" title="trait std::clone::Clone">Clone</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Returns the contained value by cloning it.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]
#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.get_cloned(), <span class="number">7</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.get_cloned(),+7);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.set" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#251-259">Source</a><h4 class="code-header">pub fn <a href="#method.set" class="fn">set</a>(&amp;self, value: T)</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Sets the contained value.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]
#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.get_cloned(), <span class="number">7</span>);
lock.set(<span class="number">11</span>);
<span class="macro">assert_eq!</span>(lock.get_cloned(), <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.get_cloned(),+7);%0A++++lock.set(11);%0A++++assert_eq!(lock.get_cloned(),+11);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#278-281">Source</a><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>(&amp;self, value: T) -&gt; T</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Replaces the contained value with <code>value</code>, and returns the old contained value.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]
#![feature(lock_value_accessors)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">7</span>);

<span class="macro">assert_eq!</span>(lock.replace(<span class="number">11</span>), <span class="number">7</span>);
<span class="macro">assert_eq!</span>(lock.get_cloned(), <span class="number">11</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%23!%5Bfeature(lock_value_accessors)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(7);%0A++++%0A++++assert_eq!(lock.replace(11),+7);%0A++++assert_eq!(lock.get_cloned(),+11);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RwLock%3CT%3E-1" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#284-563">Source</a><a href="#impl-RwLock%3CT%3E-1" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>&gt; <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#322-327">Source</a><h4 class="code-header">pub fn <a href="#method.read" class="fn">read</a>(&amp;self) -&gt; <a class="struct" href="struct.RwLockReadGuard.html" title="struct std::sync::nonpoison::RwLockReadGuard">RwLockReadGuard</a>&lt;'_, T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Locks this <code>RwLock</code> with shared read access, blocking the current thread
until it can be acquired.</p>
<p>The calling thread will be blocked until there are no more writers which
hold the lock. There may be other readers currently inside the lock when
this method returns. This method does not provide any guarantees with
respect to the ordering of whether contentious readers or writers will
acquire the lock first.</p>
<p>Returns an RAII guard which will release this threadâ€™s shared access
once it is dropped.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">Â§</a>Panics</h5>
<p>This function might panic when called if the lock is already held by the current thread.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::Arc;
<span class="kw">use </span>std::sync::nonpoison::RwLock;
<span class="kw">use </span>std::thread;

<span class="kw">let </span>lock = Arc::new(RwLock::new(<span class="number">1</span>));
<span class="kw">let </span>c_lock = Arc::clone(<span class="kw-2">&amp;</span>lock);

<span class="kw">let </span>n = lock.read();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>);

thread::spawn(<span class="kw">move </span>|| {
    <span class="kw">let </span>r = c_lock.read();
}).join().unwrap();</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::Arc;%0A++++use+std::sync::nonpoison::RwLock;%0A++++use+std::thread;%0A++++%0A++++let+lock+=+Arc::new(RwLock::new(1));%0A++++let+c_lock+=+Arc::clone(%26lock);%0A++++%0A++++let+n+=+lock.read();%0A++++assert_eq!(*n,+1);%0A++++%0A++++thread::spawn(move+%7C%7C+%7B%0A++++++++let+r+=+c_lock.read();%0A++++%7D).join().unwrap();%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.try_read" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#361-365">Source</a><h4 class="code-header">pub fn <a href="#method.try_read" class="fn">try_read</a>(&amp;self) -&gt; <a class="type" href="type.TryLockResult.html" title="type std::sync::nonpoison::TryLockResult">TryLockResult</a>&lt;<a class="struct" href="struct.RwLockReadGuard.html" title="struct std::sync::nonpoison::RwLockReadGuard">RwLockReadGuard</a>&lt;'_, T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Attempts to acquire this <code>RwLock</code> with shared read access.</p>
<p>If the access could not be granted at this time, then <code>Err</code> is returned.
Otherwise, an RAII guard is returned which will release the shared access
when it is dropped.</p>
<p>This function does not block.</p>
<p>This function does not provide any guarantees with respect to the ordering
of whether contentious readers or writers will acquire the lock first.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">Â§</a>Errors</h5>
<p>This function will return the <a href="struct.WouldBlock.html" title="struct std::sync::nonpoison::WouldBlock"><code>WouldBlock</code></a> error if the <code>RwLock</code> could
not be acquired because it was already locked exclusively.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">match </span>lock.try_read() {
    <span class="prelude-val">Ok</span>(n) =&gt; <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>),
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; <span class="macro">unreachable!</span>(),
};</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++match+lock.try_read()+%7B%0A++++++++Ok(n)+=%3E+assert_eq!(*n,+1),%0A++++++++Err(_)+=%3E+unreachable!(),%0A++++%7D;%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#396-401">Source</a><h4 class="code-header">pub fn <a href="#method.write" class="fn">write</a>(&amp;self) -&gt; <a class="struct" href="struct.RwLockWriteGuard.html" title="struct std::sync::nonpoison::RwLockWriteGuard">RwLockWriteGuard</a>&lt;'_, T&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Locks this <code>RwLock</code> with exclusive write access, blocking the current
thread until it can be acquired.</p>
<p>This function will not return while other writers or other readers
currently have access to the lock.</p>
<p>Returns an RAII guard which will drop the write access of this <code>RwLock</code>
when dropped.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">Â§</a>Panics</h5>
<p>This function might panic when called if the lock is already held by the current thread.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">let </span><span class="kw-2">mut </span>n = lock.write();
<span class="kw-2">*</span>n = <span class="number">2</span>;

<span class="macro">assert!</span>(lock.try_read().is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++let+mut+n+=+lock.write();%0A++++*n+=+2;%0A++++%0A++++assert!(lock.try_read().is_err());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.try_write" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#437-441">Source</a><h4 class="code-header">pub fn <a href="#method.try_write" class="fn">try_write</a>(&amp;self) -&gt; <a class="type" href="type.TryLockResult.html" title="type std::sync::nonpoison::TryLockResult">TryLockResult</a>&lt;<a class="struct" href="struct.RwLockWriteGuard.html" title="struct std::sync::nonpoison::RwLockWriteGuard">RwLockWriteGuard</a>&lt;'_, T&gt;&gt;</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Attempts to lock this <code>RwLock</code> with exclusive write access.</p>
<p>If the lock could not be acquired at this time, then <code>Err</code> is returned.
Otherwise, an RAII guard is returned which will release the lock when
it is dropped.</p>
<p>This function does not block.</p>
<p>This function does not provide any guarantees with respect to the ordering
of whether contentious readers or writers will acquire the lock first.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">Â§</a>Errors</h5>
<p>This function will return the <a href="struct.WouldBlock.html" title="struct std::sync::nonpoison::WouldBlock"><code>WouldBlock</code></a> error if the <code>RwLock</code> could
not be acquired because it was already locked.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(<span class="number">1</span>);

<span class="kw">let </span>n = lock.read();
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>n, <span class="number">1</span>);

<span class="macro">assert!</span>(lock.try_write().is_err());</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(1);%0A++++%0A++++let+n+=+lock.read();%0A++++assert_eq!(*n,+1);%0A++++%0A++++assert!(lock.try_write().is_err());%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.into_inner" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#460-465">Source</a><h4 class="code-header">pub fn <a href="#method.into_inner" class="fn">into_inner</a>(self) -&gt; T<div class="where">where
    T: <a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Consumes this <code>RwLock</code>, returning the underlying data.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>lock = RwLock::new(String::new());
{
    <span class="kw">let </span><span class="kw-2">mut </span>s = lock.write();
    <span class="kw-2">*</span>s = <span class="string">"modified"</span>.to_owned();
}
<span class="macro">assert_eq!</span>(lock.into_inner(), <span class="string">"modified"</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+lock+=+RwLock::new(String::new());%0A++++%7B%0A++++++++let+mut+s+=+lock.write();%0A++++++++*s+=+%22modified%22.to_owned();%0A++++%7D%0A++++assert_eq!(lock.into_inner(),+%22modified%22);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.get_mut" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#486-488">Source</a><h4 class="code-header">pub fn <a href="#method.get_mut" class="fn">get_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>nonpoison_rwlock</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/134645">#134645</a>)</span></div></span></summary><div class="docblock"><p>Returns a mutable reference to the underlying data.</p>
<p>Since this call borrows the <code>RwLock</code> mutably, no actual locking needs to
take place â€“ the mutable borrow statically guarantees no new locks can be acquired
while this reference exists. Note that this method does not clear any previously abandoned
locks (e.g., via <a href="../../mem/fn.forget.html" title="fn std::mem::forget"><code>forget()</code></a> on a <a href="struct.RwLockReadGuard.html" title="struct std::sync::nonpoison::RwLockReadGuard"><code>RwLockReadGuard</code></a> or <a href="struct.RwLockWriteGuard.html" title="struct std::sync::nonpoison::RwLockWriteGuard"><code>RwLockWriteGuard</code></a>).</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span><span class="kw-2">mut </span>lock = RwLock::new(<span class="number">0</span>);
<span class="kw-2">*</span>lock.get_mut() = <span class="number">10</span>;
<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>lock.read(), <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+mut+lock+=+RwLock::new(0);%0A++++*lock.get_mut()+=+10;%0A++++assert_eq!(*lock.read(),+10);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.data_ptr" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#498-500">Source</a><h4 class="code-header">pub const fn <a href="#method.data_ptr" class="fn">data_ptr</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>rwlock_data_ptr</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/140368">#140368</a>)</span></div></span></summary><div class="docblock"><p>Returns a raw pointer to the underlying data.</p>
<p>The returned pointer is always non-null and properly aligned, but it is
the userâ€™s responsibility to ensure that any reads and writes through it
are properly synchronized to avoid data races, and that it is not read
or written through after the lock is dropped.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#523-528">Source</a><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../ops/trait.FnOnce.html" title="trait std::ops::FnOnce">FnOnce</a>(<a class="primitive" href="../../primitive.reference.html">&amp;T</a>) -&gt; R,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Locks this <code>RwLock</code> with shared read access to the underlying data by passing
a reference to the given closure.</p>
<p>This method acquires the lock, calls the provided closure with a reference
to the data, and returns the result of the closure. The lock is released after
the closure completes, even if it panics.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(lock_value_accessors, nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>rwlock = RwLock::new(<span class="number">2</span>);
<span class="kw">let </span>result = rwlock.with(|data| <span class="kw-2">*</span>data + <span class="number">3</span>);

<span class="macro">assert_eq!</span>(result, <span class="number">5</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(lock_value_accessors,+nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+rwlock+=+RwLock::new(2);%0A++++let+result+=+rwlock.with(%7Cdata%7C+*data+%2B+3);%0A++++%0A++++assert_eq!(result,+5);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details><details class="toggle method-toggle" open><summary><section id="method.with_mut" class="method"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#557-562">Source</a><h4 class="code-header">pub fn <a href="#method.with_mut" class="fn">with_mut</a>&lt;F, R&gt;(&amp;self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../ops/trait.FnOnce.html" title="trait std::ops::FnOnce">FnOnce</a>(<a class="primitive" href="../../primitive.reference.html">&amp;mut T</a>) -&gt; R,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ðŸ”¬</span><span>This is a nightly-only experimental API. (<code>lock_value_accessors</code>&nbsp;<a href="https://github.com/rust-lang/rust/issues/133407">#133407</a>)</span></div></span></summary><div class="docblock"><p>Locks this <code>RwLock</code> with exclusive write access to the underlying data by passing
a mutable reference to the given closure.</p>
<p>This method acquires the lock, calls the provided closure with a mutable reference
to the data, and returns the result of the closure. The lock is released after
the closure completes, even if it panics.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(lock_value_accessors, nonpoison_rwlock)]

</span><span class="kw">use </span>std::sync::nonpoison::RwLock;

<span class="kw">let </span>rwlock = RwLock::new(<span class="number">2</span>);

<span class="kw">let </span>result = rwlock.with_mut(|data| {
    <span class="kw-2">*</span>data += <span class="number">3</span>;

    <span class="kw-2">*</span>data + <span class="number">5
</span>});

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>rwlock.read(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(result, <span class="number">10</span>);</code></pre><a class="test-arrow" target="_blank" title="Run code" href="https://play.rust-lang.org/?code=%23!%5Ballow(unused)%5D%0A%23!%5Bfeature(lock_value_accessors,+nonpoison_rwlock)%5D%0A%0A%0Afn+main()+%7B%0A++++use+std::sync::nonpoison::RwLock;%0A++++%0A++++let+rwlock+=+RwLock::new(2);%0A++++%0A++++let+result+=+rwlock.with_mut(%7Cdata%7C+%7B%0A++++++++*data+%2B=+3;%0A++++%0A++++++++*data+%2B+5%0A++++%7D);%0A++++%0A++++assert_eq!(*rwlock.read(),+5);%0A++++assert_eq!(result,+10);%0A%7D&amp;version=nightly&amp;edition=2024"></a></div></div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#566-579">Source</a><a href="#impl-Debug-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a>&gt; <a class="trait" href="../../fmt/trait.Debug.html" title="trait std::fmt::Debug">Debug</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#567-578">Source</a><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../fmt/struct.Formatter.html" title="struct std::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="../../fmt/type.Result.html" title="type std::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#582-587">Source</a><a href="#impl-Default-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a>&gt; <a class="trait" href="../../default/trait.Default.html" title="trait std::default::Default">Default</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#584-586">Source</a><a href="#method.default" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../default/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>RwLock&lt;T&gt;</code>, with the <code>Default</code> value for T.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CT%3E-for-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#590-596">Source</a><a href="#impl-From%3CT%3E-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#593-595">Source</a><a href="#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; Self</h4></section></summary><div class="docblock"><p>Creates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked.
This is equivalent to <a href="struct.RwLock.html#method.new" title="associated function std::sync::nonpoison::RwLock::new"><code>RwLock::new</code></a>.</p>
</div></details></div></details><section id="impl-Send-for-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#51">Source</a><a href="#impl-Send-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a>&gt; <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-Sync-for-RwLock%3CT%3E" class="impl"><a class="src rightside" href="../../../src/std/sync/nonpoison/rwlock.rs.html#54">Source</a><a href="#impl-Sync-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a> + <a class="trait" href="../../marker/trait.Send.html" title="trait std::marker::Send">Send</a> + <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a>&gt; <a class="trait" href="../../marker/trait.Sync.html" title="trait std::marker::Sync">Sync</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-RwLock%3CT%3E" class="impl"><a href="#impl-Freeze-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="../../marker/trait.Freeze.html" title="trait std::marker::Freeze">Freeze</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-RefUnwindSafe-for-RwLock%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; !<a class="trait" href="../../panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;</h3></section><section id="impl-Unpin-for-RwLock%3CT%3E" class="impl"><a href="#impl-Unpin-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../../marker/trait.Unpin.html" title="trait std::marker::Unpin">Unpin</a> + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section><section id="impl-UnwindSafe-for-RwLock%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-RwLock%3CT%3E" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.RwLock.html" title="struct std::sync::nonpoison::RwLock">RwLock</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../../panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="../../../src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../any/trait.Any.html" title="trait std::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../../../src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../any/struct.TypeId.html" title="struct std::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.Borrow.html" title="trait std::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="../../../src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../borrow/trait.BorrowMut.html" title="trait std::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../marker/trait.Sized.html" title="trait std::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="../../../src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../../primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3C!%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#802">Source</a><a href="#impl-From%3C!%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;<a class="primitive" href="../../primitive.never.html">!</a>&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#803">Source</a><a href="#method.from-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="primitive" href="../../primitive.never.html">!</a>) -&gt; T</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#788">Source</a><a href="#method.from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../convert/trait.From.html" title="trait std::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.Into.html" title="trait std::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../../convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../convert/enum.Infallible.html" title="enum std::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../convert/trait.TryInto.html" title="trait std::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="../../convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="../../../src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../result/enum.Result.html" title="enum std::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../convert/trait.TryFrom.html" title="trait std::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../convert/trait.TryFrom.html#associatedtype.Error" title="type std::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>