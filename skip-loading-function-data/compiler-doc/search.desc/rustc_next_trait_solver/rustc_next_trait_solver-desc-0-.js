searchState.loadedDescShard("rustc_next_trait_solver", 0, "Crate containing the implementation of the next-generation …\nThe next-generation trait solver, currently still WIP.\nWhether we’re canonicalizing a query input or the query …\nDoes this have infer/placeholder/param, free regions or …\nWhen canonicalizing the <code>param_env</code>, we keep <code>&#39;static</code> as …\nWhen canonicalizing predicates, we don’t keep <code>&#39;static</code>.\nFIXME: We currently return region constraints referring to …\nWe only use the debruijn index during lookup. We don’t …\nWhen canonicalizing query inputs, we keep <code>&#39;static</code> in the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe highest universe nameable by the caller.\nImproper orphan check for backward compatibility.\nWhether we do the orphan check relative to this crate or …\nProper orphan check.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks whether a trait-ref is potentially implementable by …\nIgnore orphan check failures and exclusively search for …\nReturns whether all impls which would apply to the …\nAll possible values for a constant parameter already exist …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>Some</code> if we <em>were</em> able to replace bound vars. If …\nResolves ty, region, and const vars to their inferred …\nWe’re able to use a cache here as the folder does not …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicates that a <code>impl Drop for Adt</code> is <code>const</code> or not.\nIf the self type is an alias type, e.g. an opaque type or …\nConst conditions that need to hold for <code>[const]</code> alias …\nPredicate required for an alias projection to be …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nPossible ways the given goal can be proven.\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nHow many fixpoint iterations we should attempt inside of …\nA goal is a statement, i.e. <code>predicate</code>, we want to prove …\nThe result of evaluating a goal.\nWhy a specific goal has to be proven.\nThe conditions that must change for a goal to warrant\nWhether evaluating this goal ended up changing the …\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\n<code>MetaSized</code> trait\nSome built-in impl we don’t need to differentiate. This …\nPreferred eagerly.\nIn case normalizing aliases in nested goals cycles, …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment. Stores a <code>ParamEnvSource</code>…\nOpaques that are defined in the inference context before a …\nThe result of evaluating a canonical query.\n<code>Sized</code> trait\nWhich sizedness trait - <code>Sized</code>, <code>MetaSized</code>? <code>PointeeSized</code> is …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nA built-in impl that is considered trivial, without any …\nA nested goal required to prove that types are …\nImplements the <code>AliasRelate</code> goal, which is used when …\nUse this function to merge the certainty of multiple …\nFor some deeply nested <code>&lt;T&gt;::A::B::C::D</code> rigid associated …\nAssemble and merge candidates for goals which are related …\nCode shared by trait and projection goals for candidate …\nCanonicalizes the goal remembering the original values for …\nCompute whether a param-env assumption is global or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes the region constraints and <em>new</em> opaque types …\nThis returns the canonical variable values to instantiate …\nIn coherence we have to not only care about all impls we …\nWhat kind of goal we’re currently computing, see the …\nThe inference context that backs (mostly) inference and …\nDealing with host effect goals, i.e. enforcing the …\nTo return the constraints of a canonical query to the …\nEvaluates a goal from <strong>outside</strong> of the trait solver.\nAdditional constraints returned by this query.\nCheck whether we can ignore impl candidates due to …\nIf we fail to merge responses we flounder and return …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe goal we’ve evaluated. This is the input goal, but …\nThe opaque types from the canonical input. We only need to …\nAfter calling a canonical query, we apply the constraints …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstructs a totally unconstrained, ambiguous response to …\nThe highest universe index nameable by the caller.\n<code>probe_kind</code> is only called when proof tree building is …\nReturns <code>DefId</code> of corresponding language item.\nCheck whether evaluating <code>goal</code> with a depth of <code>root_depth</code> …\nThe cause that will be returned on subsequent evaluations …\nIf the <code>Certainty</code> was <code>Maybe</code>, then keep track of whether the …\nNormalize a const for when it is structurally matched on, …\nNormalize a term for when it is structurally matched on.\nNormalize a type for when it is structurally matched on.\nDealing with trait goals, i.e. <code>T: Trait&lt;&#39;a, U&gt;</code>.\nTry to merge multiple possible ways to prove a goal, if …\nUnify the <code>original_values</code> with the <code>var_values</code> returned by …\nThe variable info for the <code>var_values</code>, only used to make an …\nUpdates the goal to one with a different <code>predicate</code> but the …\nAllows callers of <code>assemble_and_evaluate_candidates</code> to …\nA candidate is a possible way to prove a goal.\nOnly assemble candidates from the environment and alias …\nThis is currently used to track the CandidateHeadUsages of …\nMethods used to assemble candidates for either trait or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAssemble additional assumptions for an alias that are not …\nA type implements an <code>auto trait</code> if its components do as …\nCompute the built-in logic of the <code>AsyncFnKindHelper</code> helper …\nAn async closure is known to implement the <code>AsyncFn&lt;A&gt;</code> …\nA type is <code>Copy</code> or <code>Clone</code> if its components are <code>Copy</code> or <code>Clone</code>…\nA coroutine (that doesn’t come from an <code>async</code> or <code>gen</code> …\nA type is a <code>FnPtr</code> if it is of <code>FnPtr</code> type.\nA callable type (a closure, fn def, or fn ptr) is known to …\nA coroutine (that comes from a <code>gen</code> desugaring) is known to …\nA coroutine (that comes from an <code>async</code> desugaring) is known …\nA coroutine (that comes from a <code>gen</code> desugaring) is known to …\n<code>Pointee</code> is always implemented.\nA type is <code>Sized</code> if its tail component is <code>Sized</code> and a type …\n<code>Tuple</code> is implemented if the <code>Self</code> type is a tuple.\nIf the predicate contained an error, we want to avoid …\nConsider (possibly several) candidates to upcast or unsize …\nA trait alias holds if the RHS traits and <code>where</code> clauses …\nTry to reject the assumption based off of simple …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRelate the goal and assumption.\nConsider a clause, which consists of a “assumption” …\nConsider a clause specifically for a <code>dyn Trait</code> self type. …\nTry equating an assumption predicate against a goal’s …\nCode which is used by built-in goals that match “…\nMarker for bailing with ambiguity.\nRelevant types for an async callable, including its …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGiven a coroutine-closure, project to its returned …\nGiven a coroutine-closure, project to its returned …\nType returned by <code>await</code>ing the output i.e. <code>f().await</code>.\nThis duplicates …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nType returned by calling the closure i.e. <code>f()</code>.\nAssemble a list of predicates that would be present on a …\nTry to replace an alias with the term present in the …\nWe’re proving an trait goal for a coinductive trait, …\nThe kind of goal we’re currently proving.\nUnlike other goals, <code>NormalizesTo</code> goals act like functions …\nEagerly replace aliases with inference variables, emitting …\nCanonicalization is used to separate some goal from its …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nWe have the following builtin impls for arrays:\nTrait upcasting allows for coercions between trait objects:\nWe generate a builtin <code>Unsize</code> impls for structs with …\nWhat kind of goal we’re currently computing, see the …\nThe inference context that backs (mostly) inference and …\nCreates a nested evaluation context that shares the same …\n<code>enter_forall</code>, but takes <code>&amp;mut self</code> and passes it back …\nCreates a root evaluation context and search graph. This …\nEquates two values returning the nested goals without …\nThis sohuld only be used when we’re either instantiating …\nIterate over all added goals: returning <code>Ok(Some(_))</code> in …\nRecursively evaluates <code>goal</code>, returning whether any …\nRecursively evaluates <code>goal</code>, returning the nested goals in …\nEvaluates a goal from <strong>outside</strong> of the trait solver.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe opaque types from the canonical input. We only need to …\nWhen normalizing an associated item, constrain the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe highest universe index nameable by the caller.\nReturns a ty infer or a const infer depending on whether …\nConvenience function for traits that are structural, i.e. …\nRecord impl args in the proof tree for later access by …\nThis should be used when relating a rigid alias with …\nCheck whether evaluating <code>goal</code> with a depth of <code>root_depth</code> …\nComputes the <code>PathKind</code> for the step from the current goal …\nUnlike <code>instantiate_normalizes_to_term</code> this instantiates …\nIs the projection predicate is of the form …\nFIXME(#57893): For backwards compatibility with the old …\nThe variable info for the <code>var_values</code>, only used to make an …\nComputes the list of goals required for <code>arg</code> to be …\nUsed by proof trees to be able to recompute intermediate …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nUsed to do a probe to find out what projection type(s) …\nA trait goal was satisfied by an impl candidate.\nChecking that a rigid alias is well-formed.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nUsed in the probe that wraps normalizing the non-self type …\nBuilding proof trees incrementally during trait solving.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat happened inside of this probe in chronological order.\nThis is always <code>ProbeKind::Root</code>.\nThe current state of the proof tree builder, at most places\nThe core data structure when building proof trees.\nThis only exists during proof tree building and does not …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAfter we finished evaluating this is moved into <code>kind</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUnlike <code>EvalCtxt::var_values</code>, we append a new generic arg …\nComputes a normalizes-to (projection) goal for inherent …\nComputes a normalizes-to (projection) goal for inherent …\nComputes a normalizes-to (projection) goal for opaque …\nThis type is never constructed. We only use it to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWe’ve proven the trait goal by something which is is not …\nHow we’ve proven this trait goal.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSmall helper function to change the <code>def_id</code> of a trait …")