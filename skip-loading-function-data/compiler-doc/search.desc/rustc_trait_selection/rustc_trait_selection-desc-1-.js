searchState.loadedDescShard("rustc_trait_selection", 1, "Replaces args that reference param or infer variables with …\nDiagnostics only: the ‘root’ obligation which resulted …\nSpan of the scrutinee of the match (the matched value).\nCandidate selection. See the rustc dev guide for more …\nWe often create nested obligations without setting the …\nSource of the match, i.e. <code>match</code> or a desugaring.\nLogic and data structures related to impl specialization, …\nComputes the def-ids of the transitive supertraits of …\nIs the expectation of this match expression an RPIT?\nA specialized variant of <code>elaborate</code> that only elaborates …\nGiven the generic parameters for the requested impl, …\nLike translate_args, but obligations from the parent …\nEvaluates a type system constant making sure to not allow …\nTry to start normalize <code>key</code>; returns an error if …\nDetermines whether the type <code>ty</code> is known to meet <code>bound</code> and …\nCasts a trait reference into a reference to one of its …\nThe snapshot in which this context was created. Using the …\nCore logic responsible for determining what it means for …\nExecutes <code>f</code> on <code>value</code> after replacing all escaping bound …\nOverflow is only <code>Some(suggest_recursion_limit)</code> when using …\nThe node of the relevant argument in the function call.\nThe node of the function call.\nSpan of the repeat element.\nIf element is a <code>const fn</code> or const ctor we display a help …\nInformation about the <code>Span</code>, if it came from an expression, …\nThe obligation introduced by this argument.\nThe root expected type induced by a scrutinee or type …\nThe span of the scrutinee or type expression which caused …\nIf we were able to successfully evaluate the corresponding …\nThe function to lookup the parameter in\nThe index of the parameter to use. Parameters are indexed …\nThis method is designed to work around the following issue:\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe core logic responsible for computing the bounds for …\nMakes a best effort to determine whether and under which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is very similar to <code>handle_lifetimes</code>. However, instead …\nImproper orphan check for backward compatibility.\nThe “header” of an impl is everything outside the …\nWhether we do the orphan check relative to this crate or …\nThe result of [fn …\nProper orphan check.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompute the <code>intercrate_ambiguity_causes</code> for the new solver …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if both impls can be satisfied by a common type by …\nCheck if both impls can be satisfied by a common type by …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>true</code> if the overlap might’ve been permitted before the …\nChecks whether a trait-ref is potentially implementable by …\nUsed in the new solver to suggest increasing the recursion …\nCan both impl <code>a</code> and impl <code>b</code> be satisfied by a common type …\nIf there are types that satisfy both impls, returns <code>Some</code> …\nReturns whether all impls which would apply to the …\nWith <code>-Znext-solver=coherence</code>, some obligations may fail if …\nCheck if a given constant can be evaluated.\nAssociated const.\nGAT\nMethod has something illegal.\n<code>Self: Sized</code> declared on the trait.\nSupertrait reference references <code>Self</code> an in illegal location\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis is somewhat subtle. In general, we want to forbid …\nReturns <code>Some(_)</code> if this item makes the containing trait …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the dyn-compatibility violations that affect HIR …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe say a method is <em>vtable safe</em> if it can be invoked on a …\nPerforms a type instantiation to produce the version of …\nChecks the method’s receiver (the <code>self</code> argument) can be …\nChecks for <code>const Trait</code> supertraits. We’re okay with …\nReturns <code>Some(_)</code> if this method cannot be called on a trait …\nThe reason we have to prove this thing.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAssembles constness bounds from <code>~const</code> item bounds on …\nAssembles constness bounds “normal” item bounds on …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe environment in which we should prove this thing.\nThe thing we are trying to prove.\nIf we started proving this as a result of trying to prove …\nUsed if you want to have pleasant experience when dealing …\nReturns the not-yet-processed and stalled obligations from …\nComputes the least-upper-bound, or mutual supertype, of …\nRequires that <code>ty</code> must implement the trait with <code>def_id</code> in …\nResolves regions and reports errors.\nResolves regions and reports errors.\nChecks whether <code>expected</code> is a subtype of <code>actual</code>: …\nChecks whether <code>expected</code> is a supertype of <code>actual</code>: …\nThe fulfillment context is used to drive trait resolution. …\nReturns the set of inference variables contained in <code>args</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIdentifies whether a predicate obligation needs processing.\nCreates a new fulfillment context.\nA list of all obligations that have been registered with …\nProcesses a predicate obligation and returns either:\nAttempts to select obligations using <code>selcx</code>.\nCompared to <code>needs_process_obligation</code> this and its callees …\nThe snapshot in which this context was created. Using the …\nCheck that all fields of a given <code>adt</code> implement <code>lang_item</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that the fields of the type (an ADT) all implement …\nChecks that the fields of the type (an ADT) all implement …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nDeeply normalizes <code>value</code>, replacing all aliases which can …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNormalize a value using the <code>AssocTypeNormalizer</code>.\nAs <code>normalize</code>, but with a custom depth.\nOutlives bounds are relationships between generic …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nDo <em>NOT</em> call this directly. You probably want to construct …\nImplied bounds are region relationships that we deduce …\nCalls <code>U::from(self)</code>.\nThe projection cannot be normalized due to ambiguity. …\nThe projection bound holds subject to the given …\nBounds specified on an object type\nFrom a where-clause in the env or object type\nStates returned from <code>poly_project_and_unify_type</code>. Takes …\nWhen attempting to resolve <code>&lt;T as TraitRef&gt;::Name</code> …\nThe project cannot be normalized because …\nFrom an “impl” (or a “pseudo-impl” returned by …\n…we found multiple sources of information and couldn’t …\nFrom the definition of <code>Trait</code> when you have something like …\n…an error occurred matching <code>T : TraitRef</code>\nIn the case of a trait object like …\nThe first thing we have to do is scan through the parameter\nIn the case of a nested projection like …\nThe reason we have to prove this thing.\nThe reason we have to prove this thing.\nThe reason we have to prove this thing.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfirm and normalize the given inherent projection.\nThe guts of <code>normalize</code>: normalize a specific projection …\nIf we are projecting <code>&lt;T as Trait&gt;::Item</code>, but <code>T: Trait</code> does …\nThe guts of <code>normalize</code>: normalize a specific projection …\nThe environment in which we should prove this thing.\nThe environment in which we should prove this thing.\nThe environment in which we should prove this thing.\nEvaluates constraints of the form:\nThe thing we are trying to prove.\nThe thing we are trying to prove.\nThe thing we are trying to prove.\nComputes the result of a projection type (if we can).\nEvaluates constraints of the form:\nIf we started proving this as a result of trying to prove …\nIf we started proving this as a result of trying to prove …\nIf we started proving this as a result of trying to prove …\nA set of constraints that need to be satisfied in order for\nResult of the …\nOutlives bounds are relationships between generic …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTypes that could not be resolved: projections and params.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>true</code> if the type results from a dereference of a raw …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCode for the ‘normalization’ query. This consists of a …\nResult of the normalization.\nIf Some(T), a type autoderef reported an error on.\nTypes that are required to be alive in order for this type …\nIf, during the computation of the dtorck constraint, we …\nWe will generate CandidateSteps which are reachable via a …\nIf <code>true</code>, <code>steps</code> has been truncated due to reaching the …\nThe valid autoderef steps that could be found by following …\nReturns a set of constraints that needs to be satisfied in …\nThis returns true if the type <code>ty</code> is “trivial” for …\nEvaluate a given predicate, capturing overflow and …\nHelper function that canonicalizes and runs the query. If …\nEvaluates whether the predicate can be satisfied (by any …\nEvaluates whether the predicate can be satisfied in the …\nEvaluates whether the predicate can be satisfied in the …\n<code>true</code> if the type results from a dereference of a raw …\nIf Some(T), a type autoderef reported an error on.\nWe will generate CandidateSteps which are reachable via a …\nIf <code>true</code>, <code>steps</code> has been truncated due to reaching the …\nThe valid autoderef steps that could be found by following …\nResult of the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResult of the normalization.\nNormalize <code>value</code> in the context of the inference context, …\nNormalizes, and deeply normalizes in the new solver.\nNormalizes, but not in the new solver.\n“Query type ops” are type ops that are implemented …\n“Type ops” are used in NLL to perform some particular …\nThe output from performing a type op\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAny region constraints from performing the type op.\nUsed for error reporting to be able to rerun the query\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProcesses the operation and all resulting obligations, …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe output from the type op.\nIn the new trait solver, we already do caching in the …\nPerforms the actual query with the canonicalized key – …\nGive query the option for a simple fast path that never …\nThe core of the <code>type_op_ascribe_user_type</code> query: for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nProcesses the operation and all resulting obligations, …\nCalls <code>U::from(self)</code>.\nExecutes <code>op</code> and then scrapes out all the “old style” …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nWhen we have an implied bound that <code>T: &#39;a</code>, we can further …\nCalls <code>U::from(self)</code>.\nNormalizes, and deeply normalizes in the new solver.\nNormalizes, but not in the new solver.\nImplementation of an <code>AsyncFn</code>-family trait by one of the …\nImplementation of the <code>AsyncFnKindHelper</code> helper trait, which\nImplementation of an <code>AsyncIterator</code> trait by one of the …\nA builtin implementation for some specific traits, used in …\nImplementation of a <code>Fn</code>-family trait by one of the …\nImplementation of a <code>Coroutine</code> trait by one of the …\nEvaluation is known to be ambiguous – it <em>might</em> hold for …\nEvaluation failed because of recursion involving inference …\nEvaluation failed.\nEvaluation successful.\nEvaluation successful, but need to rerun because opaque …\nEvaluation successful, but there were unevaluated region …\nThe result of trait evaluation. The order is important …\nImplementation of a <code>Fn</code>-family trait by one of the anonymous\nImplementation of a <code>Future</code> trait by one of the coroutine …\nImplementation of an <code>Iterator</code> trait by one of the …\nMatching <code>dyn Trait</code> with a supertrait of <code>Trait</code>. The index …\nIndicates that trait evaluation caused overflow and in …\nThis is a trait matching with a projected type as <code>Self</code>, …\nA cache value for the provisional cache: contains the …\nThe “provisional evaluation cache” is used to store …\nThe selection process begins by considering all impls, …\nA built-in implementation for the <code>Sized</code> trait. This is …\nPerform trait upcasting coercion of <code>dyn Trait</code> to a …\nImplementation of transmutability trait.\nEmits notes when the overlap is caused by complex …\nIf <code>true</code>, then there were candidates that might or might …\nDetermines whether can we safely cache the result of …\nReturns <code>true</code> if the global caches can be used.\nCandidate assembly.\nIf there is any previous entry on the stack that precisely …\nChecks that the recursion limit has not been exceeded.\nFor defaulted traits, we use a co-inductive strategy to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nConfirmation.\nFor default impls, we need to break apart a type into its …\nThe number of parent frames plus one (thus, the topmost …\nThe depth-first number of this node in the search graph –…\nnext “depth first number” to issue – just a counter\nEnables tracking of intercrate ambiguity causes. See the …\nFurther evaluates <code>candidate</code> to decide whether all type …\nEvaluates the predicates in <code>predicates</code> recursively. This …\nEvaluates whether the obligation <code>obligation</code> can be …\nComputes the evaluation result of <code>op</code>, discarding any …\nfilter_impls filters candidates that have a positive impl …\nfilter_reservation_impls filter reservation impl for any …\nLooks at the item bounds of the projection or opaque type. …\nThe trait predicate from <code>obligation</code> but “freshened” …\nFreshener used specifically for entries on the obligation …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck the provisional cache for any result for …\nReturns the obligations that are implied by instantiating …\nInsert a provisional result into the cache. The result came\nIf <code>intercrate</code> is set, we remember predicates which were …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMap from cache key to the provisionally evaluated thing. …\nEquates the trait in <code>obligation</code> with trait bound. If the …\nReturns <code>Ok</code> if <code>poly_trait_ref</code> being true implies that the …\nReturn <code>Yes</code> if the obligation’s predicate type applies to …\nNormalize <code>where_clause_trait_ref</code> and try to match it …\nGet the next DFN in sequence (basically a counter).\nInvoked when the node at depth <code>depth</code> completed without …\nInvoked when the node with dfn <code>dfn</code> does not get a …\nAttempts to satisfy the obligation. If successful, this …\nThe mode that trait queries run in, which informs our …\nStarts out equal to <code>depth</code> – if, during evaluation, we …\nGets the intercrate ambiguity causes collected since …\nIndicates that attempting to evaluate this stack entry …\nA list of candidates that definitely apply to the current …\nThe stack of terms that we assume to be well-formed …\nIf there are multiple ways to prove a trait goal, we make …\nA type “A” <em>matches</em> “B” if the fresh types in B …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicates that a <code>impl Drop for Adt</code> is <code>const</code> or not.\nIf the self type is an alias type, e.g. an opaque type or …\nConst conditions that need to hold for <code>[const]</code> alias …\nPredicate required for an alias projection to be …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nWhy a specific goal has to be proven.\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\n<code>MetaSized</code> trait\nSome built-in impl we don’t need to differentiate. This …\nPreferred eagerly.\nIn case normalizing aliases in nested goals cycles, …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment. Stores a <code>ParamEnvSource</code>…\nOpaques that are defined in the inference context before a …\n<code>Sized</code> trait\nWhich sizedness trait - <code>Sized</code>, <code>MetaSized</code>? <code>PointeeSized</code> is …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nA built-in impl that is considered trivial, without any …\nA nested goal required to prove that types are …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdditional constraints returned by this query.\nReturns the argument unchanged.\nReturns the argument unchanged.\nData structure used to inspect trait solver behavior.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nUsed to do a probe to find out what projection type(s) …\nA trait goal was satisfied by an impl candidate.\nChecking that a rigid alias is well-formed.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nUsed in the probe that wraps normalizing the non-self type …\nWhat happened inside of this probe in chronological order.\nThis is always <code>ProbeKind::Root</code>.\nChildren of a given impl, grouped into blanket/non-blanket …\nA per-trait graph of impls in specialization order. At the …\nInformation about the most specialized definition of an …\nA node in the specialization graph is either an impl or a …\nWhat kind of overlap check are we doing – this exists …\nThe 1.0 rules (either types fail to unify, or where …\nJust check for negative impls, not for “where clause not …\nFeature-gated test: Stable, <em>or</em> there is an explicit …\nWalk up the specialization ancestors of a given impl, …\nBlanket impls associated with the trait.\nThe “root” impls are found by looking up the trait’s …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe node in the specialization graph containing the …\nThe “top-most” (ie. least specialized) specialization …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert a local impl into the specialization graph. If an …\nInsert a local impl into the specialization graph. If an …\nAttempt to insert an impl into this set of children, while …\nInsert an impl into this set of children without comparing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this definition is known to not be further …\nTries to find the associated item that implements …\nThe associated item described by this <code>LeafDef</code>.\nFinds the bottom-most (ie. most specialized) definition of …\nImpls of the trait.\nThe parent of a given impl, which is the <code>DefId</code> of the …\nAll impls have a parent; the “root” impls have as …\nInsert cached metadata mapping from a child impl back to …\nInsert cached metadata mapping from a child impl back to …\nRemoves an impl from this set of children. Used when …\nInformation pertinent to an overlapping impl error.\nAttempt to fulfill all obligations of <code>target_impl</code> after …\nQuery provider for <code>specialization_graph_of</code>.\nIs <code>specializing_impl_def_id</code> a specialization of …\nGiven the generic parameters for the requested impl, …\nLike translate_args, but obligations from the parent …\nThe impl was inserted as a new child in this group of …\nChildren of a given impl, grouped into blanket/non-blanket …\nA per-trait graph of impls in specialization order. At the …\nThe result of attempting to insert an impl into a group of …\nInformation about the most specialized definition of an …\nA node in the specialization graph is either an impl or a …\nWhat kind of overlap check are we doing – this exists …\nThe impl should replace existing impls [X1, ..], because …\nThe impl is a specialization of an existing child.\nThe 1.0 rules (either types fail to unify, or where …\nJust check for negative impls, not for “where clause not …\nFeature-gated test: Stable, <em>or</em> there is an explicit …\nWalk up the specialization ancestors of a given impl, …\nLocate the definition of an associated type in the …\nBlanket impls associated with the trait.\nThe “root” impls are found by looking up the trait’s …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe node in the specialization graph containing the …\nThe “top-most” (ie. least specialized) specialization …\nReturns the argument unchanged.\nReturns the argument unchanged.\nAttempt to insert an impl into this set of children, while …\nInsert a local impl into the specialization graph. If an …\nInsert an impl into this set of children without comparing …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe associated item described by this <code>LeafDef</code>.\nImpls of the trait.\nAll impls have a parent; the “root” impls have as …\nInsert cached metadata mapping from a child impl back to …\nRemoves an impl from this set of children. Used when …\nDescribes how to elaborate an obligation into a …\n“Elaboration” is the process of identifying all the …\nA filter around an iterator of predicates that makes it …\nThe inverse of <code>BoundVarReplacer</code>: replaces placeholders …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nStart elaborating <code>Sized</code> - reqd during coherence checking, …\nReturn the trait and projection predicates that come from …\nFilter to only the supertraits of trait predicates, i.e. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a predicate to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTo improve performance, sizedness traits are not …\nComputes the def-ids of the transitive supertraits of …\nA specialized variant of <code>elaborate</code> that only elaborates …\nCasts a trait reference into a reference to one of its …\nExecutes <code>f</code> on <code>value</code> after replacing all escaping bound …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTurns option of iterator into an iterator (this is just …\nPrepare the segments for a vtable\nHelper for <code>prepare_vtable_segments</code> that returns <code>ControlFlow</code>…\nGiven a <code>dyn Subtrait</code> and <code>dyn Supertrait</code> trait object, find …\nGiven a trait <code>trait_ref</code>, iterates the vtable entries that …\nControls whether we “elaborate” supertraits and so …\nPushes the obligations required for an alias (except …\nPushes the obligations required for an inherent alias to …\nPushes all the predicates needed to validate that <code>term</code> is …\nPushes the obligations required for <code>trait_ref</code> to be WF …\nReturns the requirements for <code>clause</code> to be well-formed.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPoints the cause span of a super predicate at the relevant …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven an object type like <code>SomeTrait + Send</code>, computes the …\nReturns the set of obligations needed to make <code>arg</code> …\nReturns the obligations that make this trait reference …\nCompute the predicates that are required for a type to be …")