searchState.loadedDescShard("rustc_borrowck", 0, "This query borrow-checks the MIR to (further) ensure it is …\nThe places might partially overlap - in this case, we give …\nIndicates an outlives-constraint between a type or between …\nThe subject of a <code>ClosureOutlivesRequirement</code> – that is, …\nRepresents a <code>ty::Ty</code> for use in <code>ClosureOutlivesSubject</code>.\nAfter we borrow check a closure, we are left with various …\nRaw content of Fluent resource for this crate, generated …\nFrom the RFC: “A <em>deep</em> access means that all data …\nThe places are disjoint, so we know all extensions of them …\nAccess is Deep only when there is a Drop implementation …\nThe places have the same type, and are either completely …\nWe want use of immutable upvars to cause a “write to …\nWhen checking permissions for a place access, this flag is …\nThe degree of overlap between 2 places for borrow-checking.\nData propagated to the typeck parent by nested items. This …\nFrom the RFC: “A <em>read</em> means that the existing data may be\nKind of read access to a value (For informational purposes …\nKind of access to a value: read or write (For …\nSubject is a free region from the closure. Indicates a …\nFor two-phase borrows, we distinguish a reservation (which …\nFrom the RFC: “A <em>shallow</em> access means that the immediate …\nSubject is a type, typically a type parameter, but could …\nAssociate some local constants with the <code>&#39;tcx</code> lifetime\nFrom the RFC: “A <em>write</em> means that the data may be …\nKind of write access to a value (For informational …\nChecks an access to the given place to see if it is …\nThis field keeps track of when borrow errors are reported …\nAdds a suggestion when a closure is invoked twice with a …\nAdds an explanatory note if the move error occurs in a …\nAdd a note to region errors and borrow explanations when …\nAdd a label to region errors and borrow explanations when …\nAdds a suggestion to errors where an <code>impl Trait</code> is …\nAdds the place into the used mutable variables set\nAnnotate argument and return type of function and closure …\nAnnotate the first argument and return type of a function …\nAppends end-user visible description of the <code>local</code> place to …\nAll regions of <code>ty</code> must be of kind <code>ReVar</code> and must represent …\nThe set of borrows extracted from the MIR\nFinds the span of arguments of a closure (within …\nSignal an error due to an attempt to move out of the …\nChecks the permissions for the given place and read or …\nThrough #123739, <code>BackwardIncompatibleDropHint</code>s (BIDs) are …\nChecks whether a borrow of this place is invalidated when …\nReports an error if this is a borrow of local data. This …\nSubslices correspond to multiple move paths, so we iterate …\nDescribe the reason for the fake borrow that was assigned …\nGiven an expression, check if it is a method call …\nFinds the spans of a captured place within a closure or …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nA public API provided for the Rust compiler consumers. …\nEnd-user visible description of <code>place</code> if one can be found. …\nEnd-user visible description of the <code>field</code>nth field of <code>base</code>\nEnd-user visible description of the <code>field_index</code>nth field …\nEnd-user visible description of <code>place</code> if one can be found. …\nReturns the description of the root place for a …\nEnd-user visible description of <code>place</code> if one can be found. …\nBorrow checker diagnostics.\nPerform the actual borrow checking.\nTargeted error when encountering an <code>FnMut</code> closure where an …\nSuggest using <code>while let</code> for call <code>next</code> on an iterator in a …\nReturns structured explanation for <em>why</em> the borrow contains …\nThis fields keeps track of the <code>Span</code>s that we have used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nWalks the MIR adding to the set of <code>used_mut</code> locals that …\nFrom the <code>hir::Ty</code> of an async function’s lowered return …\nReturn the name of the provided <code>Ty</code> (that must be a …\nReturns the name of the provided <code>Ty</code> (that must be a …\nChecks for the case where <code>fr</code> maps to something that the …\nFinds an argument that contains <code>fr</code> and label it with a …\nChecks for arguments appearing in the (closure) return …\nFinds a closure upvar that contains <code>fr</code> and label it with a …\nMaps from an internal MIR region vid to something that we …\nLogic for lowering higher-kinded outlives constraints …\nAttempts to highlight the specific part of a type …\nAttempts to highlight the specific part of a type in an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if a closure is inferred to be an <code>FnMut</code> …\nUser cannot make signature of a trait mutable without …\nWhether this value can be written or borrowed mutably. …\nIf <code>place</code> is a field projection, and the field is being …\nDetermine how the borrow was later used. First span …\nSkip over locals that begin with an underscore or have no …\nUses <code>body.var_debug_info</code> to find the symbol\nNames of local (user) variables (extracted from …\nMap from MIR <code>Location</code> to <code>LocationIndex</code>; created when MIR …\nWe’ve found an enum/struct/union type with the generic …\nProvider for <code>query mir_borrowck</code>. Similar to <code>typeck</code>, this …\nCurrently MoveData does not store entries for all places in\nFinds the spans associated to a move or copy of move_place …\nMap the regions in the type to named regions, where …\nThe counter for generating new region names.\nThe entry point of the NLL borrow checker.\nTry to note when an opaque is involved in a borrowck error …\nThe number of external regions defined on the closure. In …\nRequirements between the various free regions defined in …\nThe borrowck rules for proving disjointness are applied …\nPolonius analysis and support code:\nWhen using <code>-Zpolonius=next</code>: the data used to compute …\nResults of Polonius analysis.\nFrom the NLL RFC: “Shallow prefixes are found by …\nReturns an iterator over the prefixes of <code>place</code> (inclusive) …\nRecord the region names generated for each region in the …\nRegion inference context. This contains the results from …\nThis means that some data referenced by <code>borrow</code> needs to …\nReports an error specifically for when data is escaping a …\nReport a specialized error when <code>FnMut</code> closures return a …\nReports a region inference error for the general case with …\nReports an illegal reassignment; for example, an …\nReport an error because the universal region <code>fr</code> was …\nProduces nice borrowck error diagnostics for all the …\nThis field keeps track of when borrow conflict errors are …\nHelper to retrieve span(s) of given borrow from the …\nIf a place is used after being moved as an argument to a …\nWe have <code>S { foo: val, ..base }</code>, and we suggest instead …\nWhen encountering a lifetime error caused by the return …\nIn a move error that occurs on a call within a loop, we …\nSuggest <code>map[k] = v</code> =&gt; <code>map.insert(k, v)</code> and the like.\nSuggest using closure argument instead of capture.\nGenerate a synthetic region named <code>&#39;N</code>, where <code>N</code> is the next …\nConverts a region inference variable into a <code>ty::Region</code> that\nReturns the <code>RegionVid</code> corresponding to the region returned …\nWe’ve found an enum/struct/union type with the generic …\nThis pass type-checks the MIR to ensure it is not broken.\nThis field keeps track of errors reported in the checking …\nCode to extract the universally quantified regions …\nInformation about upvars not necessarily preserved in …\nThis field keeps track of all the local variables that are …\nIf the function we’re checking is a closure, then we’…\nChecks if a borrowed value was captured by a trait object. …\nLocation where a two-phase borrow is activated, if a borrow\nLocation where the borrow is activated.\nLocations which activate borrows. NOTE: a given location …\nPlace to which the borrow was stored\nPlace from which we are borrowing\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this is a two-phase borrow, then we will record it as …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat kind of borrow this is\nMap from local to all the borrows on that local.\nThe fundamental map relating bitvector indexes to the …\nWhen we encounter a 2-phase borrow statement, it will …\nThe region for which this borrow is live\nLocation where the borrow reservation starts. In many …\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nA set of NLL region constraints. These include “outlives…\nZero value of the index.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nWhat caused this constraint?\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this constraint is promoted from closure requirements.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nConstructs a “normal” graph from the constraint set; …\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhere did this constraint arise?\nLike <code>graph</code>, but constraints a reverse graph where <code>R1: R2</code> …\nThe <code>Span</code> associated with the creation of this constraint. …\nRegion that must be outlived.\nThe region SUP must outlive SUB…\nVariance diagnostic information\nThe construct graph organizes the constraints by their …\nMarker trait that controls whether a <code>R1: R2</code> constraint …\nIn normal mode, a <code>R1: R2</code> constraint results in an edge …\nThis struct brings together a constraint set and a …\nIn reverse mode, a <code>R1: R2</code> constraint results in an edge …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreates a “dependency graph” where each region …\nCreates a “dependency graph” where each region …\nGiven a region <code>R</code>, iterate over all constraints <code>R: R1</code>.\nReturns all regions (#53178).\nGiven a region <code>R</code>, iterate over all regions <code>R1</code> such that …\nGiven the constraint set from which this graph was built …\nA <code>Body</code> with information computed by the borrow checker. …\nStruct used during mir borrowck to collect bodies with …\n<code>Borrows</code> stores the data used in the analyses that track …\nOptions determining the output behavior of …\nWhen checking if a place conflicts with another place, …\nThe recommended option. Retrieves the maximal amount of …\nMaps between a MIR Location, which identifies a particular …\nImplies <code>PoloniusInputFacts</code>, and additionally runs Polonius …\nA (kinda) newtype of <code>RegionVid</code> so we can implement <code>Atom</code> on …\nRetrieve the <code>Body</code> along with the <code>BorrowSet</code> and …\nLocation where a two-phase borrow is activated, if a borrow\nLocation where the borrow is activated.\nLocations which activate borrows. NOTE: a given location …\nPlace to which the borrow was stored\nA mir body that contains region identifiers.\nThe set of borrows occurring in <code>body</code> with data about them.\nPlace from which we are borrowing\nWhat caused this constraint?\n<code>cfg_edge(point1, point2)</code> for each edge <code>point1 -&gt; point2</code> in …\n<code>child_path(child, parent)</code> when the path <code>child</code> is the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe constraint-set, but in graph form, making it easy to …\nThe SCC computed from <code>constraints</code> and the constraint …\nThe outlives constraints computed by the type-check.\nContains the definition for every region variable. Region …\n<code>drop_of_var_derefs_origin(var, origin)</code> when the type of <code>var</code>…\nReturns <code>true</code> if there is a need to gather <code>PoloniusFacts</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf this constraint is promoted from closure requirements.\nThis function computes borrowck facts for the given def id …\nReturns <code>true</code> if we can safely ignore borrows of this place.\nPolonius input facts. Populated when using …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat kind of borrow this is\nThese reflect the <code>&#39;a: &#39;b</code> relations that are either …\nThe liveness constraints added to each region. For most …\n<code>loan_invalidated_at(point, loan)</code> indicates that the <code>loan</code> …\n<code>loan_issued_at(origin, loan, point)</code> indicates that the <code>loan</code>…\n<code>loan_killed_at(loan, point)</code> when some prefix of the path …\nMap from local to all the borrows on that local.\nThe fundamental map relating bitvector indexes to the …\nThe table that maps Polonius points to locations in the …\nWhere did this constraint arise?\nPolonius output facts. Populated when using …\n<code>path_accessed_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_assigned_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_is_var(path, var)</code> the root path <code>path</code> starting in …\n<code>path_moved_at_base(path, point)</code> when the <code>path</code> was moved at …\n<code>placeholder(origin, loan)</code> describes a placeholder <code>origin</code>, …\nHelper function for checking if places conflict with a …\nShould the Polonius input facts be computed?\nShould we run Polonius and collect the output facts?\nThe mir bodies of promoteds.\nThe region for which this borrow is live\nContext generated during borrowck, intended to be passed to\nLocation where the borrow reservation starts. In many …\nThe final inferred values of the region variables; we …\nThe <code>Span</code> associated with the creation of this constraint. …\nRegion that must be outlived.\n<code>subset_base(origin1, origin2, point)</code> when we require …\nThe region SUP must outlive SUB…\nType constraints that we check after solving.\n<code>universal_region(origin)</code> – this is a “free region” …\nInformation about how the universally quantified regions in\nMap universe indexes to information on why we created it.\n<code>use_of_var_derefs_origin(variable, origin)</code>: References …\n<code>var_defined_at(var, point)</code> when the variable <code>var</code> is …\n<code>var_dropped_at(var, point)</code> when the variable <code>var</code> is used …\n<code>var_used_at(var, point)</code> when the variable <code>var</code> is used for …\nVariance diagnostic information\nThe transient state of the dataflow analyses used by the …\n<code>Borrows</code> stores the data used in the analyses that track …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKill any borrows that conflict with <code>place</code>.\nAdd all borrows to the kill set, if those borrows are out …\nReturns the lowest statement in <code>start..=end</code>, where the …\nLoans are in scope while they are live: whether they are …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHelper struct for <code>explain_captures</code>.\nThe access is caused by capturing a variable for a closure.\nA call to <code>Fn(..)::call(..)</code>, desugared from …\nThe access is caused by using a variable as the receiver …\nA normal method call of the form <code>receiver.foo(a, b, c)</code>\nA call to an operator trait, desugared from operator …\nThis access has a single span associated to it: common …\nThis access is caused by a <code>match</code> or <code>if let</code> pattern.\nThe span(s) associated to a use of a place.\nAdd a span label to the arguments of the closure, if it …\nBuffer of diagnostics to be reported. A mixture of error …\nThis field keeps track of move errors that are to be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPrint diagnostics to explain why values are borrowed.\nReturns <code>false</code> if this place is not used in a closure.\nReturns <code>false</code> if this place is not used in a coroutine.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEnable/Disable tuple fields. For example <code>x</code> tuple. if it’…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains utilities for generating suggestions for borrowck …\nError reporting machinery for lifetime errors.\nReturns the span of <code>self</code>, in the case of a <code>ClosureUse</code> …\nReturns the span of <code>self</code>, in the case of a <code>ClosureUse</code> …\nAdd a span label to the use of the captured variable, if …\nAdd a subdiagnostic to the use of the captured variable, …\nThe <code>Span</code> of the <code>Target</code> associated type in the <code>Deref</code> impl …\nThe type <code>T::Deref</code> we are dereferencing to\nThe span of the args of the closure, including the <code>move</code> …\nThe span of the use resulting in capture kind Check …\nThis is true if the captured variable was from a coroutine.\nThe span of the method call on the variable\nThe definition span of the method being called\nThe span of the use resulting in the captured path Check …\nThe span of the variable being moved\nAny other reason.\nRelating two types which have binders.\nCreated from performing a <code>TypeOp</code>.\nWhat operation a universe was created for.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns an error to be reported if rerunning the type op …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstraints require that <code>error_element</code> appear in the …\nLook for <code>break</code> expressions within any arbitrary …\nGiven a set of spans representing statements initializing …\nDetect whether one of the provided spans is a statement …\nWhich case a StorageDeadOrDrop is for.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAnnotate the provided diagnostic with information about …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex of the “move out” that we found. The <code>MoveData</code> can\n<code>true</code> if we traversed a back edge while walking from the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFind all uses of (including assignments to) a <code>Local</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIllegal move due to attempt to move from behind a …\nIllegal move due to attempt to move out of a slice or …\nIllegal move due to attempt to move from field of an ADT …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe place the reference refers to: if erroneous code was …\nSuggestion for expressions, <code>&amp;x</code> to <code>&amp;mut x</code>, <code>&amp;x[i]</code> to …\nSuggests <code>.get_mut</code> in the case of <code>&amp;map[&amp;key]</code> for …\nType suggestion. Changes <code>&amp;self</code> to <code>&amp;mut self</code>, <code>x: &amp;T</code> to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFinds all statements that assign directly to local (i.e., …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven a field that needs to be mutable, returns a span …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf the type is a <code>Coroutine</code>, <code>Closure</code>, or <code>CoroutineClosure</code>\nIf possible, suggest replacing <code>ref</code> with <code>ref mut</code>.\nThis visitor contains the bulk of the logic for this lint.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n’a = ’b\nOutlives(a, [b, c, d, …]) =&gt; ’a: ’b + ’c + ’d + …\nCollects information about outlives constraints that …\n’a: ’static i.e. ’a = ’static and the user should …\nThe different things we could suggest.\nIf there is a suggestion to emit, add a diagnostic to the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdd the outlives constraint <code>fr: outlived_fr</code> to the set of …\nCompiles a list of all suggestions to be printed in the …\nThe list of outlives constraints that need to be added. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nEmit an intermediate note on the given <code>Diag</code> if the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> iff the <code>RegionNameSource</code> is a valid source …\nReturns a name for the region if it is suggestable. See …\nHigher-ranked subtyping error.\nInformation about the various region constraints involved …\nAny other lifetime error.\nA collection of errors encountered during region …\nA generic bound failure for a type test (<code>T: &#39;a</code>).\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe region element that erroneously must be outlived by …\nThe origin of the region.\nIndicates whether this is a reported error. We currently …\nThe placeholder free region.\nThe region that should outlive <code>shorter_fr</code>.\nThe placeholder region.\nThe region that should be shorter, but we can’t prove it.\nThe region corresponding to an argument.\nAn anonymous region from an async fn.\nAn anonymous region from an impl self type or trait\nThe region corresponding to the return type of a closure.\nThe region corresponding to a closure upvar.\nThe region from a type yielded by a coroutine.\nThe anonymous region corresponds to a region where the …\nThe anonymous region corresponds to a <code>&#39;_</code> in the generics …\nThe anonymous region corresponds to a reference that was …\nA bound (not free) region that was instantiated at the def …\nA free region that the user has a name (<code>&#39;a</code>) for.\nThe anonymous region corresponds to a region where the …\nA name for a particular region used in emitting …\nDescribes what to highlight to explain to the user that we…\nDenotes the source of a region that is named by a …\nThe <code>&#39;static</code> region.\nThe free region corresponding to the environment of a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe name of the region (interned).\nWhere the region comes from.\nA set of outlives constraints after rewriting to remove …\nThis SCC reaches no placeholders.\nThis SCC reaches at least one placeholder.\nAn annotation for region graph SCCs that tracks the values …\nA Visitor for SCC annotation construction.\nIf we have reached placeholders, determine if they can be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis method handles placeholders by rewriting the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe largest universe this SCC can name. It’s the smallest\nThe largest universe nameable from this SCC. It is the …\nMerge the reachable placeholders of two graph components.\nDetermines if the region variable definitions contain …\nThe representative Region Variable Id for this SCC.\nDetermine if the tracked universes of the two SCCs are …\nIf this SCC reaches a placeholder it can’t name, return …\nThe placeholder with the largest ID\nThe largest-universed placeholder we can reach\nThe placeholder with the smallest ID\nThe output of <code>nll::compute_regions</code>. This includes the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes the (non-lexical) regions from the input MIR.\n<code>-Zdump-mir=nll</code> dumps MIR annotated with NLL specific …\nProduces the actual NLL MIR sections to emit during the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhen using <code>-Zpolonius=next</code>: the data used to compute …\nRewrites the regions in the MIR to use NLL variables, also …\nDetermines if a given borrow is borrowing local data This …\nEncapsulates the idea of iterating over every borrow that …\nIf <code>place</code> is a field projection, and the field is being …\nReturns <code>true</code> if we can safely ignore borrows of this place.\nWhen checking if a place conflicts with another place, …\nChecks whether the <code>borrow_place</code> conflicts with the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHelper function for checking if places conflict with a …\nFor contravariant cases, we add a backward edge …\nFor invariant cases, we add both the forward and backward …\nThe direction a constraint can flow into. Used to create …\nFor covariant cases, we add a forward edge …\nThis struct holds the data needed to create the Polonius …\nThis struct holds the data needed by the borrowck error …\nThis struct holds the liveness data created during MIR …\nThe liveness data computed during MIR typeck: …\nThe regions that outlive free regions are used to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes live loans using the set of loans model for …\nUnlike NLLs, in polonius we traverse the cfg to look for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFunctions dedicated to fact generation for the …\nThe expected edge direction per live region: the kind of …\nThe set of regions that are live at a given point in the …\nThe liveness data we recorded during MIR typeck.\nThe localized outlives constraints that were computed in …\nRecord the variance of each region contained within the …\nA localized outlives constraint reifies the CFG location …\nA container of LocalizedOutlivesConstraints that can be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>-Zdump-mir=polonius</code> dumps MIR annotated with NLL and …\nEmits the polonius MIR, as escaped HTML.\nEmits a mermaid flowchart of the CFG blocks and edges, …\nEmits a mermaid flowchart of the polonius localized …\nEmits a mermaid flowchart of the NLL regions and the …\nEmits a mermaid flowchart of the NLL SCCs and the outlives …\nThe polonius dump consists of:\nProduces the actual NLL + Polonius MIR sections to emit …\nEmits a region’s label: index, universe, external name.\nFor every potentially drop()-touched region <code>region</code> in <code>local</code>…\nWhen requested, emit most of the facts needed by polonius:\nEmit facts needed for move/init analysis: moves and …\nEmit facts about the outlives constraints: the <code>subset</code> base …\nEmit universal regions facts, and their relations.\nMIR visitor extracting point-wise facts about accesses.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEmit polonius facts for variable defs, uses, drops, and …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nA (kinda) newtype of <code>RegionVid</code> so we can implement <code>Atom</code> on …\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\n<code>cfg_edge(point1, point2)</code> for each edge <code>point1 -&gt; point2</code> in …\n<code>child_path(child, parent)</code> when the path <code>child</code> is the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>drop_of_var_derefs_origin(var, origin)</code> when the type of <code>var</code>…\nReturns <code>true</code> if there is a need to gather <code>PoloniusFacts</code> …\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nThese reflect the <code>&#39;a: &#39;b</code> relations that are either …\n<code>loan_invalidated_at(point, loan)</code> indicates that the <code>loan</code> …\n<code>loan_issued_at(origin, loan, point)</code> indicates that the <code>loan</code>…\n<code>loan_killed_at(loan, point)</code> when some prefix of the path …\n<code>path_accessed_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_assigned_at_base(path, point)</code> when the <code>path</code> was …\n<code>path_is_var(path, var)</code> the root path <code>path</code> starting in …\n<code>path_moved_at_base(path, point)</code> when the <code>path</code> was moved at …\n<code>placeholder(origin, loan)</code> describes a placeholder <code>origin</code>, …\n<code>subset_base(origin1, origin2, point)</code> when we require …\n<code>universal_region(origin)</code> – this is a “free region” …\n<code>use_of_var_derefs_origin(variable, origin)</code>: References …\n<code>var_defined_at(var, point)</code> when the variable <code>var</code> is …\n<code>var_dropped_at(var, point)</code> when the variable <code>var</code> is used …\n<code>var_used_at(var, point)</code> when the variable <code>var</code> is used for …\nSimulates an access to a place.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nSimulates consumption of an operand.\nGenerates a new <code>loan_invalidated_at(L, B)</code> fact.\nEmit <code>loan_invalidated_at</code> facts.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSimulates mutation of a place.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEmit <code>loan_killed_at</code> and <code>cfg_edge</code> facts at the same time.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRecords the borrows on the specified local as <code>killed</code>.\nRecords the borrows on the specified place as <code>killed</code>. For …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaps between a MIR Location, which identifies a particular …\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nExtracts variances for regions contained within types. …\nAdds <code>LocalizedOutlivesConstraint</code>s between two connected …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nPropagate loans throughout the CFG: for each statement in …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPropagate loans within a region between two points in the …\nThe localized constraint graph indexes the physical and …\nA node in the graph to be traversed, one of the two …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCompute loan reachability to approximately trace loan …\nThe actual, physical, edges we have recorded for a given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe logical edges representing the outlives constraints …\nTraverses the constraints and returns the indexed graph of …\nReturns the outgoing edges of a given node, not its …\nFor a given outlives constraint and CFG edge, returns the …\nPropagate loans throughout the subset graph at a given …\nFor a given outlives constraint arising from a MIR …\nFor a given outlives constraint arising from a MIR …\nDoesn’t stop until it returns the base case (a Local or …\nStops at any dereference.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nN.B., the variants in <code>Cause</code> are intentionally ordered. …\npoint inserted because Local was dropped at the given …\npoint inserted because Local was live at the given Location\nWhen we have an unmet lifetime constraint, we try to …\nThe representative region variable for an SCC, tagged by …\nA “type test” corresponds to an outlives constraint …\nAdds annotations for <code>#[rustc_regions]</code>; see …\nLike <code>universal_upper_bound</code>, but returns an approximation …\nTries to find the best constraint to blame for the fact …\nChecks if Polonius has found any unexpected free region …\nOnce regions have been propagated, this method is used to …\nChecks the final value for the free region <code>fr</code> to see if it …\nChecks that we can prove that <code>longer_fr: shorter_fr</code>. If we …\nOnce regions have been propagated, this method is used to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe constraint-set, but in graph form, making it easy to …\nWalks the graph of constraints (where <code>&#39;a: &#39;b</code> is considered …\nAccess to the SCC constraint graph. This can be used to …\nThe SCC computed from <code>constraints</code> and the constraint …\nThe outlives constraints computed by the type-check.\nContains the definition for every region variable. Region …\nWrite out the region constraint graph.\nWrite out the region constraint SCC graph.\nAs part of generating the regions, if you enable …\nWrite out our state into the <code>.mir</code> files.\nEvaluate whether <code>sup_region == sub_region</code>.\nEvaluate whether <code>sup_region: sub_region</code>.\nTests if <code>test</code> is true when applied to <code>lower_bound</code> at <code>point</code>.\nIf this is ’static or an early-bound region, then this is\nThe constraints we get from equating the hidden type of …\nTries to find the terminator of the loop in which the …\nFinds some region R such that <code>fr1: R</code> and <code>R</code> is live at …\nReturns the lowest statement index in <code>start..=end</code> which is …\nDebugging aid: Invokes the <code>with_msg</code> callback repeatedly …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe type <code>T</code> that must outlive the region.\nSearch the argument types for one that references fr …\nGiven the index of an argument, finds its name (if any) …\nSearch the upvars (if any) to find one that references fr. …\nGiven the index of an upvar, finds its name and the span …\nThis module provides linkage between …\nInitializes the region variables for each universally …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether the <code>loan_idx</code> is live at the given <code>location</code>…\nThe liveness constraints added to each region. For most …\nThe region <code>&#39;x</code> that the type must outlive.\nThe largest universe of any region nameable from this SCC.\nMap the regions in the type to named regions. This is …\nCreates a new region inference context with a total of …\nThis is a conservative normalization procedure. It takes …\nWhat kind of variable is this – a free region? …\nReturns an iterator over all the outlives constraints.\nPropagate the region constraints: this will grow the values\nWhen using <code>-Zpolonius=next</code>, records the given live loans …\nReturns <code>true</code> if the region <code>r</code> contains the point <code>p</code>.\nGet the region definition of <code>r</code>.\nGet the region outlived by <code>longer_fr</code> and live at <code>element</code>.\nReturns access to the value of <code>r</code> for debugging purposes.\nReturns an iterator over all the region indices.\nReturns the representative <code>RegionVid</code> for a given SCC. See …\nThe final inferred values of the region variables; we …\nPerforms region inference and report errors if we see any …\nThe span to blame.\nGiven a universal region in scope on the MIR, returns the …\nInvoked when we have some type-test (e.g., <code>T: &#39;X</code>) that we …\nWhen we promote a type test <code>T: &#39;r</code>, we have to replace all …\nAttempt to propagate a region error (e.g. <code>&#39;a: &#39;b</code>) that is …\nType constraints that we check after solving.\nInformation about how the universally quantified regions in\nWhich universe is this region variable defined in? This is …\nMap universe indexes to information on why we created it.\nReturns <code>true</code> if all the elements in the value of <code>scc_b</code> are …\nCheck if the SCC of <code>r</code> contains <code>upper</code>.\nA test which, if met by the region <code>&#39;x</code>, proves that this …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWe defer errors from [fn handle_opaque_type_uses] and only …\nA folder to map the regions in the hidden type to their …\nThis function is what actually applies member constraints …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis computes the actual hidden types of the opaque types …\nIn theory <code>apply_concrete_opaque_types</code> could introduce new …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis looks at all uses of opaque types in their defining …\nGiven the fully resolved, instantiated type for an opaque …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaps an NLL var to a deterministically chosen equal …\nThe opaque type using non NLL vars. This uses the actual …\nThe hidden type containing the member region.\nThe unexpected region.\nThe opaque type.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA slimmed down version of …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates a new <code>RegionCtxt</code> used to compute defining opaque …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nFor each SCC, the range of <code>universal_regions</code> that use that …\nAll of the universal regions, in grouped so that …\nFind all universal regions that are required to outlive …\nRecords the CFG locations where each region is live. When …\nA point in the control-flow graph.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nA single integer representing a <code>ty::Placeholder</code>.\nMaps from <code>ty::PlaceholderRegion</code> values that are used in …\nA placeholder (e.g., instantiated from a …\nAn individual element in a region value – the value of a …\nStores the full values for a set of regions (in contrast to\nA universally quantified region from the root universe …\nZero value of the index.\nRecords <code>region</code> as being live at all the control-flow …\nAdds all the control-flow points to the values for <code>r</code>.\nAdds the given element to the value for the given region. …\nRecords <code>region</code> as being live at the given <code>location</code>.\nRecords <code>region</code> as being live at all the given <code>points</code>.\nAdds all elements in <code>r_from</code> to <code>r_to</code> (because e.g., …\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if the region <code>r</code> contains the given element.\nReturns <code>true</code> if <code>sup_region</code> contains all the CFG points that\nReturns all the elements contained in a given region’s …\nReturns the lowest statement index in <code>start..=end</code> which is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nReturns the <code>PlaceholderIndex</code> for the inserted …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether <code>region</code> is marked live at the given <code>location</code>…\nWhen using <code>-Zpolonius=next</code>, returns whether the <code>loan_idx</code> …\nWhen using <code>-Zpolonius=next</code>, the set of loans that are live …\nReturns an iterator of all the points where <code>region</code> is live.\nWhich regions are live. This is exclusive with the …\nIterate through each region that has a value in this set.\nThe map from locations to points.\nReturns the locations contained within a given region <code>r</code>.\n<code>self[to] |= values[from]</code>, essentially: that is, take all …\nCreates a new set of “region values” that tracks …\nPlaceholders represent bound regions – so something like …\nReturns all the elements contained in a given region’s …\nReturns the liveness matrix of points where each region is …\nFor each region: the points where it is live.\nFor debugging purposes, returns a pretty-printed string of …\nFor debugging purposes, returns a pretty-printed string of …\nFor debugging purposes, returns a pretty-printed string of …\nWhen using <code>-Zpolonius=next</code>, records the given live loans …\nReturns a “pretty” string value of the region. Meant …\nIterate through each region that has a value in this set.\nReturns just the universal regions that are contained in a …\nCreate an empty map of regions to locations where they’…\nCreate an empty map of regions to locations where they’…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUsed to determine the representative of a component in the …\nReplaces all free regions appearing in the MIR with fresh …\nReplaces all regions appearing in <code>value</code> with fresh …\nThe shared context used by both the root as well as all …\nCollect all defining uses of opaque types inside of this …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThis should be <code>None</code> during normal compilation. See …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndicates that a type constraint should always be true. …\nRuns <code>infcx.instantiate_opaque_types</code>. Unlike other <code>TypeOp</code>s, …\nThe <code>Locations</code> type summarizes <em>where</em> region constraints are …\nA collection of region constraints that must be satisfied …\nHolder struct for passing results from MIR typeck to the …\nAn outlives constraint that only has to hold at a single …\nThe MIR type checker. Visits the MIR and enforces all the …\nAdds the constraints that arise from a borrow expression …\n<em>Incorrectly</em> skips the WF checks we normally do in …\nCheck explicit closure signature annotation, e.g., …\nEquate the inferred type and the annotated type for user …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdd sufficient constraints to ensure <code>a == b</code>. See also …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven some operation <code>op</code> that manipulates types, proves …\nThis module contains code to equate the input/output types …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIn general, the type-checker is not responsible for …\nEach time we add a placeholder to <code>placeholder_indices</code>, we …\nMaps from a <code>ty::Placeholder</code> to the corresponding …\nCreates a <code>Region</code> for a given <code>PlaceholderRegion</code>, or returns …\nWhen using <code>-Zpolonius=next</code>, the liveness helper data used …\nThe bodies of all promoteds. As promoteds have a …\nAdds sufficient constraints to ensure that <code>a R b</code> where <code>R</code> …\nIf this rvalue supports a user-given type annotation, then …\nGets a span representing the location.\nTry to relate <code>sub &lt;: sup</code>\nType checks the given <code>mir</code> in the context of the inference …\nUser type annotations are shared between the main MIR and …\nGiven an instance of the closure type, this method …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nEach RBP <code>GK: &#39;a</code> is assumed to be true. These encode …\nPlaceholder regions need to be converted eagerly because …\nAs part of computing the free region relations, we also …\nUpdate the type of a single local, which should represent …\nRegisters the <code>OutlivesBound</code> items from <code>outlives_bounds</code> in …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if fr1 is known to equal fr2.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the <code>&lt;=</code> relation; that is, if <code>a: b</code>, then <code>b &lt;= a</code>, …\nReturns the <em>non-transitive</em> set of known <code>outlives</code> …\nHelper for <code>non_local_upper_bounds</code> and …\nFinds a “lower bound” for <code>fr</code> that is not local. In …\nFinds an “upper bound” for <code>fr</code> that is not local. In …\nReturns <code>true</code> if fr1 is known to outlive fr2.\nStores the outlives relations that are known to hold from …\nGiven two universal regions, returns the postdominating …\nReturns a vector of free regions <code>x</code> such that <code>fr1: x</code> is …\nRecords in the <code>outlives_relation</code> (and …\nVisitor looking for regions that should be live within …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCombines liveness analysis with initialization analysis to …\nCalls <code>U::from(self)</code>.\nSome variable is “regular live” at <code>location</code> – i.e., …\nSome variables are “regular live” at <code>location</code> – …\nComputes all regions that are (currently) known to outlive …\nWe sometimes have <code>args</code> within an rvalue, or within a call. …\nWe sometimes have <code>region</code>s within an rvalue, or within a …\nWe sometimes have <code>ty</code>s within an rvalue, or within a call. …\nA map that cross references each local with the locations …\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nHead of a linked list of <strong>definitions</strong> of each variable – …\nHead of a linked list of <strong>drops</strong> of each variable – these …\nHead of a linked list of <strong>uses</strong> of each variable – use in …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContextual state for the type-liveness coroutine.\nAdds the definitions of <code>local</code> into <code>self.defs</code>.\nSome variable with type <code>live_ty</code> is “drop live” at …\nAdd extra drop facts needed for Polonius.\nStores the result that all regions in <code>value</code> are live for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nComputes all points where local is “drop live” – …\nExecutes one iteration of the drop-live analysis loop.\nComputes all points where local is “use live” – …\nSet of points that define the current local.\nCache for the results of <code>dropck_outlives</code> query.\nPoints where the current variable is “drop live” – …\nLocations where drops may occur.\nRuns dropck for locals whose liveness isn’t relevant. …\nComputes the <code>MaybeInitializedPlaces</code> dataflow analysis if …\nResults of dataflow tracking which variables (and paths) …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if the local variable (or some part of it) is …\nReturns <code>true</code> if the path <code>mpi</code> (or some part of it) is …\nReturns <code>true</code> if the local variable (or some part of it) is …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIndex indicating where each variable is assigned, used, or …\nDefines the <code>PointIndex</code> mapping\nMapping to/from the various indices used for …\nClear the value of fields that are “per local variable”…\nStack used when doing (reverse) DFS.\nThis is the heart of the liveness computation. For each …\nCurrent type-checker, giving us our inference context etc.\nPoints where the current variable is “use live” – …\nHow are we relating <code>a</code> and <code>b</code>?\nWhat category do we assign the resulting <code>&#39;a: &#39;b</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhere (and why) is this relation taking place?\nInformation so that error reporting knows what types we …\nThe MIR is a closure. The signature is found via …\nThe MIR represents some form of constant. The signature …\nThe MIR is a coroutine. The signature is that coroutines …\nThe MIR is a special kind of closure that returns …\nThe “defining type” for this MIR. The key feature of …\nAn <strong>external</strong> region is only relevant for closures, …\nThe MIR is a fn item with the given <code>DefId</code> and args. The …\nA <strong>global</strong> region is one that can be named from anywhere. …\nThe MIR represents an inline const. The signature has no …\nA <strong>local</strong> lifetime is one about which we know the full set …\nAs part of the NLL unit tests, you can annotate a function …\nReturns the args of the <code>DefiningTy</code>. These are equivalent …\nGiven a reference to a closure type, extracts all the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nBuilds a hashmap that maps from the universal regions that …\nReturns the “defining type” of the current MIR; see …\nThe “defining” type for this function, with all …\nWhether we’ve encountered an error region. If we have, …\nWe create region variables such that they are ordered by …\nSee <code>first_extern_index</code>.\nReplaces all free regions in <code>value</code> with region vids, as …\nIterates over the late-bound regions defined on <code>mir_def_id</code> …\nIterates over the late-bound regions defined on <code>mir_def_id</code> …\nA special region vid created to represent the current MIR …\nThe vid assigned to <code>&#39;static</code>\nThe vid assigned to <code>&#39;static</code>. Used only for diagnostics.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of implicit inputs – notably the “environment”\nFor those regions that may appear in the parameter …\nInitially, the <code>UniversalRegionIndices</code> map contains only the\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>r</code> is classified as a local region.\nReturns <code>true</code> if <code>r</code> is a member of this set of universal …\nReturns the number of universal regions created in any …\nGets an iterator over all the early-bound regions that …\nCreates a new and fully initialized <code>UniversalRegions</code> that …\nReturns the number of global plus external universal …\nThe total number of universal region variables …\nClassifies <code>r</code> as a universal region, returning <code>None</code> if this …\nSee UniversalRegionIndices::to_region_vid.\nConverts <code>r</code> into a local inference variable: <code>r</code> can either …\nReturns an iterator over all the RegionVids corresponding …\nThe fully liberated input types of this function, with all …\nThe return type of this function, with all regions …\nReturns a list of all the upvar types for this MIR. If …\nMIR visitor for collecting used mutable variables. The ’…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")