searchState.loadedDescShard("rustc_expand", 0, "Raw content of Fluent resource for this crate, generated …\nConverts a macro item into a syntax extension.\nConditional compilation stripping.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThis module implements declarative macros: old <code>macro_rules</code> …\nA token-based attribute macro.\nA token-based function-like macro.\nA token-based derive macro.\nFill-in macro expansion result, to allow compilation to …\nResult of an expansion that may need to be retried. …\nOne of these is made during expansion and incrementally …\nA glob delegation.\nError type that denotes indeterminacy.\nAn AST-based attribute macro.\nAn AST-based function-like macro.\nAn AST-based derive macro.\n<code>MacResult</code> implementation for the common case where you’…\nThe result of a macro expansion. The return values of the …\nA <code>macro_rules!</code> macro that can work as any <code>MacroKind</code>\nA trivial attribute “macro” that does nothing, only …\nNo value.\nExpansion produced a result (possibly dummy).\nExpansion produced a result (possibly dummy).\nExpansion could not produce a result and needs to be …\nExpansion could not produce a result and needs to be …\nSome value of type <code>T</code>.\nA struct representing a macro definition in “lowered” …\nA syntax extension kind.\nRepresents a thing that maps token trees to Macro Results\nSuppresses the <code>unsafe_code</code> lint for code produced by this …\nList of unstable features that are treated as stable …\nCreates a default MacResult that can be anything.\nSame as <code>any</code>, but must be a valid fragment, not error.\nReturns <code>Some(expander)</code> for a macro usable as an <code>Attr</code>; …\nReturns <code>Some(expander)</code> for a macro usable as a <code>LegacyBang</code>; …\nUsed for storing lints generated during expansion, like …\nBuilt-in macros have a couple of special properties like …\nPath resolution logic for <code>#[cfg_accessible(path)]</code>.\nShould debuginfo for the macro be collapsed to the …\nThe order of items in the HIR is unrelated to the order of …\nConstructs a syntax extension with default properties.\nThe macro’s deprecation info.\nDirectory to search child module files in, often (but not …\nA dummy bang macro <code>foo!()</code>.\nA dummy derive macro <code>#[derive(Foo)]</code>.\nEdition of the crate in which this macro is defined.\n<code>meta_item</code> is the attribute, and <code>item</code> is the item being …\nWhen we ‘expand’ an inert attribute, we leave it in …\nReturns a <code>Folder</code> for deeply expanding all macros in an AST …\nReturns span for the macro which originally caused the …\nReturns the current expansion kind’s description.\n<code>[expr1, expr2, ...]</code>\n<code>&amp;[expr1, expr2, ...]</code>\nStack of paths to files loaded by out-of-line module items,\nError recovery mode entered when expansion is stuck (or …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a <code>MacroExpanderResult::Ready</code> from a <code>TokenStream</code>.\nCreates a <code>MacroExpanderResult::Ready</code> from a <code>TokenStream</code>.\nif-ext - if macro from different crate (related to …\nDecodes the proc-macro quoted span in the specified crate, …\nNames of specific methods to which glob delegation expands.\nDoes <code>#[derive(...)]</code> attribute with the given <code>ExpnId</code> have …\nNames of helper attributes registered by this macro.\nRecord the name of an opaque <code>Ty::ImplTrait</code> pre-expansion …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA syntax extension kind.\nSome parent node that is close to this macro call\nUsed for running pre-expansion lints on freshly loaded …\nEnables the macro helper hack (<code>ident!(...)</code> -&gt; …\nThis method increases the internal macro errors count and …\nReturns which kinds of macro call this syntax extension.\n<code>-Zmacro-stats</code> data.\nCreates an expression.\nCreates zero or more items in an <code>extern {}</code> block\nCreates zero or more impl items.\nCreates zero or more items.\nCreates a pattern.\nCreates zero or more statements.\nCreates zero or more impl items.\nCreates zero or more trait items.\nPath to the module starting from the crate name, like …\nReturns a <code>Folder</code> that deeply expands all macros and …\nConstructs a syntax extension with the given properties …\nIf this item looks like a specific enums from <code>rental</code>, emit …\nA plain dummy expression.\nMark this invocation id as a glob delegation.\nTools registered with <code>#![register_tool]</code> and used by tool …\nResolve paths inside the <code>#[derive(...)]</code> attribute with the …\nResolves a <code>path</code> mentioned inside Rust code, returning an …\nSpan of the macro definition.\nThe macro’s stability info.\nGenerates <code>let _: Type;</code>, which is usually used for type …\nTake resolutions for paths inside the <code>#[derive(...)]</code> …\nEquivalent of <code>Span::call_site</code> from the proc macro API, …\nEquivalent of <code>Span::def_site</code> from the proc macro API, …\nEquivalent of <code>Span::mixed_site</code> from the proc macro API, …\nA folder that strips out items that do not belong in the …\nIf <code>true</code>, perform cfg-stripping on attached tokens. This is …\nPerforms cfg-expansion on <code>stream</code>, producing a new …\nParse and expand a single <code>cfg_attr</code> attribute into a list …\nReturns the argument unchanged.\nDetermines if a node with the given attributes should be …\nCalls <code>U::from(self)</code>.\nIf attributes are not allowed on expressions, emit an …\nFIXME: Still used by Rustdoc, should be removed after\nParse and expand all <code>cfg_attr</code> attributes into a list of …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA fragment of AST that can be produced by a single macro …\n“Discriminant” of an AST fragment.\nRequired for <code>visit_node</code> obtained an owned <code>Node</code> from …\nA trait implemented for all <code>AstFragment</code> nodes and …\nThis struct is a hack to workaround unstable of …\nWraps a call to <code>walk_*</code> / <code>walk_flat_map_*</code> for an AST node …\nCollects all macro invocations reachable at this time in …\nAll of the identifiers (items) declared by this node. This …\nA macro’s expansion does not fit in this fragment kind. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRecursively expand all macro invocations in this AST …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf true, show backtraces for proc-macro panics\nIf false, strip <code>#[test]</code> nodes\nIf true, use verbose debugging for <code>proc_macro::Span</code>\nIf <code>item</code> is an attribute invocation, remove the attribute …\nRequired for resolving derive helper attributes.\nWhether this is a trait impl or an inherent impl\nRe-insertion position for inert attributes.\nContains the sub-token-trees of a “delimited” token …\nA delimited sequence, e.g. <code>($e:expr)</code> (RHS) or <code>{ $e }</code> (LHS).\nA Kleene-style repetition operator for token sequences.\ne.g., <code>$var</code>. The span covers the leading dollar and the …\ne.g., <code>$var:expr</code>. Only appears on the LHS.\nA meta-variable expression inside <code>${...}</code>.\nKleene plus (<code>+</code>) for one or more repetitions\nA kleene-style repetition sequence, e.g. <code>$($e:expr)*</code> (RHS) …\nA token. Unlike <code>tokenstream::TokenTree::Token</code> this lacks a …\nSimilar to <code>tokenstream::TokenTree</code>, except that <code>Sequence</code>, …\nKleene star (<code>*</code>) for zero or more repetitions\nKleene optional (<code>?</code>) for zero or one repetitions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given token tree is delimited.\nReturns <code>true</code> if the given token tree is a token of the …\nWhether the sequence can be repeated zero (*), or one or …\nChecks that meta-variables in macro definition are …\nThis is an NFA-based parser, which calls out to the main …\nThe number of <code>Match</code>s that appear in the sequence (and …\nThe optional separator\nRetrieves the <code>TokenTree</code>’s span.\nFIXME: #67062 has details about why this is sub-optimal.\nThe sequence of token trees\nThe fragment specifier.\nName to bind.\nThe tracker used for the slow error path that collects …\nWhich arm’s failure should we report? (the one furthest …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerates an appropriate parsing failure message. For EOF, …\nInformation attached to a meta-variable binder in LHS.\nAn environment of meta-variables to their binder …\nEmpty stack.\nNothing that matches a nested macro definition was …\nThe keyword <code>macro</code> was processed.\nThe keyword <code>macro</code> followed by a name was processed.\nThe keyword <code>macro</code> followed by a name and a token delimited …\nThe token <code>macro_rules</code> was processed.\nThe tokens <code>macro_rules!</code> were processed.\nThe tokens <code>macro_rules!</code> followed by a name were processed. …\nThe state at which we entered a macro definition in the …\nRepresents the processed prefix of a nested macro.\nA non-empty stack.\nStack represented as linked list.\nThe binders of the branch where we entered the macro …\nChecks <code>lhs</code> as part of the LHS of a macro definition, …\nChecks that meta-variables are used correctly in one rule …\nChecks the body of nested macro, returns where the check …\nChecks <code>tts</code> as part of the RHS of a macro definition, tries …\nChecks <code>rhs</code> as part of the RHS of a macro definition and …\nChecks that a meta-variable occurrence is valid.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the binder information of a meta-variable.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether a stack is empty.\nThe stack of Kleene operators (outermost first).\nThe stack of Kleene operators (outermost first) where we …\nReturns whether <code>binder_ops</code> is a prefix of <code>occurrence_ops</code>.\nReturns a new stack with an element of top.\nThe span of the meta-variable in LHS.\nThe previous elements.\nThe top element.\nFatal error (malformed macro?). Abort compilation.\nFatal error (malformed macro?). Abort compilation.\nArm failed to match. If the second parameter is <code>token::Eof</code>…\nArm failed to match. If the second parameter is <code>token::Eof</code>…\nA unit within a matcher that a <code>MatcherPos</code> can refer to. …\nA single matcher position, representing the state of …\n<code>NamedMatch</code> is a pattern-match result for a single metavar. …\nContains a mapping of <code>MacroRulesNormalizedIdent</code>s to …\nA <code>ParseResult</code> where the <code>Success</code> variant contains a mapping …\nRepresents the possible results of an attempted parse.\nParsed successfully.\nParsed successfully.\nThe set of mps that are waiting for the black-box parser.\nCount how many metavars declarations are in <code>matcher</code>.\nThe set of current mps to be processed. This should be …\nPre-allocate an empty match array, so it can be cloned …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe index into <code>TtParser::locs</code>, which represents the “dot…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe matches made against metavar decls so far. On a …\nThe set of newly generated mps. These are used to …\nMatch the token stream from <code>parser</code> against <code>matcher</code>.\nProcess the matcher positions of <code>cur_mps</code> until it is …\nAdds <code>m</code> as a named match for the <code>metavar_idx</code>-th metavar. …\nPerforms a token equality check, ignoring syntax context …\nAn attr rule, for use with <code>#[m]</code>\nA derive rule, for use with <code>#[m]</code>\nThe contents of <code>ParseResult::Failure</code>.\nA function-style rule, for use with <code>m!()</code>\nWe are not allowed to retry macro expansion as a fatal …\nA noop tracker that is used in the hot path of the …\nThis is only used for implicit token trees. The …\nThis is used in most cases.\nThis is called after an arm has been parsed, either …\nThis is called before trying to match next MatcherLoc on …\nArm failed to match. If the token is <code>token::Eof</code>, it …\nChecks that the lhs contains no repetition which could …\nChecks if a <code>vis</code> nonterminal fragment is unnecessarily …\nConverts a macro item into a syntax extension.\nFor tracing.\nExpands the rules based macro defined by <code>rules</code> for a given …\nExpands the rules based macro defined by <code>rules</code> for a given …\nReturns <code>true</code> if a fragment of type <code>frag</code> can be followed by …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>frag</code> can legally be followed by the token …\nWhether or not this macro is defined in the current crate\nThe ident of the macro we’re parsing\nSpan of the expansion site of the macro this parser is for\nTry expanding the macro. Returns the index of the …\nTry expanding the macro attribute. Returns the index of …\nTry expanding the macro derive. Returns the index of the …\nUnification of two or more identifiers.\nThe number of repetitions of an identifier.\nIdentifier WITHOUT a preceding dollar sign, which means …\nIgnore a meta-variable for repetition without expansion.\nThe index of the repetition at a particular depth, where 0 …\nThe length of the repetition at a particular depth, where …\nFor example, a number or a string.\nA meta-variable expression, for expansions based on …\nIndicates what is placed in a <code>concat</code> parameter. For …\nIdentifier WITH a preceding dollar sign, which means that …\nChecks if there are any remaining tokens (for example, …\nExpects that the next item is a dollar sign.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a span encompassing all tokens in the iterator if …\nAttempt to parse a meta-variable expression from a token …\nParse a meta-variable <code>concat</code> expression: …\nParse a meta-variable <code>count</code> expression: …\nParses the depth used by index(depth) and len(depth).\nParses an generic ident\nTries to move the iterator forward returning <code>true</code> if there …\nTries to move the iterator forward returning <code>true</code> if there …\nThe right-hand side body, with metavar references and …\nThe left-hand side, with patterns and metavar definitions …\nWhich part of a macro rule we’re parsing\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTakes a token and returns <code>Some(KleeneOp)</code> if the token is <code>+</code> …\nAsks for the <code>macro_metavar_expr</code> feature if it is not …\nTakes a <code>tokenstream::TokenStream</code> and returns a …\nParse the next token tree of the input looking for a …\nTakes a <code>tokenstream::TokenTree</code> and returns a …\nAttempt to parse a single Kleene star, possibly with a …\nTakes a <code>tokenstream::TokenTree</code> and returns a …\nA <code>MetaVar</code> with an actual <code>MatchedSeq</code>. The length of the …\nTwo <code>Constraint</code>s on the same sequence had different …\nAn iterator over the token trees in a delimited token tree …\nAn accumulator over a TokenTree to be used with <code>fold</code>. …\nA Marker adds the given mark to the syntax context.\nContext needed to perform transcription of metavariable …\nNo constraints on length of matcher. This is true for any …\nUsed solely by the <code>count</code> meta-variable expression, counts …\nExtracts an metavariable symbol that can be an identifier, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nMap from metavars to matched tokens\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGiven a <code>tree</code>, make sure that all sequences have the same …\nLookup the meta-var named <code>ident</code> and return the matched …\nMark a span with the stored expansion ID and transparency.\nAllow marking spans.\nReturns a <code>NamedMatch</code> item declared on the LHS given an …\nStore the metavariable span for this original span into a …\nHandle the <code>${concat(...)}</code> metavariable expression.\nUsed by meta-variable expressions when an user input is …\nA stack of where we are in the repeat expansion.\nThe resulting token stream from the <code>TokenTree</code> we just …\nThe in-progress <code>result</code> lives at the top of this stack. …\nThe stack of things yet to be completely expanded.\nThis can do Macro-By-Example transcription.\nFind the matched nonterminal from the macro invocation, …\nTurn <code>${expr(...)}</code> metavariable expressionss into tokens.\nTurn <code>$(...)*</code> sequences into tokens.\nSpan marked with the correct expansion and transparency.\nFind incompatibilities in matcher/invocation sizes.\nReturns a path to a module.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDerive a submodule path from the first found …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSaves the provided span into the metadata of <em>the crate we </em>…\nNumber of bytes of code (when pretty-printed).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of lines of code (when pretty-printed).\nNumber of uses of the macro.")