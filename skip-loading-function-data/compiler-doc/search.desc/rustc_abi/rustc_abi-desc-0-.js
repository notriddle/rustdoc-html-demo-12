searchState.loadedDescShard("rustc_abi", 0, "ABI handling for rustc\nArm Architecture Procedure Call Standard, sometimes …\nA pair of alignments, ABI-mandated and preferred.\nAn identifier that specifies the address space that some …\nAlignment of a type in bytes (always a power of two).\nA tuple, closure, or univariant which cannot be coerced to …\nStruct-like placement, with precomputed offsets.\nABIs relevant to 32-bit Arm targets\nABIs defined for 32-bit Arm\nArray/vector-like placement, with all fields of identical …\nThe way we represent values to the backend\nBox. <code>unpin</code> indicates the absence of any pinned data. <code>global</code>…\npresumed C ABI for the platform\nCalling convention to determine codegen\n<code>ExternAbi::C</code> but spelled funny because x86\nextremely constrained barely-C ABI for TrustZone\nextremely constrained barely-C ABI for TrustZone\nAn ABI that rustc does not know how to call or define.\nAn ABI that rustc does not know how to call or define. …\nThe tag directly stores the discriminant, but possibly …\nUEFI ABI, usually an alias of C, but sometimes an …\nA type with no valid variants. Must be uninhabited.\nA union had no fields.\nEndianness of the target, which must match …\nABI we expect to see within <code>extern &quot;{abi}&quot;</code>\nEquivalent to <code>VariantIdx(0)</code>.\n“fastcall” has both GNU and Windows variants\ngnu-fastcall on “unix” and win-fastcall on “windows…\nThe <em>source-order</em> index of a field in a variant.\nDescribes how the fields of a type are located in memory.\nFixed-sized integer type, e.g. <code>i8</code>, <code>u32</code>, <code>i128</code>. The bool …\nFloating-point types.\nABI relevant to GPUs: the entry point for a GPU kernel\nAn entry-point function called by the GPU’s host\nRequirements for a <code>StableHashingContext</code> to be used in this …\nError from the <code>homogeneous_aggregate</code> test function, …\nYes, all the “leaf fields” of this struct are passed …\nReturn value from the <code>homogeneous_aggregate</code> test function.\nThe <code>bool</code> is the signedness of the <code>Integer</code> type.\nIntegers, also used for enum discriminants.\nABIs relevant to bare-metal interrupt targets\nCallee codegen for interrupts\nThe maximum supported number of lanes in a SIMD vector.\nA univariant, the last field of which may be coerced to …\nEnum-likes with more than one variant: each variant comes …\nMutable reference. <code>unpin</code> indicates the absence of any …\nNiche (values invalid for a type) encoding the …\nThere are no leaf fields at all.\nno “-unwind” variant can be used here\nAn element type of an SIMD type isn’t a primitive\nThe length of an SIMD type exceeds the maximum number of …\nEncodes extra information we have about a pointer. Note …\nPointer-sized integer type, i.e. <code>isize</code> and <code>usize</code>. The …\nHow pointers are represented in a given address space\nA univariant, but with a prefix of an arbitrary size &amp; …\nFundamental unit of memory access and layout.\nScalar primitives and <code>!</code>, which never have fields.\nAn entry-point function called by the GPU’s host\nThe fields or variants have irreconcilable reprs\nRepresents the repr options provided by the user.\nthat’s us!\nthe mostly-unused <code>unboxed_closures</code> ABI, effectively now an …\nFor things unlikely to be called, where reducing register …\nAn always-invalid ABI that’s used to test “this ABI is …\nInformation about one scalar component of a Rust type.\nShared reference. <code>frozen</code> indicates the absence of any …\nSingle enum variants, structs/tuples, unions, and all …\nSize of a type in bytes.\nA type was too large for the target platform.\n“stdcall” has both GNU and Windows variants\ngnu-stdcall on “unix” and win-stdcall on “windows”\nABI of the “system” interface, e.g. the Win32 API, …\nParsed Data layout for a target, which contains everything …\nwindows C++ ABI\nTrait that needs to be implemented by the higher-level …\nThe layout of a type, alongside the type itself. Provides …\nUnstable impl detail that directly uses Rust types to …\nAn unsized type was found in a location where a sized type …\nAll fields start at no offset. The <code>usize</code> is the field …\nnot a known ABI\nThe <em>source-order</em> index of a variant in a type.\nuses AVX and stuff\nInclusive wrap-around range of valid values, that is, if …\nABIs relevant to Windows or x86 targets\nABIs defined for x86-{32,64}\nLLVM’s <code>0</code> address space.\nThe length of an SIMD type is zero\nPointers into this address space contain extra metadata …\nAddress space information of all known address spaces.\nIf <code>safe</code> is <code>Some</code>, then the pointer is aligned as indicated.\nGet a flags value with all known bits set.\nFind the largest integer with the given alignment or less.\nThe <code>backend_repr</code> defines how this data will be represented …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nMinimum size of #[repr(C)] enums (default c_int::BITS, …\npsABI-mandated alignment for a vector type, if any\nReturns <code>true</code> if this type is valid for reordering and …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nReturns <code>true</code> if <code>v</code> is contained in the range.\nReturns <code>true</code> if all the values in <code>other</code> are contained in …\nCreates an instance of <code>TargetDataLayout</code>.\nThe intersection of a source flags value with the …\nReturns the discriminant type, given these <code>repr</code> options. …\nGet a flags value with all bits unset.\nChecks if these two <code>Layout</code> are equal enough to be …\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nThe seed to be used for randomizing a type’s layout\nSays where the fields are located within the layout.\nFinds the smallest Integer type which can represent the …\nFinds the smallest Integer type which can represent the …\nFinds the smallest integer with the given alignment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the Integer type from an IntegerType.\nConvert from a bits value.\nRounds <code>bits</code> up to the next-higher byte boundary, if <code>bits</code> is\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nReturns <code>Homogeneous</code> if this layout is an aggregate …\nGets source indices of the fields by increasing offsets.\nReturns <code>true</code> if this <code>#[repr()]</code> should inhabit “smart enum\nReturns <code>true</code> if this <code>#[repr()]</code> guarantees a fixed field …\nReturns <code>true</code> if this <code>#[repr()]</code> should inhibit union ABI …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the type is sized and a 1-ZST (meaning it …\nReturns <code>true</code> if this is an aggregate type (including a …\nWhether all known bits in this flags value are set.\nReturns <code>true</code> if all possible numbers are valid, i.e …\nReturns <code>true</code> if this is a bool\nWhether all bits in this flags value are unset.\nReturns <code>true</code> if <code>size</code> completely fills the range.\nReturns <code>true</code> if this is a scalar type\nReturns <code>true</code> if this is a signed integer scalar\nReturns <code>true</code> if this is a single signed integer scalar. …\nReturns <code>true</code> if this is an uninhabited type\nReturns <code>true</code> if this type can be left uninit.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the layout corresponds to an unsized type.\nReturns <code>true</code> if the type is a ZST and not unsized.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe leaf scalar with the largest number of invalid values …\nan alignment resembling the one LLVM would pick for a …\nObtain the greatest factor of <code>size</code> that is an alignment …\nThe largest alignment explicitly requested with <code>repr(align)</code>…\nChecks whether this range is considered non-wrapping when …\nChecks whether this range is considered non-wrapping when …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nReturns <strong>exclusive</strong> upper bound on object size in bytes, in …\nReturns <strong>exclusive</strong> upper bound on object size in bytes.\nParse data layout from an llvm data layout string\nGet the pointer alignment in the default data address …\nThe alignment of pointers for this address space\nGet the pointer alignment in a specific address space.\nGet the pointer index in the default data address space.\nThe size of the value a pointer can be offset by in this …\nGet the pointer index in a specific address space.\nGet the pointer size in the default data address space.\nThe size of the bitwise representation of the pointer.\nGet the pointer size in a specific address space.\nGet the primitive representation of this type, ignoring …\nThe randomization seed based on this type’s own repr and …\nThe intersection of a source flags value with the …\nReduces Align to an aligned factor of <code>size</code>.\nIf this is <code>None</code>, then this is a raw pointer, so size and …\nThe psABI alignment for a <code>Scalar</code> or <code>ScalarPair</code>\nThe psABI size for a <code>Scalar</code> or <code>ScalarPair</code>\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nTruncates <code>value</code> to <code>self</code> bits and then sign-extends it to …\nReturns the largest signed value that can be represented …\nReturns the smallest signed value that can be represented …\nIf <code>safe</code> is <code>Some</code>, then the pointer is either null or …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nDiscard validity range information and allow undef.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nTruncates <code>value</code> to <code>self</code> bits.\nThe alignment the type would have, ignoring any <code>repr(align)</code>…\nIs this type known to be uninhabted?\nReturns a dummy layout for an uninhabited variant.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nAllows the caller to mutate the valid range. This …\nEncodes information about multi-variant layouts. Even with …\nAlignments for vector types.\nReturns <code>self</code> with replaced <code>end</code>\nReturns <code>self</code> with replaced <code>start</code>\nIf true, the size is exact, otherwise it’s only a lower …\nMaps source order field indices to memory order indices, …\nOffsets for the first byte of each field, ordered to match …\nEven for unions, we need to use the correct registers for …\nThis is inbounds of the type of the niche field (not …\nThis range <em>may</em> contain <code>untagged_variant</code> or uninhabited …\nAlways <code>0</code> for types that cannot have multiple variants.\nError from the <code>homogeneous_aggregate</code> test function, …\nYes, all the “leaf fields” of this struct are passed …\nReturn value from the <code>homogeneous_aggregate</code> test function.\nThere are no leaf fields at all.\nTry to combine two <code>HomogeneousAggregate</code>s, e.g. from two …\nIf this is a homogeneous aggregate, returns the homogeneous\nABIs relevant to 32-bit Arm targets\nABIs defined for 32-bit Arm\nCalling convention to determine codegen\nAn ABI that rustc does not know how to call or define.\n“fastcall” has both GNU and Windows variants\nABI relevant to GPUs: the entry point for a GPU kernel\nABIs relevant to bare-metal interrupt targets\nCallee codegen for interrupts\n“stdcall” has both GNU and Windows variants\nABIs relevant to Windows or x86 targets\nABIs defined for x86-{32,64}\nArm Architecture Procedure Call Standard, sometimes …\npresumed C ABI for the platform\n<code>ExternAbi::C</code> but spelled funny because x86\nextremely constrained barely-C ABI for TrustZone\nextremely constrained barely-C ABI for TrustZone\nAn ABI that rustc does not know how to call or define. …\nUEFI ABI, usually an alias of C, but sometimes an …\nABI we expect to see within <code>extern &quot;{abi}&quot;</code>\nDefault ABI chosen for <code>extern fn</code> declarations without an …\ngnu-fastcall on “unix” and win-fastcall on “windows…\nAn entry-point function called by the GPU’s host\nAn entry-point function called by the GPU’s host\nthat’s us!\nthe mostly-unused <code>unboxed_closures</code> ABI, effectively now an …\nFor things unlikely to be called, where reducing register …\nAn always-invalid ABI that’s used to test “this ABI is …\ngnu-stdcall on “unix” and win-stdcall on “windows”\nABI of the “system” interface, e.g. the Win32 API, …\nwindows C++ ABI\nUnstable impl detail that directly uses Rust types to …\nuses AVX and stuff\nAn ABI “like Rust”\nA union had no fields.\nContains the error value\nDetermines towards which end of a struct layout …\nAn element type of an SIMD type isn’t a primitive\nContains the success value\nThe length of an SIMD type exceeds the maximum number of …\nThe fields or variants have irreconcilable reprs\nA type was too large for the target platform.\nAn unsized type was found in a location where a sized type …\nThe length of an SIMD type is zero\nCoroutine layout logic.\nCompute the layout for a coroutine.\nFormat an untranslated diagnostic for this type\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nsingle-variant enums are just structs, if you think about …\nOverlap eligibility and variant assignment for each …\nCompute the eligibility and assignment of each local.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute the full coroutine layout.\nEquivalent to <code>VariantIdx(0)</code>.\nThe <em>source-order</em> index of a field in a variant.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nThe second field, at index 1.\nTrait that needs to be implemented by the higher-level …\nThe layout of a type, alongside the type itself. Provides …\nThe <em>source-order</em> index of a variant in a type.\nZero value of the index.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nFinds the one field that is not a 1-ZST. Returns <code>None</code> if …")