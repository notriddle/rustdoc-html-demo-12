searchState.loadedDescShard("rustc_const_eval", 0, "<code>rustc_driver::main</code> installs a handler that will set this …\nRaw content of Fluent resource for this crate, generated …\nCheck the bodies of <code>const</code>s, <code>static</code>s and <code>const fn</code>s for …\nReturns the diagnostic message for this error.\nShortand for calling …\nAn interpreter for MIR used in CTFE and by miri\nInformation about the item currently being const-checked, …\nThe <code>Visitor</code> responsible for actually checking a <code>mir::Body</code> …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the kind of const context this <code>Item</code> represents (…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the given <code>def_id</code> (trait or function) is “…\nConcrete error types for all operations which may be …\nStructural const qualification.\nPropagate <code>Qualif</code>s between locals and query the results.\nCheck the const stability of the given item (fn or trait).\nEmits an error if an expression cannot be evaluated in the …\nEmits an error at the given <code>span</code> if an expression cannot …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if <code>local</code> is <code>HasMutInterior</code> at the given …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if <code>local</code> is <code>NeedsDrop</code> at the given <code>Location</code>.\nReturns <code>true</code> if <code>local</code> is <code>NeedsNonConstDrop</code> at the given …\nReturns whether this place can possibly escape the …\nReturns whether there are const-conditions.\nThe span of the current statement.\nA set that stores for each local whether it is “transient…\nA call to an <code>#[unstable]</code> const fn, <code>#[rustc_const_unstable]</code> …\nA call to a function that is in a trait, or has trait …\nA borrow of a type that contains an <code>UnsafeCell</code> somewhere. …\nThis op is for <code>&amp;mut</code> borrows in the trailing expression of …\nA function call where the callee is a pointer.\nA function call where the callee is not marked as <code>const</code>.\nA call to an intrinsic that is just not const-callable at …\nA call to an intrinsic that is just not const-callable at …\nAn operation that is <em>not allowed</em> in a const context.\nA call to a <code>panic()</code> lang item where the first argument is …\nAn operation that must be removed for const-checking to …\nComparing raw pointers for equality. Not currently …\nCasting raw pointer or function pointer to an integer. Not …\nAn operation that causes const-checking to fail, but is …\nAn access to a thread-local <code>static</code>.\nBuild an error message reporting that a function call is …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nIf this is true, then the feature is enabled, but we need …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ntrue if <code>def_id</code> is the function we are calling, false if …\nReturns an enum indicating whether this operation can be …\nThe feature that must be enabled to use this operation.\nWhether the feature gate was already checked (because the …\nWe indicate whether this is a function call, since we can …\nWhether it is allowed to use this operation from stable …\nLook for live drops in a const context.\nReturns <code>true</code> if we should use the more precise live drop …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWhether this <code>Qualif</code> might be evaluated after the promotion …\nThe name of the file used to debug the dataflow analysis …\nConstant containing interior mutability (<code>UnsafeCell&lt;T&gt;</code>). …\nWhether this <code>Qualif</code> is cleared when a local is moved from.\nConstant containing an ADT that implements <code>Drop</code>. This must …\nConstant containing an ADT that implements non-const <code>Drop</code>. …\nA “qualif”(-ication) is a way to look for something “…\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns <code>true</code> if <em>any</em> value of the given type could possibly …\nReturns <code>true</code> if this <code>Operand</code> contains qualif <code>Q</code>.\nReturns <code>true</code> if this <code>Place</code> contains qualif <code>Q</code>.\nExtracts the field of <code>ConstQualifs</code> that corresponds to …\nReturns <code>true</code> if this <code>Rvalue</code> contains qualif <code>Q</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the <code>Qualif</code> is structural in an ADT’s …\nThe dataflow analysis used to propagate qualifs on …\nThe state for the <code>FlowSensitiveAnalysis</code> dataflow analysis. …\nA <code>Visitor</code> that propagates qualifs between locals. This …\nDescribes whether a local’s address escaped and it might …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDescribes whether a local contains qualif.\n<code>&amp;</code> only allow mutation if the borrowed place is <code>!Freeze</code>.\nExtra machine state for CTFE, and the Machine instance.\nThe CTFE machine has some custom error kinds.\nCalled <code>const_make_global</code> twice.\nCalled <code>const_make_global</code> on a non-heap pointer.\nCalled <code>const_make_global</code> on a dangling pointer.\nCalled <code>const_make_global</code> on a pointer that does not start …\nHard error when dereferencing a misaligned pointer.\nIgnore all alignment requirements. This is mainly used in …\nPattern matching on consts with references would be …\nWhether to check alignment during evaluation.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nStores the <code>Machine</code> instance.\nThis function takes the place where the result of the …\nThe virtual memory system.\nCreate an interpreter context to inspect the given …\nThe number of terminators that have been evaluated.\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nThe virtual call stack.\nIf <code>Some</code>, we are evaluating the initializer of the static …\nComputes the tag (if any) for a given type and variant.\nThe results of the type checker, from rustc. The span in …\nMacro for machine-specific <code>InterpError</code> without allocation. …\nThe current context in case we’re evaluating in a …\nA cache of “data range” computations for unions (i.e., …\nIndicates whether <code>make_global</code> was called on this …\nMacro for machine-specific <code>InterpError</code> without allocation. …\nThe CTFE machine has some custom error kinds.\nCalled <code>const_make_global</code> twice.\nCalled <code>const_make_global</code> on a non-heap pointer.\nCalled <code>const_make_global</code> on a dangling pointer.\nCalled <code>const_make_global</code> on a pointer that does not start …\nEmit a lint from a const-eval situation, with a backtrace.\nCreate a diagnostic for a const eval error.\nThis function takes the place where the result of the …\nCreate an interpreter context to inspect the given …\nThe <code>InterpCx</code> is only meant to be used to do field and …\nThis function converts an interpreter value into a MIR …\nChecks whether a function-like definition is considered to …\nExtra machine state for CTFE, and the Machine instance.\nHard error when dereferencing a misaligned pointer.\nWhen hitting this many interpreted terminators we emit a …\nIgnore all alignment requirements. This is mainly used in …\nAfter this many interpreted terminators, we start emitting …\nThe limit used by <code>-Z tiny-const-eval-limit</code>. This smaller …\nFind the first stack frame that is within the current …\nPattern matching on consts with references would be …\nWhether to check alignment during evaluation.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nSee documentation on the <code>ptr_guaranteed_cmp</code> intrinsic. …\n“Intercept” a function call, because we have something …\nCalls <code>U::from(self)</code>.\nStores the <code>Machine</code> instance.\nThe virtual memory system.\nThe number of terminators that have been evaluated.\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nThe virtual call stack.\nIf <code>Some</code>, we are evaluating the initializer of the static …\nThe results of the type checker, from rustc. The span in …\nThe current context in case we’re evaluating in a …\nA cache of “data range” computations for unions (i.e., …\nIndicates whether <code>make_global</code> was called on this …\nEvaluates a constant and turns it into a type-level …\nValtrees don’t store the <code>MemPlaceMeta</code> that all …\nConverts a <code>ValTree</code> to a <code>ConstValue</code>, which is needed after …\nPut a valtree into memory and return a reference to that.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the diagnostic message for this error.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNeed to duplicate the field so that fluent also provides …\nDetermines whether <code>eval_mir_constant</code> can never fail …\nExtra data stored in every allocation.\nMetadata about an <code>AllocId</code>.\nThe return value of <code>get_alloc_info</code> indicates the “kind”…\nThe functionality needed by memory to manage its …\nA reference to some allocation that was already …\nA reference to some allocation that was already …\nType for the bytes of the allocation.\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nValidation of a <code>const</code>. <code>allow_immutable_unsafe_cell</code> says …\nA <code>const</code> item\nPass a copy of the given operand.\nExtra things to check for during validation of CTFE …\nA dead allocation.\nA marker trait returned by …\nMachines can define extra (non-instance) things that …\nAn argument passed to a function.\nThe value of a function pointer.\nA stack frame.\nExtra data stored in every call frame.\nWhat we store about a frame in an interpreter backtrace.\nA function allocation (that fn ptrs point to).\nThe memory kind to use for copied global memory (held in …\nJump to the next block in the caller, or cause UB if None …\nAn <code>Immediate</code> represents a single immediate self-contained …\nAllow for the argument to be passed in-place: destroy the …\nThe offset has to be inbounds, like <code>ptr::offset</code>.\nHow a constant value should be interned.\nA regular live data allocation.\nState of a local variable including a memoized layout\nA MemPlace with its layout. Constructing it is only …\nMethods of this trait signifies a point where CTFE …\nAdditional memory kinds a machine wishes to distinguish …\nWhether this kind of memory is allowed to leak\nInformation required for the sound usage of a <code>MemPlace</code>.\nAdditional memory kinds a machine wishes to distinguish …\nMemory’s allocation map\nThe unsized payload (e.g. length for slices or vtable …\nReturned by <code>InterpCx::pop_stack_frame_raw</code> when no cleanup …\nIndicates that we should <em>not</em> jump to the return/unwind …\n<code>Sized</code> types or unsized <code>extern type</code>\nIndicates that no special handling should be done - we’…\nDescribes the constraints placed on offset-projections.\nShould the machine panic on allocation failures?\nAn evaluated place, together with its type.\nA thing that we can project into, and that has a layout.\nValidation of a promoted.\nPointers are “tagged” with provenance information; …\nWhen getting the AllocId of a pointer, some extra data is …\nRepresents a set of <code>Size</code> values as a sorted list of ranges.\nState for tracking recursive validation of references\nData returned by <code>Machine::after_stack_pop</code>, and consumed by …\nWhere and how to continue when returning/unwinding from …\nA single scalar value (must have <em>initialized</em> <code>Scalar</code> ABI).\nA pair of two scalar value (must have <code>ScalarPair</code> ABI where …\nStack memory. Error if deallocated except during a stack …\nReturn type of <code>InterpCx::pop_stack_frame_raw</code>.\nThe <code>mutability</code> of the static, ignoring the type which may …\nValidation of a <code>static</code>\nThe root frame of the stack: nowhere else to jump to, so …\nA TypeId allocation.\nA value of fully uninitialized memory. Can have arbitrary …\nA vtable allocation.\nHow to traverse a value and what to do when we are at the …\nNo constraints, just wrap around the edge of the address …\nThe <code>Weiteable</code> trait describes interpreter values that can …\nReturn a “root” pointer for the given allocation: the …\nCalled to adjust global allocations to the Provenance and …\nCalled immediately after actual memory was allocated for a …\nCalled immediately after an “immediate” local variable …\nCalled immediately after an “immediate” local variable …\nCalled immediately after a stack frame got popped, but …\nCalled immediately after a stack frame got pushed and its …\nThis function provides the chance to reorder the order in …\nGives the machine a chance to detect more misalignment …\nAllocations local to this instance of the interpreter. The …\nApply non-determinism to float operations that do not …\nCalled to evaluate <code>Assert</code> MIR terminators that trigger a …\nCalled before a global allocation is accessed. <code>def_id</code> is …\nHook for performing extra checks on any memory read access,\nHook for performing extra operations on a memory …\nHook for performing extra checks on a memory read access. …\nHook for performing extra checks on a memory write access. …\nCalled just before the frame is removed from the stack …\nCalled before a basic block terminator is executed.\nCalled for all binary operations where the LHS has pointer …\nThe MIR for the function called on this frame.\nManages calling a concrete function (with known MIR body) …\nExecute <code>fn_val</code>. It is the hook’s responsibility to …\nDirectly process an intrinsic without pushing a stack …\nLow-level cast helper function. Converts an apfloat <code>f</code> into …\nLow-level cast helper function. This works directly on …\nReturns a <code>bool</code> saying whether the two arguments are …\nCheck whether the given function may be executed on the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nA lot of the flexibility above is just needed for <code>Miri</code>, …\nTests if the map contains the given key. Deliberately …\nCallers should prefer <code>AllocMap::contains_key</code> when it is …\nDetermines the result of a <code>NullaryOp::ContractChecks</code> …\nMake a copy of the given fn_arg. Any <code>InPlace</code> are …\nMake a copy of the given fn_args. Any <code>InPlace</code> are …\nTo be able to compare pointers with null, and to check …\nFunctions for reading and writing discriminants of …\nRead discriminant, return the user-visible discriminant. …\nThe visitor must have an <code>InterpCx</code> in it.\nWhether memory accesses should be alignment-checked.\nWhether to enforce the validity invariant for a specific …\nWhether to enforce the validity invariant <em>recursively</em>.\nAllows enabling/disabling tracing calls from within …\nDetermines the result of <code>min</code>/<code>max</code> on floats when the …\nMarks a pointer as exposed, allowing its provenance to be …\nReturn the <code>AllocId</code> for the given <code>extern static</code>.\nExtra data for the machine.\nMap for “extra” function pointers.\nReturns data based on the keys and values in the map.\nEntry point to all function calls.\nHandles ‘FloatToFloat’ and ‘FloatToInt’ casts.\nHelper function for argument untupling.\nTurn the given error into a human-readable string. Expects …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate the NaN returned by a float operation, given the …\nRead-only lookup.\nCompute the value passed to the constructors of the …\nReturns the salt to be used for a deduplicated global …\nMutable lookup.\nReturns a mutable reference to entry <code>k</code>. If no such entry …\nReturns a reference to entry <code>k</code>. If no such entry exists, …\nSee documentation on the <code>ptr_guaranteed_cmp</code> intrinsic. …\n“Intercept” a function call, because we have something …\nWhether Assert(OverflowNeg) and Assert(Overflow) MIR …\nCalled when the interpreter encounters a …\nInitiate a call to this function – pushing the stack …\nInitiate a tail call to this function – popping the …\nCalled immediately before a new stack frame gets pushed.\nInitialize the extra state of an allocation local to this …\nThe main entry point for creating a new stack frame: …\nInserts a new entry into the map.\nThe def_id and args of the current function.\nHandles ‘IntToInt’ and ‘IntToFloat’ casts.\nThis module specifies the type based interner for …\nIntern <code>ret</code>. This function assumes that <code>ret</code> references no …\nIntern <code>ret</code> and everything it references.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIntrinsics and other functions that the interpreter …\nGet the layout.\nDon’t modify if <code>Some</code>, this is only used to prevent …\nCheck if these two layouts look like they are …\nGet the length of a slice/string/array stored here.\nEntry point for obtaining the MIR of anything that should …\nIf this is <code>Right</code>, we are not currently executing any …\nThe list of locals for this stack frame, stored in order as\nThis module contains everything needed to instantiate an …\nStores the <code>Machine</code> instance.\nThe memory subsystem.\nThe virtual memory system.\nGet the metadata of a wide value.\nOffset the value by the given amount, replacing the layout …\nFunctions concerning immediate values and operands, and …\nAllows executing an alternative function when tracing is …\nCalled to trigger a non-unwinding panic.\nInitialize a single callee argument, checking the types …\nComputations on places – field projections, going from …\nThis file implements “place projections”; basically a …\nCalled on places used for in-place function argument and …\n“Int-to-pointer cast”\nConvert a pointer with provenance into an …\nHandles ‘FnPtrToPtr’ and ‘PtrToPtr’ casts.\nRead discriminant, return the variant index. Can also …\n<code>read_discriminant</code> can be hooked for better error messages.\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nRemoves an entry from the map.\nExecutes a retagging operation on a compound value. …\nExecutes a retagging operation for a single pointer. …\nAdditional information about the action to be performed …\nWhere to continue when returning from this function.\n<code>return_cont</code> of the popped stack frame.\nPops the current frame from the stack, copies the return …\nThe location where the result of the current stack frame …\n<code>return_place</code> of the popped stack frame.\nManages the low-level pushing and popping of stack frames …\nBorrow the current thread’s stack.\nMutably borrow the current thread’s stack.\nReturns the <code>DefId</code> of the static item that is currently …\nThis module contains the <code>InterpCx</code> methods for executing a …\nComputes how to write the tag of a given variant of enum <code>ty</code>…\nThe results of the type checker, from rustc. The span in …\nReturn the <code>AllocId</code> for the given thread-local static in …\nConvert this to an <code>OpTy</code>. This might be an irreversible …\nThe span of the <code>tracing</code> crate is stored here. When the …\nThis does an offset-by-zero, which is effectively a …\nThe current context in case we’re evaluating in a …\nDetermines the result of a <code>NullaryOp::UbChecks</code> invocation.\nUnwrap types that are guaranteed a …\nFind the wrapped inner type of a transparent wrapper. Must …\n<code>src</code> is a <em>pointer to</em> a <code>source_ty</code>, and in <code>dest</code> we should …\nCalled when unwinding reached a state where execution …\nThis stores whether we are currently doing reads purely …\nCheck the validity invariant of a given value, and tell …\nVisits the given value as the pointer of a <code>Box</code>. There is …\nCalled each time we recurse down to a field of a “…\nVisits the given value as a union. No automatic recursion …\nVisits the given value, dispatching as appropriate to more …\nCalled when recursing into an enum variant. This gives the …\nVisitor for a run-time value with a given layout: Traverse …\nTraversal logic; should not be overloaded.\nWrites the discriminant of the given variant.\nPass a copy of the given operand.\nAn argument passed to a function.\nAllow for the argument to be passed in-place: destroy the …\nAllocates a sequence of bytes in the interpreter’s …\nAllocates a string in the interpreter’s memory, …\nGiven a place, returns either the underlying mplace or a …\nReturns the result of the specified operation.\nLow-level helper function to check if a ptr is in-bounds …\nCheck if the given pointer points to live memory of the …\nCheck whether the given pointer points to live memory for …\nChecks a pointer for misalignment.\nCheck that the given vtable trait is valid for a …\nRemove all provenance in the given place.\nComputes the total size of this access, <code>count * elem_size</code>, …\nThis function checks the data at <code>val</code> to be const-valid. <code>val</code>…\nCopy <code>count*size_of::&lt;T&gt;()</code> many bytes from <code>*src</code> to <code>*dst</code>.\nCopies the data from an operand to a place. <code>src</code> and <code>dest</code> …\nCopies the data from an operand to a place. The layouts of …\nCopies the data from an operand to a place. <code>allow_transmute</code>…\nCopies the data from an operand to a place. <code>allow_transmute</code>…\nCall a query that can return <code>ErrorHandled</code>. Should be used …\nReturns the span of the currently executed …\nTake an operand, representing a pointer, and dereference …\nCreate a lazy debug printer that prints the given …\nCreate a lazy debug printer for a list of allocations and …\nShared part of <code>Call</code> and <code>TailCall</code> implementation — …\nEvaluate the arguments of a function call\nReturns <code>true</code> if emulation happened. Here we implement the …\nEvaluate the operand, returning a place where you can then …\nComputes a place. You should only use this if you intend …\nEvaluate a place with the goal of reading from it. This …\nEvaluate an assignment statement.\nRuns the interpretation logic for the given <code>mir::Statement</code> …\nWalks up the callstack from the intrinsic’s callsite, …\nThis inherent method takes priority over the trait method …\nThis inherent method takes priority over the trait method …\nEnsures that a place is in memory, and returns where it is.\nTurn the given error into a human-readable string. Expects …\nUse the already known layout if given (but sanity check in …\nGives raw, immutable access to the <code>Allocation</code> address, …\nGives raw, mutable access to the <code>Allocation</code> address, …\nReturn the <code>extra</code> field of the given allocation.\nReturn the <code>extra</code> field of the given allocation.\nObtain the size and alignment of an allocation, even if …\nReturn the <code>mutability</code> field of the given allocation.\nGives raw access to the <code>Allocation</code>, without bounds or …\nGives raw mutable access to the <code>Allocation</code>, without bounds …\nHelper function to obtain a global (tcx) allocation. This …\nObtain the size and alignment of a <em>live</em> allocation.\nInternal helper function to determine the allocation and …\nBounds-checked <em>but not align-checked</em> allocation access.\nBounds-checked <em>but not align-checked</em> allocation access.\nTakes a pointer that is the first chunk of a <code>TypeId</code> and …\nGet the dynamic type of the given vtable pointer. If …\nCreates a dynamic vtable for the given type and vtable …\nCall this to turn untagged “global” pointers (obtained …\nJump to the given block.\nCall this on things you got out of the MIR (so it is as …\nCall this on things you got out of the MIR (so it is as …\nA helper function that allocates memory for the layout …\nCheck whether an allocation is live. This is faster than …\nThis inherent method takes priority over the trait method …\nThis is public because it is used by Aquascope to analyze …\nRead from a local of a given frame. Will not access …\nRead from a local of the current frame. Convenience method …\nTurn a local in the current frame into a place.\nStores the <code>Machine</code> instance.\nMark the <code>const_allocate</code>d allocation <code>ptr</code> points to as …\nPerforms <code>num_copies</code> many copies of <code>size</code> many bytes from <code>src</code>…\nThe virtual memory system.\nTest if it is valid for a MIR assignment to assign <code>src</code>…\nTurn a mplace into a (thin or wide) mutable raw pointer, …\nEvery place can be read from, so we can turn them into an …\nLow-level helper that pops a stack frame from the stack …\nPrint the allocation’s bytes, without any nested …\nApplying a general projection\nIterates over all fields of an array. Much more efficient …\nDowncasting to an enum variant.\nOffset a pointer to project to a field of a struct/union. …\nProjects multiple fields at once. See <code>Self::project_field</code> …\nCompute the offset and field layout for accessing the …\nSubslicing\nConverts a repr(simd) value into an array of the right …\nTurning a “maybe pointer” into a proper pointer (and …\nOffsets a pointer by some multiple of its type, returning …\nTurning a “maybe pointer” into a proper pointer (and …\nVery low-level helper that pushes a stack frame without …\nReads the given number of bytes from memory, and strips …\nRead an immediate from a place, asserting that that is …\nTry reading an immediate in memory; this is interesting …\nTry returning an immediate for the operand. If the layout …\nRead a pointer from a place.\nRead a scalar from a place\nTurn the wide MPlace into a string (must already be …\nRead a pointer-sized signed integer from a place.\nRead a pointer-sized unsigned integer from a place.\nRead a value of type <code>TypeId</code>, returning the type it …\nIf this grows the allocation, <code>init_growth</code> determines …\nThe recursion limit (cached from <code>tcx.recursion_limit(())</code>)\nTake a value, which represents a (thin or wide) reference, …\nThis function is used by Miri’s provenance GC to remove …\nThe <code>args</code> are assumed to already be in our interpreter “…\n<em>Return</em> to the given <code>target</code> basic block. Do <em>not</em> use for …\nRuns the closure in “validation” mode, which means the …\nRuns the closure in “validation” mode, which means the …\nTest if this value might be null. If the machine does not …\nReturns the actual dynamic size and alignment of the place …\nReturns <code>true</code> as long as there are more things to do.\nMark a storage as live, killing the previous content.\nIn the current stack frame, mark all locals as live that …\nFind leaked allocations, remove them from memory and …\nThe results of the type checker, from rustc. The span in …\nDoes a <em>typed</em> swap of <code>*left</code> and <code>*right</code>.\nThe current context in case we’re evaluating in a …\nReturns the result of the specified operation, whether it …\nTurn a place with a <code>dyn Trait</code> type into a place with the …\n<em>Unwind</em> to the given <code>target</code> basic block. Do <em>not</em> use for …\nThis function checks the data at <code>val</code> to be runtime-valid. …\nVisit all allocations reachable from the given start set, …\nWrites the aggregate to the destination.\nWrites the given stream of bytes into memory.\nWrite an immediate to a place\nWrite an immediate to a place. If you use this you are …\nWrite an immediate to memory. If you use this you are …\nWrite a pointer to a place\nRepeats <code>operand</code> into the destination. <code>dest</code> must have array …\nWrite a scalar to a place\nGenerates a value of <code>TypeId</code> for <code>ty</code> in-place.\nA <code>const</code> item\nHow a constant value should be interned.\nThe <code>mutability</code> of the static, ignoring the type which may …\nCreates a new <code>DefId</code> and feeds all the right queries to …\nIntern <code>ret</code>. This function assumes that <code>ret</code> references no …\nIntern <code>ret</code> and everything it references.\nIntern an allocation. Returns <code>Err</code> if the allocation does …\nReturns the <code>DefId</code> of the static item that is currently …\nDirectly returns an <code>Allocation</code> containing an absolute path …\nDetermines whether <code>eval_mir_constant</code> can never fail …\nExtra data stored in every allocation.\nThe functionality needed by memory to manage its …\nType for the bytes of the allocation.\nMachines can define extra (non-instance) things that …\nExtra data stored in every call frame.\nThe memory kind to use for copied global memory (held in …\nMethods of this trait signifies a point where CTFE …\nWhether this kind of memory is allowed to leak\nAdditional memory kinds a machine wishes to distinguish …\nMemory’s allocation map\nReturned by <code>InterpCx::pop_stack_frame_raw</code> when no cleanup …\nIndicates that we should <em>not</em> jump to the return/unwind …\nIndicates that no special handling should be done - we’…\nShould the machine panic on allocation failures?\nPointers are “tagged” with provenance information; …\nWhen getting the AllocId of a pointer, some extra data is …\nData returned by <code>Machine::after_stack_pop</code>, and consumed by …\nReturn a “root” pointer for the given allocation: the …\nCalled to adjust global allocations to the Provenance and …\nCalled immediately after actual memory was allocated for a …\nCalled immediately after an “immediate” local variable …\nCalled immediately after an “immediate” local variable …\nCalled immediately after a stack frame got popped, but …\nCalled immediately after a stack frame got pushed and its …\nGives the machine a chance to detect more misalignment …\nApply non-determinism to float operations that do not …\nCalled to evaluate <code>Assert</code> MIR terminators that trigger a …\nCalled before a global allocation is accessed. <code>def_id</code> is …\nHook for performing extra checks on any memory read access,\nHook for performing extra operations on a memory …\nHook for performing extra checks on a memory read access. …\nHook for performing extra checks on a memory write access. …\nCalled just before the frame is removed from the stack …\nCalled before a basic block terminator is executed.\nCalled for all binary operations where the LHS has pointer …\nExecute <code>fn_val</code>. It is the hook’s responsibility to …\nDirectly process an intrinsic without pushing a stack …\nCheck whether the given function may be executed on the …\nA lot of the flexibility above is just needed for <code>Miri</code>, …\nTests if the map contains the given key. Deliberately …\nCallers should prefer <code>AllocMap::contains_key</code> when it is …\nDetermines the result of a <code>NullaryOp::ContractChecks</code> …\nWhether memory accesses should be alignment-checked.\nWhether to enforce the validity invariant for a specific …\nWhether to enforce the validity invariant <em>recursively</em>.\nAllows enabling/disabling tracing calls from within …\nDetermines the result of <code>min</code>/<code>max</code> on floats when the …\nMarks a pointer as exposed, allowing its provenance to be …\nReturn the <code>AllocId</code> for the given <code>extern static</code>.\nReturns data based on the keys and values in the map.\nEntry point to all function calls.\nGenerate the NaN returned by a float operation, given the …\nRead-only lookup.\nCompute the value passed to the constructors of the …\nReturns the salt to be used for a deduplicated global …\nMutable lookup.\nReturns a mutable reference to entry <code>k</code>. If no such entry …\nReturns a reference to entry <code>k</code>. If no such entry exists, …\nWhether Assert(OverflowNeg) and Assert(Overflow) MIR …\nCalled when the interpreter encounters a …\nCalled immediately before a new stack frame gets pushed.\nInitialize the extra state of an allocation local to this …\nInserts a new entry into the map.\nEntry point for obtaining the MIR of anything that should …\nCalled to trigger a non-unwinding panic.\nCalled on places used for in-place function argument and …\n“Int-to-pointer cast”\nConvert a pointer with provenance into an …\nRemoves an entry from the map.\nExecutes a retagging operation on a compound value. …\nExecutes a retagging operation for a single pointer. …\nBorrow the current thread’s stack.\nMutably borrow the current thread’s stack.\nReturn the <code>AllocId</code> for the given thread-local static in …\nDetermines the result of a <code>NullaryOp::UbChecks</code> invocation.\nCalled when unwinding reached a state where execution …\nMetadata about an <code>AllocId</code>.\nThe return value of <code>get_alloc_info</code> indicates the “kind”…\nA reference to some allocation that was already …\nA reference to some allocation that was already …\nMemory allocated by <code>caller_location</code> intrinsic. Error if …\nA dead allocation.\nThe value of a function pointer.\nA function allocation (that fn ptrs point to).\nA regular live data allocation.\nAdditional memory kinds a machine wishes to distinguish …\nStack memory. Error if deallocated except during a stack …\nA TypeId allocation.\nA vtable allocation.\nThis is used by priroda\nAllocations local to this instance of the interpreter. The …\nRemove all provenance in the reference range.\nTo be able to compare pointers with null, and to check …\nMap for “extra” function pointers.\n<code>range</code> is relative to this allocation reference, not the …\nReturns whether the allocation has provenance anywhere in …\n<code>range</code> is relative to this allocation reference, not the …\n<code>offset</code> is relative to this allocation reference, not the …\n<code>range</code> is relative to this allocation reference, not the …\nThis stores whether we are currently doing reads purely …\n<code>offset</code> is relative to this allocation reference, not the …\n<code>range</code> is relative to this allocation reference, not the …\nMark the given sub-range (relative to this allocation …\nMark the entire referenced range as uninitialized\nAn <code>Immediate</code> represents a single immediate self-contained …\nAn <code>Operand</code> is the result of computing a <code>mir::Operand</code>. It …\nA single scalar value (must have <em>initialized</em> <code>Scalar</code> ABI).\nA pair of two scalar value (must have <code>ScalarPair</code> ABI where …\nA value of fully uninitialized memory. Can have arbitrary …\nAssert that this immediate is a valid value for the given …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCompute the “sub-immediate” that is located within the …\nReturns the scalar from the first component and optionally …\nReturn the immediate as a <code>ScalarInt</code>. Ensures that it has …\nTo support alloc-free locals, we are able to write …\nA MemPlace with its layout. Constructing it is only …\nInformation required for the sound usage of a <code>MemPlace</code>.\nThe unsized payload (e.g. length for slices or vtable …\n<code>Sized</code> types or unsized <code>extern type</code>\nAn evaluated place, together with its type.\nA place referring to a value allocated in the <code>Memory</code> …\nThe <code>Weiteable</code> trait describes interpreter values that can …\nA place is either an mplace or some local.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nProduces a MemPlace that works for ZST but nothing else. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAdjust the provenance of the main pointer (metadata is …\nAdjust the provenance of the main pointer (metadata is …\nMetadata for unsized places. Interpretation is up to the …\nStores whether this place was created based on a …\nThe pointer can be a pure integer, with the <code>None</code> …\nTurn a mplace into a (thin or wide) pointer, as a …\nA type representing iteration over the elements of an …\nThe offset has to be inbounds, like <code>ptr::offset</code>.\nDescribes the constraints placed on offset-projections.\nA thing that we can project into, and that has a layout.\nNo constraints, just wrap around the edge of the address …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGet the layout.\nGet the length of a slice/string/array stored here.\nGet the metadata of a wide value.\nShould be the same <code>ecx</code> on each call, and match the one …\nOffset the value by the given amount, replacing the layout …\nConvert this to an <code>OpTy</code>. This might be an irreversible …\nThis does an offset-by-zero, which is effectively a …\nThis local is not currently alive, and cannot be used at …\nA stack frame.\nWhat we store about a frame in an interpreter backtrace.\nJump to the next block in the caller, or cause UB if None …\nA normal, live local. Mostly for convenience, we re-use …\nState of a local variable including a memoized layout\nCurrent value of a local variable\nWhere and how to continue when returning/unwinding from …\nReturn type of <code>InterpCx::pop_stack_frame_raw</code>.\nThe root frame of the stack: nowhere else to jump to, so …\nRead the local’s value or error if the local is not yet …\nOverwrite the local. If the local can be overwritten in …\nThis is a hack because Miri needs a way to visit all the …\nThe MIR for the function called on this frame.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGet the current location within the Frame.\nReturn the <code>SourceInfo</code> of the current instruction.\nIf a span is entered, we exit the previous span (if any, …\nExtra data for the machine.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe def_id and args of the current function.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDon’t modify if <code>Some</code>, this is only used to prevent …\nIf this is <code>Right</code>, we are not currently executing any …\nThe list of locals for this stack frame, stored in order as\nReturns the address of the buffer where the locals are …\nBy default a <code>SpanGuard</code> does nothing.\nAdditional information about the action to be performed …\nWhere to continue when returning from this function.\n<code>return_cont</code> of the popped stack frame.\nThe location where the result of the current stack frame …\n<code>return_place</code> of the popped stack frame.\nThe span of the <code>tracing</code> crate is stored here. When the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTrue if the function is marked as <code>#[track_caller]</code> (…\nA marker trait returned by …\nChecks whether a type contains generic parameters which …\nAllows executing an alternative function when tracing is …\nValidation of a <code>const</code>. <code>allow_immutable_unsafe_cell</code> says …\nExtra things to check for during validation of CTFE …\nWe want to show a nice path to the invalid field for …\nValidation of a promoted.\nRepresents a set of <code>Size</code> values as a sorted list of ranges.\nState for tracking recursive validation of references\nValidation of a <code>static</code>\nAdd the given pointer-length pair to the “data” range …\nAdd the entire given place to the “data” range of this …\nCheck a reference or <code>Box</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\n<code>None</code> indicates this is not validating for CTFE (but for …\nThis tracks which byte ranges in this value contain data; …\nConvert a place into the offset it starts at, for the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe <code>path</code> may be pushed to, but the part that is present …\nWhether provenance should be reset outside of pointers …\nIf $e throws an error matching the pattern, throw a …\nCheck if this is a value of primitive type, and if yes …\nComputes the data range of this union type: which bytes …\nFormat a path\nHow to traverse a value and what to do when we are at the …\nThis function provides the chance to reorder the order in …\nThe visitor must have an <code>InterpCx</code> in it.\n<code>read_discriminant</code> can be hooked for better error messages.\nVisits the given value as the pointer of a <code>Box</code>. There is …\nCalled each time we recurse down to a field of a “…\nVisits the given value as a union. No automatic recursion …\nVisits the given value, dispatching as appropriate to more …\nCalled when recursing into an enum variant. This gives the …\nTraversal logic; should not be overloaded.\nClassify whether an operator is “left-homogeneous”, …\nClassify whether an operator is “right-homogeneous”, …\nDetermines if this type permits “raw” initialization …\nRoutines to check for relations between fully inferred …\nReturns <code>true</code> if this place is allowed to be less aligned …\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nReturns <code>true</code> if this place is allowed to be less aligned …\nAllocate a <code>const core::panic::Location</code> with the provided …\nDetermines if this type permits “raw” initialization …\nImplements the ‘lax’ (default) version of the …\nImplements the ‘strict’ version of the …\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nReturns whether <code>src</code> is a subtype of <code>dest</code>, i.e. <code>src &lt;: dest</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")