searchState.loadedDescShard("rustc_lexer", 0, "Low-level Rust lexer.\n<code>&amp;</code>\n<code>@</code>\n<code>!</code>\nBase of numeric literal encoding according to its prefix.\nLiteral starts with “0b”.\nA block comment, e.g. <code>/* block comment */</code>.\n<code>b&#39;a&#39;</code>, <code>b&#39;\\\\&#39;</code>, <code>b&#39;&#39;&#39;</code>, <code>b&#39;;</code>\n<code>b&quot;abc&quot;</code>, <code>b&quot;abc</code>\n<code>c&quot;abc&quot;</code>, <code>c&quot;abc</code>\n<code>^</code>\n<code>&#39;a&#39;</code>, <code>&#39;\\\\&#39;</code>, <code>&#39;&#39;&#39;</code>, <code>&#39;;</code>\n<code>}</code>\n<code>]</code>\n<code>)</code>\n<code>:</code>\n<code>,</code>\nPeekable iterator over a char sequence.\nLiteral doesn’t contain a prefix.\n<code>$</code>\n<code>.</code>\nEnd of input.\n<code>=</code>\n<code>12.34f32</code>, <code>1e3</code>, but not <code>1f32</code>.\n<code>&gt;</code>\n<code>#&quot;abc&quot;#</code>, <code>##&quot;a&quot;</code> (fewer closing), or even <code>#&quot;a</code> (unterminated).\nGuarded string literal prefix: <code>#&quot;</code> or <code>##</code>.\nLiteral starts with “0x”.\nAn identifier or keyword, e.g. <code>ident</code> or <code>continue</code>.\n<code>12_u8</code>, <code>0o100</code>, <code>0b120i99</code>, <code>1f32</code>.\nAn identifier that is invalid because it contains emoji.\nNon <code>#</code> characters exist between <code>r</code> and <code>&quot;</code>, e.g. <code>r##~&quot;abcde&quot;##</code>\nA lifetime, e.g. <code>&#39;a</code>.\nA line comment, e.g. <code>// comment</code>.\nLiterals, e.g. <code>12u8</code>, <code>1.0e-40</code>, <code>b&quot;123&quot;</code>. Note that <code>_</code> is an …\nEnum representing the literal types supported by the lexer.\n<code>&lt;</code>\n<code>-</code>\nThe string was not terminated, e.g. <code>r###&quot;abcde&quot;##</code>. …\nLiteral starts with “0o”.\n<code>{</code>\n<code>[</code>\n<code>(</code>\n<code>|</code>\n<code>%</code>\n<code>+</code>\n<code>#</code>\n<code>?</code>\n<code>br&quot;abc&quot;</code>, <code>br#&quot;abc&quot;#</code>, <code>br####&quot;ab&quot;###&quot;c&quot;####</code>, <code>br#&quot;a</code>. <code>None</code> …\n<code>cr&quot;abc&quot;</code>, “cr#“abc”#“, <code>cr#&quot;a</code>. <code>None</code> indicates an …\nA raw identifier, e.g. “r#ident”.\nA raw lifetime, e.g. <code>&#39;r#foo</code>. In edition &lt; 2021 it will be …\n<code>r&quot;abc&quot;</code>, <code>r#&quot;abc&quot;#</code>, <code>r####&quot;ab&quot;###&quot;c&quot;####</code>, <code>r#&quot;a</code>. <code>None</code> indicates\n<code>;</code>\n<code>/</code>\n<code>*</code>\n<code>&quot;abc&quot;</code>, <code>&quot;abc</code>\n<code>~</code>\nParsed token. It doesn’t contain information about data …\nEnum representing common lexeme types.\nMore than 255 <code>#</code>s exist.\nThe version of Unicode that this version of unicode-xid is …\nUnknown token, not expected by the lexer, e.g. “№”\nAn unknown literal prefix, like <code>foo#</code>, <code>foo&#39;</code>, <code>foo&quot;</code>. Excludes …\nAn unknown prefix in a lifetime, like <code>&#39;foo#</code>.\nAny whitespace character sequence.\nParses a token from the input string.\nIterator over chars. Slightly faster than a &amp;str.\nEats double-quoted string and returns true if string is …\nEats the float exponent. Returns true if at least one …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven that one <code>-</code> was eaten, eat the rest of the …\nAttempt to lex for a guarded string literal.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrue if <code>c</code> is valid as a non-first character of an …\nTrue if <code>c</code> is valid as a first character of an identifier. …\nThe passed string is lexically an identifier.\nTrue if <code>c</code> is considered a whitespace according to Rust …\nEats the double-quoted string and returns <code>n_hashes</code> and an …\n<code>rustc</code> allows files to have a shebang, e.g. “…\nCreates an iterator that produces tokens from the input …\nValidates a raw string literal. Used for getting more …\nPeekable iterator over a char sequence.\nMoves to the next character.\nMoves to a substring by a number of bytes.\nIterator over chars. Slightly faster than a &amp;str.\nEats symbols while predicate returns true or until the end …\nPeeks the next symbol from the input stream without …\nChecks if there is nothing more to consume.\nReturns amount of already consumed symbols.\nReturns the last eaten symbol (or <code>&#39;\\0&#39;</code> in release builds). …\nResets the number of bytes consumed to 0.\nPeeks the second symbol from the input stream without …\nPeeks the third symbol from the input stream without …")