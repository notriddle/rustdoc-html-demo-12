searchState.loadedDescShard("rustc_infer", 0, "This crates defines the type inference engine.\nRaw content of Fluent resource for this crate, generated …\nTrait Resolution. See the rustc-dev-guide for more …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nwhen projecting an associated type\nRegions created as part of an autoref of a method receiver.\nRegions created by <code>&amp;</code> operator.\nRegion variables created when instantiating a binder with …\nTimes when we replace bound regions with existentials:\nChecking that the bounds of a trait’s associated type …\nRegions created as part of an automatic coercion.\nComparing the signature and requirements of an impl method …\n<code>ConcreteFailure(o, a, b)</code>:\nEquivalent to <code>ty::ConstKind::Infer(ty::InferConst::Var(_))</code>.\nContains the error value\nContains the error value\nwhen a fn is called\nDuring NLL region processing, we create variables for free …\n<code>GenericBoundFailure(p, s, a)</code>:\nwhen two higher-ranked types are compared\nUsed to configure inference contexts before their creation.\nThis type contains all the things within <code>InferCtxt</code> that …\n<code>InferOk&lt;&#39;tcx, ()&gt;</code> is used a lot. It may seem like a …\nReplace <code>{integer}</code> with <code>i32</code> and <code>{float}</code> with <code>f64</code>. Used only …\nRegion variables created for ill-categorized reasons.\nThis origin is used for the inference variables that we …\nContains the success value\nContains the success value\nThe number of entries in the opaque type storage at a …\nRegions created by a <code>&amp;P</code> or <code>[...]</code> pattern.\n“Universal” instantiation of a higher-ranked region …\nCreating a pointer <code>b</code> to contents of another reference.\n(&amp;’a &amp;’b T) where a &gt;= b\nRegion variables created as the values for early-bound …\nReasons to create a region inference variable.\nWhen casting <code>&amp;&#39;a T</code> to an <code>&amp;&#39;b Trait</code> object, relating <code>&#39;a</code> to …\nSome type parameter was instantiated with the given type, …\nThe given region parameter was instantiated with a region …\nWhether aliases should be related structurally or not. Used\n…\nThe origin of a <code>r1 &lt;= r2</code> constraint.\nArose from a subtyping relation\nEquivalent to <code>ty::Infer(ty::TyVar(_))</code>.\nEquivalent to <code>ty::Infer(ty::FloatVar(_))</code>.\nEquivalent to <code>ty::Infer(ty::IntVar(_))</code>.\nHelper for InferCtxt::ty_or_const_infer_var_changed (see …\nDerives <code>TypeFoldable</code> for the annotated <code>struct</code> or <code>enum</code> (…\nSee the <code>region_obligations</code> field for more information.\nThe trace designates the path through inference that we …\nDerives <code>TypeVisitable</code> for the annotated <code>struct</code> or <code>enum</code> (…\nIndicates a <code>&#39;b: &#39;a</code> constraint where <code>&#39;a</code> is in a universe …\nSee the <code>error_reporting</code> module for more details.\nA nice interface for working with the infcx. The basic …\nAttach a callback to be invoked on each root obligation …\nGiven a canonical value <code>C</code> as a starting point, create an …\n<strong>Canonicalization</strong> is the key to constructing a query in the …\nCanonicalizes a query value <code>V</code>. When we canonicalize a …\nCanonicalizes a query <em>response</em> <code>V</code>. When we canonicalize a …\nObtains the latest type of the given closure; this may be a\nProcesses a <code>Coerce</code> predicate from the fulfillment context. …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nExecute <code>f</code> and commit the bindings if closure <code>f</code> returns …\nWhether this inference context should care about region …\nMap from const parameter variable to the kind of const it …\nReturns the origin of the const variable identified by <code>vid</code>\nCreates and return a fresh universe that extends all …\nReplaces all bound variables (lifetimes, types, and …\nReplaces all bound variables (lifetimes, types, and …\nCaches the results of trait evaluation. This cache is used …\nGiven a <code>hir::Block</code>, get the span of its last expression or …\nGiven a <code>hir::HirId</code> for a block (or an expr of a block), …\nMap from floating variable to the kind of float it …\nForks the inference context, creating a new inference …\nForks the inference context, creating a new inference …\nThis module handles the relationships between “free …\nGiven a set of generics defined on a type or impl, returns …\nFreshening is the process of replacing unknown variables …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThis rather funky routine is used while processing expected\nAttempts to resolve all type/region/const variables in …\nAttempts to generalize <code>source_term</code> for the type variable …\nClone the list of variable regions. This is used only …\n<code>-Znext-solver</code>: Successfully proven goals during HIR typeck …\n<code>-Znext-solver</code>: Whether this inference context is used by …\nInsert a hidden type into the opaque type storage, …\nCreates an instantiation S for the canonical value with …\nGiven the “info” about a canonical variable, creates a …\nGiven the “infos” about the canonical variables from …\nInstantiates the const variable <code>target_vid</code> with the given …\nAn alternative to …\nGiven the (canonicalized) result to a canonical query, …\nThe idea is that we should ensure that the type variable …\nMap from integral variable to the kind of integer it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nExtracts <code>value</code>, registering any obligations into <code>fulfill_cx</code>…\nThe returned function is used in a fast path. If it …\nSee RegionConstraintCollector::leak_check. We only check …\nOnce region inference is done, the values for each …\nLexical region resolution.\nThis method is meant to be invoked as the final step of a …\nHelper for <code>make_canonicalized_query_response</code> that does …\nA version of <code>make_canonicalized_query_response</code> that does …\nTries to extract an inference variable from a constant, …\nTries to extract an inference variable from a type or a …\nTries to extract an inference variable from a type or a …\nTries to extract an inference variable from a type, …\nJust a convenient wrapper of <code>next_region_var</code> for using …\nJust a convenient wrapper of <code>next_region_var</code> for using …\nCreates a fresh region variable with the next available …\nCreates a fresh region variable with the next available …\nWhether we should use the new trait solver in the local …\nNumber of region variables created so far.\nNumber of type variables created so far.\nCaches for opaque type inference.\nResolves a float var to a rigid int type, if it was …\nResolves an int var to a rigid int type, if it was …\nVarious code related to computing outlives relations.\nExecute <code>f</code> then unroll any bindings it creates.\nIf <code>TyVar(vid)</code> resolves to a type, return that type. Else, …\nProcess the region obligations that must be proven (during …\nCache for projections.\nInstead of normalizing an associated type projection, this …\nSimilar to <code>Self::canonicalize_query</code>, except that it returns\nGiven the original values and the (canonicalized) result …\nGiven the original values and the (canonicalized) result …\nThe outlives bounds that we assume must hold about …\nTracks the set of region variables and the constraints …\nSee <code>README.md</code>.\nScan the constraints produced since <code>snapshot</code> and check …\nA set of constraints that regionck must validate.\nRegister <code>AliasRelate</code> obligation(s) that both types must be …\nRegister obligations that must hold in order for this …\nInsert a hidden type into the opaque type storage, making …\nRegister predicates that must hold in order for this …\nRegisters that the given region obligation must be resolved\nThis module contains the definitions of most <code>TypeRelation</code>s …\nThis is a backwards compatibility hack to prevent breaking …\nThe set of predicates on which errors have been reported, …\nProcess the region constraints and return any errors that …\nWhere possible, replaces type/const variables in <code>value</code> …\nCaches the results of trait selection. This cache is used …\nSet the “tainted by errors” flag to true. We call this …\nIf set, this flag causes us to skip the ‘leak check’ …\nWhether aliases should be related structurally. This is …\nReturns <code>true</code> if errors have been reported since this infcx …\nWhen an error occurs, we want to avoid reporting “derived…\nObtains (and clears) the current set of region …\nTrait queries just want to pass back type obligations “…\n<code>ty_or_const_infer_var_changed</code> is equivalent to one of …\nReturns the origin of the type variable identified by <code>vid</code>.\nWe instantiate <code>UnificationTable</code> with <code>bounds&lt;Ty&gt;</code> because …\nExtract <code>ty::TypingMode</code> of this inference context to get a …\nThe mode of this inference context, see the struct …\nGiven two sets of values for the same set of canonical …\nGiven a “guess” at the values for the canonical …\nWhat is the innermost universe we have created? Starts out …\nReturn the universe that the region <code>r</code> was created in. For …\nSee the …\nGives temporary access to the region constraint data.\nWhether we should define opaque types or just treat them …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nMakes <code>expected == actual</code>.\nMakes <code>expected == actual</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the least-upper-bound, or mutual supertype, of two\nMakes <code>expected &lt;: actual</code>.\nMakes <code>actual &lt;: expected</code>. For example, if type-checking a …\nThe query is not known to be true, but also not known to be\nFIXME(-Znext-solver): This or public because it is shared …\nRust actually has more than one category of type variables;\nIndicates whether or not we were able to prove the query …\nSome kind of const inference variable.\nFloating-point type variable <code>?F</code> (that can only be unified …\nGeneral type variable <code>?T</code> that can be unified with …\nIntegral type variable <code>?I</code> (that can only be unified with …\nWhen we canonicalize a value to form a query, we wind up …\nA “placeholder” that represents “any const”.\nA “placeholder” that represents “any region”. …\nA “placeholder” that represents “any type”.\nThe query is known to be true, presuming that you apply the\nAfter we execute a query with a canonicalized key, we get …\nRegion variable <code>&#39;?R</code>.\nSome kind of type inference variable.\nThis module contains the “canonicalizer” itself.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets the cached canonical form of <code>key</code> or executes …\nThis module contains code to instantiate new values into a …\nInstantiate the wrapped value, replacing each canonical …\nInstantiate the wrapped value, replacing each canonical …\nAllows one to apply a instantiation to some subset of …\nAllows one to apply a instantiation to some subset of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresents an empty (trivially true) set of region …\nThis module contains the code to instantiate a “query …\nMap from the universes that appear in the query to the …\nThis is equivalent to <code>CanonicalVarValues</code>, but using a …\nControls how we canonicalize “free regions” that are …\nCreates a canonical variable replacing <code>kind</code> from the input,\nCreates a canonical variable (with the given <code>info</code>) …\nShorthand helper that creates a canonical region variable …\nThe main <code>canonicalize</code> method, shared impl of …\nGiven a type variable <code>const_var</code> of the given kind, first …\nGiven a type variable <code>ty_var</code> of the given kind, first check\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSet to <code>None</code> to disable the resolution of inference …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReplaces the universe indexes used in <code>var_values</code> with …\nFIXME(-Znext-solver): This or public because it is shared …\nReplaces the bound vars in a canonical binder with var …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAs with <code>BoundVarReplacer</code>, represents the index of a binder …\nReturns the argument unchanged.\nInstantiate the wrapped value, replacing each canonical …\nAllows one to apply a instantiation to some subset of …\nInstantiate the values from <code>var_values</code> into <code>value</code>. …\nCalls <code>U::from(self)</code>.\nAlgebraic data types (ADT). For example: structures, …\nA projection, opaque type, free type alias, or inherent …\nSeparate from <code>ClauseKind::Projection</code> which is used for …\nRepresents the unprojected term of a projection goal.\nRepresents the projection of an associated, opaque, or …\nA marker predicate that is always ambiguous. Used for …\nAnalysis includes type inference, checking that items are …\nAn array with the given length. Written as <code>[T; N]</code>.\nE.g., <code>Send</code>.\n<code>Binder</code> is a binder for higher-ranked lifetimes or types. …\nThe primitive boolean type. Written as <code>bool</code>.\nThe behavior during MIR borrowck is identical to …\nBound const variable, used only when preparing a trait …\nBound type variable, used to represent the <code>&#39;a</code> in …\nA “canonicalized” type <code>V</code> is one where all free …\nRust actually has more than one category of type variables;\nInformation about a canonical variable that is included …\nA set of values corresponding to the canonical variables …\nThe primitive character type; holds a Unicode scalar value …\nProve a clause\nA clause is something that can appear in where bounds or …\nThe anonymous type of a closure. Used to represent the …\nA closure can be modeled as a struct that looks like:\nStruct returned by <code>split()</code>.\nRepresents the various closure traits in the language. This\n<code>T1</code> coerced to <code>T2</code>\nEncodes that we have to coerce <em>from</em> the <code>a</code> type to the <code>b</code> …\nWhen checking whether impls overlap, we check whether any …\nImagine you have a function <code>F: FnOnce(&amp;[T]) -&gt; R</code>, plus an …\nSome kind of const inference variable.\n<code>Type: const Trait</code>\nEnsures that a const generic argument to a parameter …\nConstants must be equal. The first component is the const …\nConstant initializer must evaluate successfully.\nRepresents a constant in Rust.\nA <strong><code>const</code></strong> <strong>v</strong>ariable <strong>ID</strong>.\nThe anonymous type of a coroutine. Used to represent the …\nSimilar to <code>ClosureArgs</code>; see the above documentation for …\nThe anonymous type of a closure. Used to represent the …\nSee docs for explanation of how each argument is used.\nA type representing the types stored inside a coroutine. …\nA De Bruijn index is a standard means of representing …\nAn unsized <code>dyn Trait</code> object\nTrait must be dyn-compatible.\nSpecifies how a trait object is represented.\nA trait object. Written as …\nSimilar to <code>Binder</code> except that it tracks early bound …\nA placeholder for a const which could not be computed; …\nA placeholder for a type which could not be computed; this …\nA <code>ProjectionPredicate</code> for an <code>ExistentialTraitRef</code>.\nAn existential reference to a trait, where <code>Self</code> is erased. …\nUnevaluated non-const-item, used by …\nThis trait is implemented for every folding traversal. …\nFloating-point type variable <code>?F</code> (that can only be unified …\nA primitive floating-point type. For example, <code>f64</code>.\nA floating-point type variable (<code>{float}</code>).\nA <strong>float</strong>ing-point (<code>f32</code> or <code>f64</code>) type <strong>v</strong>ariable <strong>ID</strong>.\nThe anonymous type of a function declaration/definition. …\nA pointer to a function. Written as <code>fn() -&gt; i32</code>.\nAn unsized FFI type that is opaque to Rust. Written as …\nA type alias that actually checks its trait bounds. …\nA top level const item not part of a trait or impl.\nA free type alias that actually checks its trait bounds. …\nA fresh const variable. See <code>infer::freshen</code> for more …\nLike <code>FreshTy</code>, but as a replacement for <code>FloatVar</code>.\nLike <code>FreshTy</code>, but as a replacement for <code>IntVar</code>.\nA <code>FreshTy</code> is one that is generated as a replacement for an …\nGeneral type variable <code>?T</code> that can be unified with …\nDoes this have <code>Alias</code> or <code>ConstKind::Unevaluated</code>?\nDoes this have any binders with bound vars (e.g. that need …\nDoes this have any bound variables? Used to check if a …\nDoes this have any <code>ConstKind::Bound</code> consts?\nDoes this value have <code>InferConst::Fresh</code>?\nDoes this have <code>ConstKind::Infer</code>?\nDoes this have <code>ConstKind::Param</code>?\nDoes this have <code>ConstKind::Placeholder</code>?\nDoes this have <code>ConstKind::Unevaluated</code>?\nIs an error type/lifetime/const reachable?\n<code>true</code> if there are “names” of types and regions and so …\n<code>true</code> if there are “names” of regions and so forth that …\nDoes this have any region that “appears free” in the …\nDoes this have inference variables? Used to determine …\nDoes this have placeholders?\nDoes this have any <code>ReBound</code> regions?\nDoes this have any <code>ReErased</code> regions?\nDoes this have <code>ReVar</code>?\nDoes this have <code>ReEarlyParam</code>?\nDoes this have <code>RePlaceholder</code>?\nDoes this have any <code>Bound</code> types?\nDoes this type have any coroutines in it?\nDoes this have <code>Free</code> aliases?\nDoes this value have …\nDoes this have <code>Infer</code>?\nDoes this have <code>Inherent</code>?\nDoes this have <code>Opaque</code>?\nDoes this have <code>Param</code>?\nDoes this have <code>Placeholder</code>?\nDoes this have <code>Projection</code>?\nEnforces the constness of the predicate we’re calling. …\nInfer the value of the const.\nA type variable used during type checking.\nAn inference variable for a const, for use in const …\nA placeholder for a type that hasn’t been inferred yet.\nAn associated type in an inherent <code>impl</code>\nAn associated const in an inherent <code>impl</code>\nAn associated type in an inherent <code>impl</code>\nIntegral type variable <code>?I</code> (that can only be unified with …\nA primitive signed integer type. For example, <code>i32</code>.\nAn integral type variable (<code>{integer}</code>).\nAn <strong>int</strong>egral (<code>u32</code>, <code>i32</code>, <code>usize</code>, etc.) type <strong>v</strong>ariable <strong>ID</strong>.\nThis is the initial value used when doing upvar inference.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\n<code>Type: [const] Trait</code>\nThe movability of a coroutine / closure literal: whether a …\nMust not contain self-references, <code>Unpin</code>.\n<code>impl !Trait for Type</code>\n<code>Type: !Trait</code>\nThe never type <code>!</code>.\nUsed by the new solver to normalize an alias. This always …\nThis should only be used inside of the new solver for …\nAn opaque type (usually from <code>impl Trait</code> in type aliases or …\nAn opaque type (usually from <code>impl Trait</code> in type aliases or …\n<code>A: &#39;region</code>\nA const generic parameter.\nA type parameter; for example, <code>T</code> in <code>fn f&lt;T&gt;(x: T) {}</code>.\nA pattern newtype. Takes any type and restricts its valid …\nA placeholder const - universally quantified higher-ranked …\nA placeholder type, used during higher ranked subtyping to …\nA “placeholder” that represents “any const”.\nA “placeholder” that represents “any region”. …\nA “placeholder” that represents “any type”.\n<code>impl Trait for Type</code>\n<code>Type: Trait</code>\nAfter analysis, mostly during codegen and MIR …\nAny analysis after borrowck for a given body should be …\nPolarity for a trait predicate. May either be negative or …\nE.g., <code>Iterator::Item = T</code>.\n<code>where &lt;T as TraitRef&gt;::Name == X</code>, approximately. See the …\nA projection <code>&lt;Type as Trait&gt;::AssocType</code>. Can get …\nAn unevaluated const coming from an associated const.\nThis kind of predicate has no <em>direct</em> correspondent in the …\nA projection <code>&lt;Type as Trait&gt;::AssocType</code>. Can get …\nA raw pointer. Written as <code>*mut T</code> or <code>*const T</code>\nA higher-ranked region. These represent either late-bound …\nA region parameter; for example <code>&#39;a</code> in …\nErased region, used by trait selection, in MIR and during …\nA region that resulted from some other error. Used …\nLate-bound function parameters are represented using a …\nA placeholder region – the higher-ranked version of …\nStatic data that has an “infinite” lifetime. Top in …\nA region variable. Should not exist outside of type …\nA reference; a pointer with an associated lifetime. …\nRegion variable <code>&#39;?R</code>.\nFolds over the substructure of a type, visiting its …\nRepresentation of regions. Note that the NLL checker uses …\n<code>where &#39;a: &#39;r</code>\nA <strong>region</strong> <strong>v</strong>ariable <strong>ID</strong>.\n<code>#[rustc_reservation_impl] impl Trait for Type</code>\nDoes this value have parameters/placeholders/inference …\nThe pointee of an array slice. Written as <code>[T]</code>.\nMay contain self-references, <code>!Unpin</code>.\nThe pointee of a string slice. Written as <code>str</code>.\n<code>T1 &lt;: T2</code>\nEncodes that <code>a</code> must be a subtype of <code>b</code>. The <code>a_is_expected</code> …\nE.g., <code>Iterator</code>.\nCorresponds to <code>where Foo: Bar&lt;A, B, C&gt;</code>. <code>Foo</code> here would be …\nA <code>DefId</code> of a trait.\nA complete reference to a trait. These take numerous …\nUsed for types that are <code>Copy</code> and which <strong>do not care arena </strong>…\nA tuple type. For example, <code>(i32, bool)</code>.\nSome kind of type inference variable.\nDefines the kinds of types used by the type system.\nA type variable.\nA <strong>ty</strong>pe <strong>v</strong>ariable <strong>ID</strong>.\nFlags that we track on types. These flags are propagated …\nThis trait is implemented for every type that can be …\nThis trait is implemented for every infallible folding …\n<code>where T: &#39;r</code>\nThis trait is implemented for every type that can be …\nThis trait is implemented for every visiting traversal. …\nThe current typing mode of an inference context. We …\nA primitive unsigned integer type. For example, <code>u32</code>.\nAn unnormalized const item such as an anon const or assoc …\nAn unevaluated (potentially generic) constant used in the …\nAn unevaluated anonymous constants.\n“Universes” are used during type- and trait-checking …\nAn unsafe binder type.\nSupport marking impl as unstable.\nAn <code>Into</code>-like trait that takes <code>TyCtxt</code> to perform …\nA <code>From</code>-like trait that takes <code>TyCtxt</code> to perform …\nUsed to hold computed value.\nInfer the value of the const.\nSimilar to the <code>Try</code> trait, but also implemented for <code>()</code>.\nNo syntax: <code>T</code> well-formed.\nA helper type that you can wrap round your own type in …\nZero value of the index.\nZero value of the index.\nZero value of the index.\nZero value of the index.\nZero value of the index.\nZero value of the index.\nZero value of the index.\nZero value of the index.\nAlways <code>RustCall</code>\nGet a flags value with all known bits set.\nWhile typechecking a body, we need to be able to define …\nThe parameters of the associated or opaque item.\nLifetime and type parameters from the enclosing function, …\nThe parameters of the associated or opaque type.\nGet the article (“a” or “an”) to use with this …\nThe polarity marker in front of the impl trait ref if …\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nAlways false\nReturns <code>true</code> if <code>self</code> can name a name from <code>other</code> – in …\nReturns <code>true</code> if <code>self</code> cannot name some names from <code>other</code> – …\nRepresents the maximum calling capability of the closure.\nRepresents the maximum calling capability of the closure.\nCaptures the closure’s signature. This closure signature …\nProduce a result of type <code>Self::Output</code> from <code>iter</code>. The …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\na function pointer that has the shape …\nAssert that the args from an <code>ExistentialTraitRef</code> or …\nThe <code>DefId</code> of the <code>TraitItem</code> or <code>ImplItem</code> for the associated …\nThe <code>DefId</code> of the <code>TraitItem</code> or <code>ImplItem</code> for the associated …\nThe intersection of a source flags value with the …\nThe type of the state discriminant used in the coroutine …\nThe discriminant for the given variant. Panics if the …\nThe set of all discriminants for the coroutine, enumerated …\nWraps <code>value</code> in a binder, asserting that <code>value</code> does not …\nCreates dummy var values which should not be used in a …\nGet a flags value with all bits unset.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns <code>true</code> if a type that impls this closure kind must …\nThis field provides fast access to information that is …\nFlips polarity by turning <code>Positive</code> into <code>Negative</code> and …\nThe entry point for folding. To fold a value <code>t</code> with a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nTrue if there are any late-bound regions\nTrue if there are any bound variables\nTrue if there are any un-erased free regions.\nReturn <code>true</code> if this type has regions that are not a part …\n“Free” regions in this context means that it has any …\nTrue if there are any late-bound non-region variables\nReturns <code>true</code> if this type has any regions that escape …\nReturns <code>true</code> if <code>self</code> has any late-bound regions that are …\nReturns a <code>TraitRef</code> of the form <code>P0: Foo&lt;P1..Pn&gt;</code> where <code>Pi</code> …\nThis is equivalent to computing the super-predicates of …\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nSet of traits which are used to emulate the inherent impls …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nMakes the identity replacement <code>T0 =&gt; T0, ..., TN =&gt; TN</code>. …\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nIndicates whether this value references only ‘global’ …\nReturns <code>true</code> if this represents the generic parameters of …\nReturns <code>true</code> when the outermost type cannot be further …\nReturn <code>true</code> if self is mutable\nReturn <code>true</code> if self is <strong>not</strong> mutable\nWhether this alias type is an opaque.\nReturns <code>true</code> if <code>self</code> is the root universe, otherwise false.\nThe <code>DefId</code> of the <code>TraitItem</code> for the associated type.\nYield a set of contained flags values.\nSimilar to <code>instantiate_identity</code>, but on an iterator of …\nSimilar to <code>instantiate_identity</code>, but on an iterator of …\nYield a set of contained named flags values.\nReturns the closure kind for this closure; only usable …\nReturns the closure kind for this closure; may return a …\nThe coroutines returned by a coroutine-closure’s …\nReturns <code>&quot;&quot;</code> (empty string) or <code>&quot;mutably &quot;</code> depending on the …\nConstruct <code>ClosureArgs</code> from <code>ClosureArgsParts</code>, containing …\nConstruct <code>CoroutineArgs</code> from <code>CoroutineArgsParts</code>, …\nWhether the new trait solver is enabled. This only exists …\nReturns the “next” universe index in order – this …\nUnwraps and returns the value within, but only if it …\nReturns the inner value, but only if it contains no bound …\nAnalysis outside of a body does not define any opaque …\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nsee <code>Ty::outer_exclusive_binder</code> for details\nThis field provides fast access to information that is …\nThe outlives relation <code>T: &#39;a</code> or <code>&#39;a: &#39;b</code>. This code frequently\nExtract the own args from this projection. For example, if …\nReturns the generic parameters of the closure’s parent.\nReturns the generic parameters of the coroutine’s parent.\nThis is the args of the typeck root.\nThis is the args of the typeck root.\nThis is the args of the typeck root.\nIf polarity is Positive: we are proving that the trait is …\nReturns <code>&quot;&quot;</code> (empty string) or <code>&quot;mut &quot;</code> depending on the …\nThis is the types of the fields of a coroutine which are …\nReturns <code>&quot;const&quot;</code> or <code>&quot;mut&quot;</code> depending on the mutability.\nTransform the generic parameters to have the given <code>impl</code> …\nWraps a <code>value</code> in a binder, using the same bound variables …\nReturns <code>&quot;&amp;&quot;</code> or <code>&quot;&amp;mut &quot;</code> depending on the mutability.\nThe intersection of a source flags value with the …\nReturns the type representing the resume type of the …\nReturns the type representing the return type of the …\nAlways <code>Normal</code> (safe)\nThe search graph is responsible for caching and cycle …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nUpdate this index in place by shifting it “in” through …\nUpdate in place by shifting out from <code>amount</code> binders.\nReturns the resulting index when this value is moved into …\nReturns the resulting index when this value is moved out …\nAdjusts any De Bruijn indices so as to make <code>to_binder</code> the …\nExtracts the signature from the closure.\nReturns the “coroutine signature”, which consists of …\nReturns the <code>fn</code> pointer type representing the closure …\nRepresents all of the relevant parts of the coroutine …\nReturns the value contained inside of this <code>for&lt;&#39;a&gt;</code>. …\nSkips the binder and returns the “bound” value. …\nCompares via an ordering that will not change if modules …\nThis returns the types of the MIR locals which had to be …\nIndicates whether this value still has …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nA convenient alternative to <code>try_super_fold_with</code> for use …\nProvides a default visit for a recursive type of interest. …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nConstruct a coroutine from the closure signature. Since a …\nGiven known upvars and a <code>ClosureKind</code>, compute the coroutine\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nReturns the <code>DefId</code> of the trait of the associated item …\nReturns <code>true</code> if this is an <code>unsafe trait</code>.\nExtracts the underlying existential trait reference from …\nExtracts the underlying trait reference from this …\nExtracts the underlying trait reference from this …\nExtracts the underlying trait reference and own args from …\nExtracts the underlying trait reference and own args from …\nThe entry point for folding. To fold a value <code>t</code> with a …\nProvides a default fold for a recursive type of interest. …\nCompute the tupled upvars that a coroutine-closure’s …\nReturns the tuple type representing the upvars for this …\nReturns the tuple type representing the upvars for this …\nThe upvars captured by the closure. Remains an inference …\nThe upvars captured by the closure. Remains an inference …\nThe upvars captured by the closure. Remains an inference …\nAllows you to map the <code>value</code> of a canonical while keeping …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nReturns an iterator over the list of types of captured …\nReturns an iterator over the list of types of captured …\nCalls <code>f</code> with a reference to the name of the enumerator for …\nThe valid variant indices of this coroutine.\nThe entry point for visiting. To visit a value <code>t</code> with a …\nAn iterator over the type substructure. WARNING: this does …\nGiven an existential predicate like <code>?Self: PartialEq&lt;u32&gt;</code> …\nObject types don’t have a self type specified. …\nObject types don’t have a self type specified. …\nReplaces the universe of this canonical variable with <code>ui</code>.\n<code>a.xform(b)</code> combines the variance of a context with the …\nReturns the type representing the yield type of the …\nA hashmap which only starts hashing after ignoring the …\nDefines the type to return when merging of two values …\nType alias for a hash map that uses the Fx hashing …\nType alias for a hash set that uses the Fx hashing …\nA struct which can never be instantiated. Used for the …\nSmall-storage-optimized implementation of a map.\nSmall-storage-optimized implementation of a set.\nThis trait is implemented by any type that can serve as a …\nTrait implemented for <strong>values</strong> associated with a unification …\nReturns the number of elements the map can hold without …\nReturns the number of elements the set can hold without …\nClears the map, removing all key-value pairs. Keeps the …\nClears the set, removing all values.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns <code>true</code> if the set contains a value.\nReturns <code>true</code> if the map contains a value for the specified …\nClears the map, returning all key-value pairs as an …\nClears the set, returning all elements in an iterator.\nGrows the stack on demand to prevent stack overflow. Call …\nGets the given key’s corresponding entry in the map for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a reference to the value corresponding to the key.\nReturns a reference to the value in the set, if any, that …\nReturns the key-value pair corresponding to the supplied …\nReturns a mutable reference to the value corresponding to …\nInserts a key-value pair into the map.\nAdds a value to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if the map contains no elements.\nReturns <code>true</code> if the set contains no elements.\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all elements in arbitrary order. The …\nAn iterator visiting all key-value pairs in arbitrary …\nAn iterator visiting all keys in arbitrary order. The …\nReturns the number of elements in the map.\nReturns the number of elements in the set.\nCreates an empty <code>SsoHashMap</code>.\nCreates an empty <code>SsoHashSet</code>.\nYou should return first the key that should be used as …\nRemoves a key from the map, returning the value at the key …\nRemoves a value from the set. Returns whether the value was\nRemoves a key from the map, returning the stored key and …\nReserves capacity for at least <code>additional</code> more elements to …\nReserves capacity for at least <code>additional</code> more elements to …\nRetains only the elements specified by the predicate.\nRetains only the elements specified by the predicate.\nShrinks the capacity of the map as much as possible. It …\nShrinks the capacity of the set as much as possible. It …\nRemoves and returns the value in the set, if any, that is …\nGiven two values, produce a new value that combines them. …\nAn iterator visiting all values in arbitrary order. The …\nAn iterator visiting all values mutably in arbitrary order.\nCreates an empty <code>SsoHashMap</code> with the specified capacity.\nCreates an empty <code>SsoHashSet</code> with the specified capacity.\nDescribes how to elaborate an obligation into a …\n“Elaboration” is the process of identifying all the …\nA filter around an iterator of predicates that makes it …\nComputes the def-ids of the transitive supertraits of …\nInstantiating a type variable with the given type would …\n<code>#[rustc_force_inline]</code> functions must be inlined and must …\nSafe <code>#[target_feature]</code> functions are not assignable to …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTreat parameters as placeholders in the given environment. …\nGiven generic arguments, could they be unified after …\nTreat parameters as infer vars. This is the correct mode …\nA trait object, all of whose components are markers (e.g., …\nSee <code>simplify_type</code>.\nGeneric parameters are pretty much just bound variables, …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTreat parameters in both the lhs and the rhs as infer vars.\nTreat parameters in the lhs as rigid, and in rhs as infer …\nTreat parameters in both the lhs and the rhs as rigid.\nTries to simplify a type by only returning the outermost …\nCommon capabilities of placeholder kinds\nChecks whether this type is an ADT that has unsafe fields.\nPerforms a instantiation suitable for going from a …\nWhether this ABI is <code>extern &quot;Rust&quot;</code>.\nWhether the number of opaques has changed in a way that …\nReturns the type of the struct tail.\nLang items used by the new trait solver. This can be …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA trait implemented for all <code>X&lt;&#39;a&gt;</code> types that can be safely …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCollect Components for <em>all</em> the args of <code>alias_ty</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPush onto <code>out</code> all the things that must outlive <code>&#39;a</code> for the …\nContains the error value\nWe switched our variance because a generic argument occurs …\nNo additional information - this is the default. We will …\nContains the success value\nWhether aliases should be related structurally or not. Used\nExtra information about why we ended up with a particular …\nGeneric relation routine suitable for most anything.\nRelate the two args for the given item. The default is to …\nSwitch variance for the purpose of relating <code>a</code> and <code>b</code>.\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nThe index of the generic parameter being used (e.g. <code>0</code> for …\nThe generic type containing the generic parameter that …\nRegister <code>AliasRelate</code> obligation(s) that both types must be …\nRegister obligations that must hold in order for this …\nRegister predicates that must hold in order for this …\nWhether aliases should be related structurally. This is …\nContains the error value\nWe switched our variance because a generic argument occurs …\nNo additional information - this is the default. We will …\nContains the success value\nEnforce that <code>a</code> is equal to or a subtype of <code>b</code>.\nWhether aliases should be related structurally or not. Used\nExtra information about why we ended up with a particular …\nGeneric relation routine suitable for most anything.\nRelate the two args for the given item. The default is to …\nSwitch variance for the purpose of relating <code>a</code> and <code>b</code>.\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nThe index of the generic parameter being used (e.g. <code>0</code> for …\nThe generic type containing the generic parameter that …\nA path with at least one coinductive step. Such cycles …\nThe search graph does not simply use <code>Interner</code> directly to …\nThe initial value when adding a goal to its own nested …\nWhether to use the provisional cache. Set to <code>false</code> by a …\nA path which is treated as ambiguous. Once a path has this …\nA path consisting of only inductive/unproductive steps. …\nIn the initial iteration of a cycle, we do not yet have a …\nTracks how nested goals have been accessed. This is …\nA path which is not be coinductive right now but we may …\nGet a flags value with all known bits set.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nGet the underlying bits value.\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nWhether all set bits in a source flags value are also set …\nThe number of goals currently in the search graph. This …\nThe intersection of a source flags value with the …\nGet a flags value with all bits unset.\nReturning <code>Some</code> disables the global cache for the current …\nProbably the most involved method of the whole solver.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from a bits value.\nConvert from a bits value exactly.\nConvert from a bits value, unsetting any unknown bits.\nThe bitwise or (<code>|</code>) of the bits in each flags value.\nGet a flags value with the bits of a flag with the given …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nThe bitwise and (<code>&amp;</code>) of the bits in two flags values.\nWhether any set bits in a source flags value are also set …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether all known bits in this flags value are set.\nWhether all bits in this flags value are unset.\nYield a set of contained flags values.\nYield a set of contained named flags values.\nThe bitwise negation (<code>!</code>) of the bits in a flags value, …\nThe intersection of a source flags value with the …\nCall <code>insert</code> when <code>value</code> is <code>true</code> or <code>remove</code> when <code>value</code> is …\nThe intersection of a source flags value with the …\nThe intersection of a source flags value with the …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise exclusive-or (<code>^</code>) of the bits in two flags …\nThe bitwise or (<code>|</code>) of the bits in two flags values.\nIndicates that a <code>impl Drop for Adt</code> is <code>const</code> or not.\nIf the self type is an alias type, e.g. an opaque type or …\nConst conditions that need to hold for <code>[const]</code> alias …\nPredicate required for an alias projection to be …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nPossible ways the given goal can be proven.\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nA goal is a statement, i.e. <code>predicate</code>, we want to prove …\nWhy a specific goal has to be proven.\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\n<code>MetaSized</code> trait\nSome built-in impl we don’t need to differentiate. This …\nPreferred eagerly.\nIn case normalizing aliases in nested goals cycles, …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment. Stores a <code>ParamEnvSource</code>…\nOpaques that are defined in the inference context before a …\nThe result of evaluating a canonical query.\n<code>Sized</code> trait\nWhich sizedness trait - <code>Sized</code>, <code>MetaSized</code>? <code>PointeeSized</code> is …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nA built-in impl that is considered trivial, without any …\nA nested goal required to prove that types are …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdditional constraints returned by this query.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nData structure used to inspect trait solver behavior.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nUpdates the goal to one with a different <code>predicate</code> but the …\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nUsed to do a probe to find out what projection type(s) …\nA trait goal was satisfied by an impl candidate.\nChecking that a rigid alias is well-formed.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nUsed in the probe that wraps normalizing the non-self type …\nWhat happened inside of this probe in chronological order.\nThis is always <code>ProbeKind::Root</code>.\nAn iterator for walking the type tree.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSkips the subtree corresponding to the last type returned …\nGiven the region obligations and constraints scraped from …\nCombines a <code>FreeRegionMap</code> and a <code>TyCtxt</code>.\nCheck whether <code>r_a &lt;= r_b</code> is found in the relation.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nFree-region relationships.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the least-upper-bound of two free regions. In some\nStores the relation <code>a &lt; b</code>, where <code>a</code> and <code>b</code> are regions.\nTests whether <code>r_a &lt;= r_b</code>.\n<code>ConcreteFailure(o, a, b)</code>:\nEmpty lifetime is for data that is never accessed. We tag …\n<code>GenericBoundFailure(p, s, a)</code>:\nContains the result of lexical region resolution. Offers …\n…\nIndicates a <code>&#39;b: &#39;a</code> constraint where <code>&#39;a</code> is in a universe …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCollects all regions that “bound” the variable …\nAfter expansion is complete, go and check upper bounds …\nGo over the variables that were declared to be error …\nInitially, the value for all variables is set to <code>&#39;empty</code>, …\nExpands the value of the region represented with <code>b_vid</code> …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the least-upper-bound of <code>a</code> and <code>b</code>; i.e., the …\nThis function performs lexical region resolution given a …\nTrue if <code>a &lt;= b</code>, but not defined over inference variables.\nTrue if <code>a &lt;= b</code>.\nThe number of entries in the opaque type storage at a …\nOnly returns the opaque types which are stored in …\nOnly returns the opaque types from the lookup table. These …\nCode that handles “type-outlives” constraints like …\nThe <code>OutlivesEnvironment</code> collects information about what …\n“Region-bound pairs” tracks outlives relations that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCreate a new <code>OutlivesEnvironment</code> from normalized outlives …\nAssumptions that come from the well-formedness of …\nCalls <code>U::from(self)</code>.\nFIXME: Your first reaction may be that this is a bit …\nVisits free regions in the type that are relevant for …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe <code>TypeOutlives</code> struct has the job of “lowering” a …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAdds constraints to inference such that <code>T: &#39;a</code> holds (or …\nBinds the pattern variable <code>br</code> to <code>value</code>; returns an <code>Err</code> if …\nTrue if a (potentially higher-ranked) outlives\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGiven a “verify-if-eq” type test like:\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreates the “Error” variant that signals “no match”…\nThe <code>TypeOutlives</code> struct has the job of “lowering” a …\nGiven a projection like <code>T::Item</code>, searches the environment …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nGiven a projection like <code>&lt;T as Foo&lt;&#39;x&gt;&gt;::Bar</code>, returns any …\nSearches the environment for where-clauses like <code>G: &#39;a</code> where\nSearches the environment to find all bounds that apply to …\nReturns the argument unchanged.\nDuring borrowck, if there are no outlives bounds on a …\nCalls <code>U::from(self)</code>.\nWe added a GLB/LUB “combination variable”.\nWe added the given <code>constraint</code>.\nWe added <code>RegionVid</code>.\nWe added the given <code>verify</code>.\nGiven a set of bounds <code>B</code>, expands to the function:\nGiven a set of bounds <code>B</code>, expands to the function:\nRepresents a constraint that influences the inference …\nRepresents a constraint that influences the inference …\nSee <code>VerifyIfEq</code> docs\nGiven a region <code>R</code>, true if it is <code>&#39;empty</code>.\nGiven a region <code>R</code>, expands to the function:\nA constraint where neither side is a variable. This does …\nA concrete region is a subregion of region variable.\nThe full set of region constraints gathered up by the …\nA region variable is a subregion of a concrete region. …\nA region variable is a subregion of another.\nDescribes the things that some <code>GenericKind</code> value <code>G</code> is …\nThis is a “conditional bound” that checks the result …\na flag set to true when we perform any unifications; this …\nBound that applies if <code>ty</code> is equal.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nConstraints of the form <code>A &lt;= B</code>, where either <code>A</code> or <code>B</code> can be …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFor a given pair of regions (R1, R2), maps to a region R3 …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this region constraint data contains no …\nSearches new universes created during <code>snapshot</code>, looking for\nFor a given pair of regions (R1, R2), maps to a region R3 …\nResolves a region var to its value in the unification …\nSee <code>InferCtxt::region_constraints_added_in_snapshot</code>.\nTakes (and clears) the current set of constraints. Note …\nType which must match the generic <code>G</code>\nWhen we add a R1 == R2 constraint, we currently add (a) …\nFor each <code>RegionVid</code>, the corresponding <code>RegionVariableOrigin</code>.\nReturns the origin for the given variable.\nA “verify” is something that we need to verify after …\nMaximum value the index can take.\nMaximum value the index can take.\nMaximum value the index can take, as a <code>u32</code>.\nMaximum value the index can take, as a <code>u32</code>.\nRepresents the graph of constraints. For each <code>R1: R2</code> …\nTracks the “minimum universe” for each SCC, along with …\nZero value of the index.\nZero value of the index.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>u32</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCompute what placeholders (if any) each SCC must be equal …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u16</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>u32</code>.\nCreates a new index from a given <code>usize</code>.\nCreates a new index from a given <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nExtracts the value of this index as a <code>usize</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInvokes <code>each_edge(R1, R2)</code> for each edge where <code>R2: R1</code>\nMap from a region to the index of the node in the graph.\nFor each SCC S, iterate over each successor S1 where <code>S: S1</code>:\nSome region that caused <code>universe</code> to be what it is.\nMap from node index to SCC, and stores the successors of …\nIf <code>universe</code> is less than our current universe, then update …\nFor some SCC S, the minimum universe of:\nContains the error value\nContains the error value\nWe switched our variance because a generic argument occurs …\nNo additional information - this is the default. We will …\nContains the success value\nContains the success value\nWhether aliases should be related structurally or not. Used\nExtra information about why we ended up with a particular …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nHelper routines for higher-ranked things. See the <code>doc</code> …\nCalls <code>U::from(self)</code>.\nLattice variables\nRegister <code>AliasRelate</code> obligation(s) that both types must be …\nRegister obligations that must hold in order for this …\nRegister predicates that must hold in order for this …\nGeneric relation routine suitable for most anything.\nRelate the two args for the given item. The default is to …\nSwitch variance for the purpose of relating <code>a</code> and <code>b</code>.\nWhether aliases should be related structurally. This is …\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nMirrors <code>Variance::xform</code> - used to ‘combine’ the …\nThe index of the generic parameter being used (e.g. <code>0</code> for …\nThe generic type containing the generic parameter that …\nRegister <code>AliasRelate</code> obligation(s) that both types must be …\nRegister obligations that must hold in order for this …\nRegister predicates that must hold in order for this …\nWhether aliases should be related structurally. This is …\nResult from a generalization operation. This includes not …\nThe “generalizer” is used when handling inference …\nAfter we generalize this type, we are going to relate it to\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCreate an error that corresponds to the term kind in …\nThe universe of the type variable that is in the process …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn occurs check failure inside of an alias does not mean …\nSee the field <code>has_unconstrained_ty_var</code> in <code>Generalization</code>.\nIn general, we do not check whether all types which occur …\nThis is set once we’re generalizing the arguments of an …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new type variable in the universe of the target …\nThe root term (const or type) we’re generalizing. Used …\nThe vid of the type variable that is in the process of …\nWhether aliases should be related structurally. If not, we …\nWhen generalizing <code>&lt;?0 as Trait&gt;::Assoc</code> or …\nA greatest lower bound“ (common subtype) or least upper …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRelates two types using a given lattice.\nContains the error value\nWe switched our variance because a generic argument occurs …\nNo additional information - this is the default. We will …\nContains the success value\nEnforce that <code>a</code> is equal to or a subtype of <code>b</code>.\nWhether aliases should be related structurally or not. Used\nExtra information about why we ended up with a particular …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGeneric relation routine suitable for most anything.\nRelate the two args for the given item. The default is to …\nSwitch variance for the purpose of relating <code>a</code> and <code>b</code>.\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nRelates <code>a</code> and <code>b</code> structurally, calling the relation for all …\nThe index of the generic parameter being used (e.g. <code>0</code> for …\nThe generic type containing the generic parameter that …\nEnforce that <code>a</code> is equal to or a subtype of <code>b</code>.\nThe cache only tracks the <code>ambient_variance</code> as it’s the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe opportunistic region resolver opportunistically …\nThe opportunistic resolver can be used at any time. It …\nWe’re able to use a cache here as the folder does not …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFull type resolution replaces all type and region …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe combined undo log for all the various unification …\nRecords the “undo” data for a single operation that …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThese structs (a newtyped TyVid) are used as the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTwo variables are unified in <code>eq_relations</code> when we have a …\nRecords that <code>a == b</code>, depending on <code>dir</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAn always-inlined variant of <code>probe</code>, for very hot call …\nInstantiates <code>vid</code> with the type <code>ty</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf this value is known, returns the type it is known to be.\nCreates a new type variable.\nReturns the number of type variables created thus far.\n<code>DefId</code> of the type parameter this was instantiated for, if …\nRetrieves the type to which <code>vid</code> has been instantiated, if …\nReturns the “root” variable of <code>vid</code> in the <code>eq_relations</code> …\nReturns indices of all variables that are not yet …\nThe origins of each type variable.\nReturns the origin that was given when <code>vid</code> was created.\nReturns a range of the type variables created during the …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIf this value is known, returns the const it is known to …\n<code>DefId</code> of the const parameter this was instantiated for, if …\nObligations to prove that a <code>Drop</code> or negative auto trait …\nAn ambiguity. This goal may hold if further inference is …\nAmbiguity can happen when monomorphizing during trans …\nAn array <code>[T; N]</code> can only be indexed (and is only …\nVarious cases where expressions must be <code>Sized</code> / <code>Copy</code> / etc.\nAssociated const.\ne.g., <code>async fn foo(&amp;self)</code>\nBlock implicit return\nSuccessful resolution for a builtin impl.\nSuccessful resolution for a builtin impl.\nDerived obligation (i.e. theoretical <code>where</code> clause) on a …\nDerived obligation (i.e. <code>where</code> clause) on an user-provided …\nChecking that the bounds of a trait’s associated type …\nThese are the error cases for <code>codegen_select_candidate</code>.\nObligation incurred due to a coercion.\nError derived when checking an impl item is compatible with\nError for a <code>ConstArgHasType</code> goal\nRequirement for a <code>const N: Ty</code> to implement <code>Ty: ConstParamTy</code>\nUse of a const ctor\nAn old-solver-style cycle error, which will fatal. This is …\nContains the error value\nEvaluation is known to be ambiguous – it <em>might</em> hold for …\nEvaluation failed because of recursion involving inference …\nEvaluation failed.\nEvaluation successful.\nEvaluation successful, but need to rerun because opaque …\nEvaluation successful, but there were unevaluated region …\nThe result of trait evaluation. The order is important …\nChecking that this expression can be assigned to its …\nTypes of fields (other than the last, except for packed …\nCall to a const fn\nDerived obligation refined to point at a specific argument …\nGAT\ne.g., <code>fn foo&lt;A&gt;()</code>\nLike <code>WhereClauseinExpr</code>, but indexes into the …\nComputing common supertype in an if expression\nComputing common supertype of an if expression with no …\nDerived obligation (i.e. <code>where</code> clause) on an user-provided …\nDerived obligation (i.e. <code>where</code> clause) on an user-provided …\nGiven the successful resolution of an obligation, the …\nIdentifies a particular impl in the source, along with a …\nInline asm operand type must be <code>Sized</code>.\nIntrinsic has wrong type\nWhether a value can be extracted into a const. Used for …\nlanguage function has wrong type\nA let else block does not diverge\n<code>main</code> has wrong type\nComputing common supertype in the arms of a match …\nFrom <code>match_impl</code>. The cause for us having to match an impl, …\nMethod has something illegal.\nMethod receiver\nReasons a method might not be dyn-compatible.\nSome built-in impl we don’t need to differentiate. This …\nNot well classified or should be obvious from the span.\nA given constant couldn’t be evaluated.\nA built-in impl for trait objects. The index is only used …\nA type like <code>Box&lt;Foo&lt;&#39;a&gt; + &#39;b&gt;</code> is WF only if <code>&#39;b: &#39;a</code>.\nAn <code>Obligation</code> represents some trait reference (e.g., …\nThe reason why we incurred this obligation; used for error …\nA compact form of <code>ObligationCauseCode</code>.\nA callback that can be provided to <code>inspect_typeck</code>. Invoked …\nContains the success value\nOpaque return type of this function\nComputing an opaque type’s hidden type caused an error …\nRepresents a bound for an opaque we are checking the …\nExceeded the recursion depth during type projection.\nIndicates that trait evaluation caused overflow and in …\nSuccessful resolution to an obligation provided by the …\nUse the type of the parameter of the provided function. We …\nSuccessful resolution to an obligation provided by the …\nType error arising from type checking a pattern against an …\nInformation about the origin expression of a pattern, …\nThe projection cache. Unlike the standard caches, this can …\nA type like <code>&amp;&#39;a T</code> is WF only if <code>T: &#39;a</code>.\ne.g., <code>fn foo(&amp;self) -&gt; impl Sized</code>\ne.g., <code>fn foo(&amp;self, x: Self)</code>\ne.g., <code>fn foo(&amp;self) -&gt; Self</code>\n<code>[expr; N]</code> requires <code>type_of(expr): Copy</code>.\n<code>return</code> with no expression\n<code>return</code> with an expression\nA trait error with most of its information removed. This …\nWhen performing resolution, it is typically the case that …\n<code>static</code> items must have <code>Sync</code> type.\nAfter a closure impl has selected, its “outputs” were …\nArgument type must be <code>Sized</code>.\nReturn type of a call expression must be <code>Sized</code>.\nCaptured closure type must be <code>Sized</code>.\nConstant expressions must be sized.\nTypes live across coroutine yields must be <code>Sized</code>.\nReturn type must be <code>Sized</code>.\n<code>Self: Sized</code> declared on the trait.\nYield type must be <code>Sized</code>.\nA slice or array is WF only if <code>T: Sized</code>.\ne.g., <code>fn foo()</code>\n<code>S { ... }</code> must be <code>Sized</code>.\nSupertrait reference references <code>Self</code> an in illegal location\nThe trait pointed by <code>DefId</code> is dyn-incompatible.\nA built-in implementation of <code>Upcast</code> for trait objects to …\nA built-in impl that is considered trivial, without any …\n#[feature(trivial_bounds)] is not enabled\nA real error. This goal definitely does not hold.\nA tuple is WF only if its middle elements are <code>Sized</code>.\n<code>(x1, .., xn)</code> must be <code>Sized</code>.\nUse the type of the provided definition.\nObligations emitted during the normalization of a free …\nThe selected impl has unconstrained generic parameters. …\nthe method’s receiver (<code>self</code> argument) can’t be …\nThe trait is not implemented.\nThis can trigger when we have a global bound that is not …\nOnly reachable if the <code>unsized_fn_params</code> feature is used. …\nImplSource identifying a particular impl.\nImplSource identifying a particular impl.\nType of each variable must be <code>Sized</code>.\nWell-formed checking. If a <code>WellFormedLoc</code> is provided, then …\nDerived obligation for WF goals.\nThe ‘location’ at which we try to perform HIR-based wf …\nRepresents a clause that comes from a specific item. The …\nLike <code>WhereClause</code>, but also identifies the expression which …\ne.g., <code>fn foo(&amp;self) where Self: Clone</code>\nThe ID of the fn body that triggered this obligation. This …\nThe reason we have to prove this thing.\nThe reason we have to prove this thing.\nThe reason we have to prove this thing.\nThe reason we have to prove this thing.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nCreates a cause for obligations that are derived from …\nAmong all pending obligations, collect those are stalled …\nSpan of the <em>whole</em> match expr.\nFlips the polarity of the inner predicate.\nFlips the polarity of the inner predicate.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe <code>DefId</code> of the <code>impl</code> that gave rise to the <code>derived</code> …\nThe index of the derived predicate in the parent impl’s …\nThe <code>DefId</code> of the <code>impl</code> that gave rise to the <code>derived</code> …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if this evaluation result is known to apply, …\nReturns <code>true</code> if this evaluation result is known to apply, …\nThe environment in which we should prove this thing.\nThe environment in which we should prove this thing.\nThe environment in which we should prove this thing.\nThe environment in which we should prove this thing.\nThe parent trait had this cause.\nThe parent trait had this cause.\nThe trait predicate of the parent obligation that led to …\nThe trait predicate of the parent obligation that led to …\nReturns the base obligation, ignoring derived obligations.\nReturns the base obligation and the base trait predicate, …\nThe number of references that were peeled to produce …\nDoes the peeled expression need to be wrapped in …\nA span representing the scrutinee expression, with all …\nThe thing we are trying to prove.\nThe thing we are trying to prove.\nThe thing we are trying to prove.\nThe thing we are trying to prove.\nSpans of the previous arms except for those that diverge …\nCode for projecting associated types out of trait …\nExperimental types for the trait query interface. The …\nIf we started proving this as a result of trying to prove …\nIf we started proving this as a result of trying to prove …\nIf we started proving this as a result of trying to prove …\nIf we started proving this as a result of trying to prove …\nRequires that <code>ty</code> must implement the trait with <code>def_id</code> in …\nSpan of the scrutinee of the match (the matched value).\nCandidate selection. See the rustc dev guide for more …\nWe often create nested obligations without setting the …\nSource of the match, i.e. <code>match</code> or a desugaring.\nIs the expectation of this match expression an RPIT?\nThe node of the relevant argument in the function call.\nThe node of the function call.\nSpan of the repeat element.\nIf element is a <code>const fn</code> or const ctor we display a help …\nInformation about the <code>Span</code>, if it came from an expression, …\nThe obligation introduced by this argument.\nThe root expected type induced by a scrutinee or type …\nThe span of the scrutinee or type expression which caused …\nIf we were able to successfully evaluate the corresponding …\nThe function to lookup the parameter in\nThe index of the parameter to use. Parameters are indexed …\nAn ambiguity. This goal may hold if further inference is …\nAn old-solver-style cycle error, which will fatal. This is …\nA trait error with most of its information removed. This …\nA real error. This goal definitely does not hold.\nAmong all pending obligations, collect those are stalled …\nRequires that <code>ty</code> must implement the trait with <code>def_id</code> in …\nThe projection cache. Unlike the standard caches, this can …\nIndicates that trying to normalize <code>key</code> resulted in …\nMark the relevant projection cache key as having its …\nIndicates that trying to normalize <code>key</code> resulted in error.\nIndicates that <code>key</code> was normalized to <code>value</code>.\nIndicates that while trying to normalize <code>key</code>, <code>key</code> was …\nTry to start normalize <code>key</code>; returns an error if …\nIf we were able to successfully evaluate the corresponding …\nA set of constraints that need to be satisfied in order for\nResult of the …\nOutlives bounds are relationships between generic …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nTypes that could not be resolved: projections and params.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>true</code> if the type results from a dereference of a raw …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResult of the normalization.\nIf Some(T), a type autoderef reported an error on.\nTypes that are required to be alive in order for this type …\nIf, during the computation of the dtorck constraint, we …\nWe will generate CandidateSteps which are reachable via a …\nIf <code>true</code>, <code>steps</code> has been truncated due to reaching the …\nThe valid autoderef steps that could be found by following …\nNormalizes, and deeply normalizes in the new solver.\nNormalizes, but not in the new solver.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementation of an <code>AsyncFn</code>-family trait by one of the …\nImplementation of the <code>AsyncFnKindHelper</code> helper trait, which\nImplementation of an <code>AsyncIterator</code> trait by one of the …\nA builtin implementation for some specific traits, used in …\nImplementation of a <code>Fn</code>-family trait by one of the …\nImplementation of a <code>Coroutine</code> trait by one of the …\nEvaluation is known to be ambiguous – it <em>might</em> hold for …\nEvaluation failed because of recursion involving inference …\nEvaluation failed.\nEvaluation successful.\nEvaluation successful, but need to rerun because opaque …\nEvaluation successful, but there were unevaluated region …\nThe result of trait evaluation. The order is important …\nImplementation of a <code>Fn</code>-family trait by one of the anonymous\nImplementation of a <code>Future</code> trait by one of the coroutine …\nImplementation of an <code>Iterator</code> trait by one of the …\nMatching <code>dyn Trait</code> with a supertrait of <code>Trait</code>. The index …\nIndicates that trait evaluation caused overflow and in …\nThis is a trait matching with a projected type as <code>Self</code>, …\nThe selection process begins by considering all impls, …\nA built-in implementation for the <code>Sized</code> trait. This is …\nPerform trait upcasting coercion of <code>dyn Trait</code> to a …\nImplementation of transmutability trait.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIndicates that a <code>impl Drop for Adt</code> is <code>const</code> or not.\nIf the self type is an alias type, e.g. an opaque type or …\nConst conditions that need to hold for <code>[const]</code> alias …\nPredicate required for an alias projection to be …\nWe failed due to ambiguity. This ambiguity can either be a …\nA builtin impl generated by the compiler. When adding a …\nA candidate that is registered only during coherence to …\nContains the error value\nAdditional constraints returned on success.\nWhy a specific goal has to be proven.\nA user written impl.\nWe’re proving a where-bound of an impl.\nInstantiating a higher-ranked goal and re-proving it.\nWhy we failed to evaluate a goal.\n<code>MetaSized</code> trait\nSome built-in impl we don’t need to differentiate. This …\nPreferred eagerly.\nIn case normalizing aliases in nested goals cycles, …\nA built-in impl for trait objects. The index is only used …\nContains the success value\nWe gave up due to an overflow, most often by hitting the …\nAn assumption from the environment. Stores a <code>ParamEnvSource</code>…\nOpaques that are defined in the inference context before a …\n<code>Sized</code> trait\nWhich sizedness trait - <code>Sized</code>, <code>MetaSized</code>? <code>PointeeSized</code> is …\nA built-in implementation of <code>Upcast</code> for trait objects to …\nA built-in impl that is considered trivial, without any …\nA nested goal required to prove that types are …\nUse this function to merge the certainty of multiple …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nAdditional constraints returned by this query.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nData structure used to inspect trait solver behavior.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>DefId</code> of corresponding language item.\nWe added a goal to the <code>EvalCtxt</code> which will get proven the …\nWhen evaluating a goal we also store the original values …\nA call to …\nA call to <code>probe</code> while proving the current goal. This is …\nProbe entered when normalizing the self ty during …\nTry to unify an opaque type with an existing key in the …\nA self-contained computation during trait solving. This …\nWhat kind of probe we’re in. In case the probe …\nUsed to do a probe to find out what projection type(s) …\nA trait goal was satisfied by an impl candidate.\nChecking that a rigid alias is well-formed.\nThe root inference context while proving a goal.\nLooking for param-env candidates that satisfy the trait …\nSome <code>data</code> together with information about how they relate …\nA candidate for proving a trait or alias-relate goal.\nUsed in the probe that wraps normalizing the non-self type …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhat happened inside of this probe in chronological order.\nThis is always <code>ProbeKind::Root</code>.\nChildren of a given impl, grouped into blanket/non-blanket …\nA per-trait graph of impls in specialization order. At the …\nInformation about the most specialized definition of an …\nA node in the specialization graph is either an impl or a …\nWhat kind of overlap check are we doing – this exists …\nThe 1.0 rules (either types fail to unify, or where …\nJust check for negative impls, not for “where clause not …\nFeature-gated test: Stable, <em>or</em> there is an explicit …\nWalk up the specialization ancestors of a given impl, …\nBlanket impls associated with the trait.\nThe “root” impls are found by looking up the trait’s …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nThe node in the specialization graph containing the …\nThe “top-most” (ie. least specialized) specialization …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns whether this definition is known to not be further …\nTries to find the associated item that implements …\nThe associated item described by this <code>LeafDef</code>.\nFinds the bottom-most (ie. most specialized) definition of …\nImpls of the trait.\nThe parent of a given impl, which is the <code>DefId</code> of the …\nAll impls have a parent; the “root” impls have as …\nDescribes how to elaborate an obligation into a …\n“Elaboration” is the process of identifying all the …\nA filter around an iterator of predicates that makes it …\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nEquivalent to <code>f(&amp;iter.collect::&lt;Vec&lt;_&gt;&gt;())</code>.\nStart elaborating <code>Sized</code> - reqd during coherence checking, …\nFilter to only the supertraits of trait predicates, i.e. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAdds a predicate to the set.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nComputes the def-ids of the transitive supertraits of …\nA specialized variant of <code>elaborate</code> that only elaborates …")