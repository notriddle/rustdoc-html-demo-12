<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Macro Expansions - Clippy Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon-de23e50b.svg">
        <link rel="shortcut icon" href="../favicon-8114d1fc.png">
        <link rel="stylesheet" href="../css/variables-3865ffda.css">
        <link rel="stylesheet" href="../css/general-4c35105a.css">
        <link rel="stylesheet" href="../css/chrome-c0e702bf.css">
        <link rel="stylesheet" href="../css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="../fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex-4094555e.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc-eeee08c3.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Clippy Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust-clippy/tree/master/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust-clippy/edit/master/book/src/development/macro_expansions.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dealing-with-macros-and-expansions"><a class="header" href="#dealing-with-macros-and-expansions">Dealing with macros and expansions</a></h1>
<p>Sometimes we might encounter Rust macro expansions while working with Clippy.
While macro expansions are not as dramatic and profound as the expansion
of our universe, they can certainly bring chaos to the orderly world
of code and logic.</p>
<p>The general rule of thumb is that we should ignore code with macro
expansions when working with Clippy because the code can be dynamic
in ways that are difficult or impossible for us to foresee.</p>
<h2 id="false-positives"><a class="header" href="#false-positives">False Positives</a></h2>
<p>What exactly do we mean by <em>dynamic in ways that are difficult to foresee</em>?</p>
<p>Macros are <a href="https://rustc-dev-guide.rust-lang.org/macro-expansion.html#expansion-and-ast-integration">expanded</a> in the <code>EarlyLintPass</code> level,
so the Abstract Syntax Tree (AST) is generated in place of macros.
This means the code which we work with in Clippy is already expanded.</p>
<p>If we wrote a new lint, there is a possibility that the lint is
triggered in macro-generated code. Since this expanded macro code
is not written by the macro's user but really by the macro's author,
the user cannot and should not be responsible for fixing the issue
that triggers the lint.</p>
<p>Besides, a <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html">Span</a> in a macro can be changed by the macro author.
Therefore, any lint check related to lines or columns should be
avoided since they might be changed at any time and become unreliable
or incorrect information.</p>
<p>Because of these unforeseeable or unstable behaviors, macro expansion
should often not be regarded as a part of the stable API.
This is also why most lints check if they are inside a macro or not
before emitting suggestions to the end user to avoid false positives.</p>
<h2 id="how-to-work-with-macros"><a class="header" href="#how-to-work-with-macros">How to Work with Macros</a></h2>
<p>Several functions are available for working with macros.</p>
<h3 id="the-spanfrom_expansion-method"><a class="header" href="#the-spanfrom_expansion-method">The <code>Span.from_expansion</code> method</a></h3>
<p>We could utilize a <code>span</code>'s <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> method, which
detects if the <code>span</code> is from a macro expansion / desugaring.
This is a very common first step in a lint:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if expr.span.from_expansion() {
    // We most likely want to ignore it.
    return;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="spanctxt-method"><a class="header" href="#spanctxt-method"><code>Span.ctxt</code> method</a></h3>
<p>The <code>span</code>'s context, given by the method <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.ctxt"><code>ctxt</code></a> and returning <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/hygiene/struct.SyntaxContext.html">SyntaxContext</a>,
represents if the span is from a macro expansion and, if it is, which
macro call expanded this span.</p>
<p>Sometimes, it is useful to check if the context of two spans are equal.
For instance, suppose we have the following line of code that would
expand into <code>1 + 0</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The following code expands to `1 + 0` for both `EarlyLintPass` and `LateLintPass`
1 + mac!()
<span class="boring">}</span></code></pre></pre>
<p>Assuming that we'd collect the <code>1</code> expression as a variable <code>left</code> and the
<code>0</code>/<code>mac!()</code> expression as a variable <code>right</code>, we can simply compare their
contexts. If the context is different, then we most likely are dealing with a
macro expansion and should just ignore it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if left.span.ctxt() != right.span.ctxt() {
    // The code author most likely cannot modify this expression
    return;
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Code that is not from expansion is in the "root" context.
So any spans whose <code>from_expansion</code> returns <code>false</code> can be assumed
to have the same context. Because of this, using <code>span.from_expansion()</code>
is often sufficient.</p>
</blockquote>
<p>Going a bit deeper, in a simple expression such as <code>a == b</code>,
<code>a</code> and <code>b</code> have the same context.
However, in a <code>macro_rules!</code> with <code>a == $b</code>, <code>$b</code> is expanded to
an expression that contains a different context from <code>a</code>.</p>
<p>Take a look at the following macro <code>m</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>macro_rules! m {
    ($a:expr, $b:expr) =&gt; {
        if $a.is_some() {
            $b;
        }
    }
}

let x: Option&lt;u32&gt; = Some(42);
m!(x, x.unwrap());
<span class="boring">}</span></code></pre></pre>
<p>If the <code>m!(x, x.unwrap());</code> line is expanded, we would get two expanded
expressions:</p>
<ul>
<li><code>x.is_some()</code> (from the <code>$a.is_some()</code> line in the <code>m</code> macro)</li>
<li><code>x.unwrap()</code> (corresponding to <code>$b</code> in the <code>m</code> macro)</li>
</ul>
<p>Suppose <code>x.is_some()</code> expression's span is associated with the <code>x_is_some_span</code> variable
and <code>x.unwrap()</code> expression's span is associated with <code>x_unwrap_span</code> variable,
we could assume that these two spans do not share the same context:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// x.is_some() is from inside the macro
// x.unwrap() is from outside the macro
assert_ne!(x_is_some_span.ctxt(), x_unwrap_span.ctxt());
<span class="boring">}</span></code></pre></pre>
<h3 id="the-in_external_macro-function"><a class="header" href="#the-in_external_macro-function">The <code>in_external_macro</code> function</a></h3>
<p><code>Span</code> provides a method (<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a>) that can
detect if the given span is from a macro defined in a foreign crate.</p>
<p>Therefore, if we really want a new lint to work with macro-generated code,
this is the next line of defense to avoid macros not defined inside
the current crate since it is unfair to the user if Clippy lints code
which the user cannot change.</p>
<p>For example, assume we have the following code that is being examined
by Clippy:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[macro_use]
extern crate a_foreign_crate_with_macros;

// `foo` macro is defined in `a_foreign_crate_with_macros`
foo!("bar");
<span class="boring">}</span></code></pre></pre>
<p>Also assume that we get the corresponding variable <code>foo_span</code> for the
<code>foo</code> macro call, we could decide not to lint if <code>in_external_macro</code>
results in <code>true</code> (note that <code>cx</code> can be <code>EarlyContext</code> or <code>LateContext</code>):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if foo_span.in_external_macro(cx.sess().source_map()) {
    // We should ignore macro from a foreign crate.
    return;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="the-is_from_proc_macro-function"><a class="header" href="#the-is_from_proc_macro-function">The <code>is_from_proc_macro</code> function</a></h3>
<p>A common point of confusion is the existence of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/clippy_utils/fn.is_from_proc_macro.html"><code>is_from_proc_macro</code></a>
and how it differs from the other <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a>/<a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> functions.</p>
<p>While <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a> and <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.from_expansion"><code>from_expansion</code></a> both work perfectly fine for detecting expanded code
from <em>declarative</em> macros (i.e. <code>macro_rules!</code> and macros 2.0),
detecting <em>proc macro</em>-generated code is a bit more tricky, as proc macros can (and often do)
freely manipulate the span of returned tokens.</p>
<p>In practice, this often happens through the use of <a href="https://docs.rs/quote/latest/quote/macro.quote_spanned.html"><code>quote::quote_spanned!</code></a> with a span from the input tokens.</p>
<p>In those cases, there is no <em>reliable</em> way for the compiler (and tools like Clippy)
to distinguish code that comes from such a proc macro from code that the user wrote directly,
and <a href="https://doc.rust-lang.org/stable/nightly-rustc/rustc_span/struct.Span.html#method.in_external_macro"><code>in_external_macro</code></a> will return <code>false</code>.</p>
<p>This is usually not an issue for the compiler and actually helps proc macro authors create better error messages,
as it allows associating parts of the expansion with parts of the macro input and lets the compiler
point the user to the relevant code in case of a compile error.</p>
<p>However, for Clippy this is inconvenient, because most of the time <em>we don't</em> want
to lint proc macro-generated code and this makes it impossible to tell what is and isn't proc macro code.</p>
<blockquote>
<p>NOTE: this is specifically only an issue when a proc macro explicitly sets the span to that of an <strong>input span</strong>.</p>
<p>For example, other common ways of creating <code>TokenStream</code>s, such as <code>"fn foo() {...}".parse::&lt;TokenStream&gt;()</code>,
sets each token's span to <code>Span::call_site()</code>, which already marks the span as coming from a proc macro
and the usual span methods have no problem detecting that as a macro span.</p>
</blockquote>
<p>As such, Clippy has its own <code>is_from_proc_macro</code> function which tries to <em>approximate</em>
whether a span comes from a proc macro, by checking whether the source text at the given span
lines up with the given AST node.</p>
<p>This function is typically used in combination with the other mentioned macro span functions,
but is usually called much later into the condition chain as it's a bit heavier than most other conditions,
so that the other cheaper conditions can fail faster. For example, the <code>borrow_deref_ref</code> lint:</p>
<pre><code class="language-rs">impl&lt;'tcx&gt; LateLintPass&lt;'tcx&gt; for BorrowDerefRef {
    fn check_expr(&amp;mut self, cx: &amp;LateContext&lt;'tcx&gt;, e: &amp;rustc_hir::Expr&lt;'tcx&gt;) {
        if let ... = ...
            &amp;&amp; ...
            &amp;&amp; !e.span.from_expansion()
            &amp;&amp; ...
            &amp;&amp; ...
            &amp;&amp; !is_from_proc_macro(cx, e)
            &amp;&amp; ...
        {
            ...
        }
    }
}
</code></pre>
<h3 id="testing-lints-with-macro-expansions"><a class="header" href="#testing-lints-with-macro-expansions">Testing lints with macro expansions</a></h3>
<p>To test that all of these cases are handled correctly in your lint,
we have a helper auxiliary crate that exposes various macros, used by tests like so:</p>
<pre><pre class="playground"><code class="language-rust edition2024">//@aux-build:proc_macros.rs

extern crate proc_macros;

fn main() {
    proc_macros::external!{ code_that_should_trigger_your_lint }
    proc_macros::with_span!{ span code_that_should_trigger_your_lint }
}</code></pre></pre>
<p>This exercises two cases:</p>
<ul>
<li>
<p><code>proc_macros::external!</code> is a simple proc macro that echos the input tokens back but with a macro span:
this represents the usual, common case where an external macro expands to code that your lint would trigger,
and is correctly handled by <code>in_external_macro</code> and <code>Span::from_expansion</code>.</p>
</li>
<li>
<p><code>proc_macros::with_span!</code> echos back the input tokens starting from the second token
with the span of the first token: this is where the other functions will fail and <code>is_from_proc_macro</code> is needed</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../development/method_checking.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../development/common_tools_writing_lints.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../development/method_checking.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../development/common_tools_writing_lints.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace-2a3cd908.js"></script>
        <script src="../mode-rust-2c9d5c9a.js"></script>
        <script src="../editor-16ca416c.js"></script>
        <script src="../theme-dawn-4493f9c8.js"></script>
        <script src="../theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="../elasticlunr-ef4e11c1.min.js"></script>
        <script src="../mark-09e88c2c.min.js"></script>
        <script src="../searcher-9aeb6ddf.js"></script>

        <script src="../clipboard-1626706a.min.js"></script>
        <script src="../highlight-abc7f01d.js"></script>
        <script src="../book-9576a2db.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
