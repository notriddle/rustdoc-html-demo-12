<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>E0038 - Error codes index</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Book listing all Rust error codes">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="error-index.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Error codes index</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/rust/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="error-code-e0038"><a class="header" href="#error-code-e0038">Error code E0038</a></h1>
<p>For any given trait <code>Trait</code> there may be a related <em>type</em> called the <em>trait
object type</em> which is typically written as <code>dyn Trait</code>. In earlier editions of
Rust, trait object types were written as plain <code>Trait</code> (just the name of the
trait, written in type positions) but this was a bit too confusing, so we now
write <code>dyn Trait</code>.</p>
<p>Some traits are not allowed to be used as trait object types. The traits that
are allowed to be used as trait object types are called "dyn-compatible"<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>
traits. Attempting to use a trait object type for a trait that is not
dyn-compatible will trigger error E0038.</p>
<p>Two general aspects of trait object types give rise to the restrictions:</p>
<ol>
<li>
<p>Trait object types are dynamically sized types (DSTs), and trait objects of
these types can only be accessed through pointers, such as <code>&amp;dyn Trait</code> or
<code>Box&lt;dyn Trait&gt;</code>. The size of such a pointer is known, but the size of the
<code>dyn Trait</code> object pointed-to by the pointer is <em>opaque</em> to code working
with it, and different trait objects with the same trait object type may
have different sizes.</p>
</li>
<li>
<p>The pointer used to access a trait object is paired with an extra pointer
to a "virtual method table" or "vtable", which is used to implement dynamic
dispatch to the object's implementations of the trait's methods. There is a
single such vtable for each trait implementation, but different trait
objects with the same trait object type may point to vtables from different
implementations.</p>
</li>
</ol>
<p>The specific conditions that violate dyn-compatibility follow, most of which
relate to missing size information and vtable polymorphism arising from these
aspects.</p>
<h3 id="the-trait-requires-self-sized"><a class="header" href="#the-trait-requires-self-sized">The trait requires <code>Self: Sized</code></a></h3>
<p>Traits that are declared as <code>Trait: Sized</code> or which otherwise inherit a
constraint of <code>Self:Sized</code> are not dyn-compatible.</p>
<p>The reasoning behind this is somewhat subtle. It derives from the fact that Rust
requires (and defines) that every trait object type <code>dyn Trait</code> automatically
implements <code>Trait</code>. Rust does this to simplify error reporting and ease
interoperation between static and dynamic polymorphism. For example, this code
works:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
}

fn static_foo&lt;T:Trait + ?Sized&gt;(b: &amp;T) {
}

fn dynamic_bar(a: &amp;dyn Trait) {
    static_foo(a)
}
<span class="boring">}</span></code></pre></pre>
<p>This code works because <code>dyn Trait</code>, if it exists, always implements <code>Trait</code>.</p>
<p>However as we know, any <code>dyn Trait</code> is also unsized, and so it can never
implement a sized trait like <code>Trait:Sized</code>. So, rather than allow an exception
to the rule that <code>dyn Trait</code> always implements <code>Trait</code>, Rust chooses to prohibit
such a <code>dyn Trait</code> from existing at all.</p>
<p>Only unsized traits are considered dyn-compatible.</p>
<p>Generally, <code>Self: Sized</code> is used to indicate that the trait should not be used
as a trait object. If the trait comes from your own crate, consider removing
this restriction.</p>
<h3 id="method-references-the-self-type-in-its-parameters-or-return-type"><a class="header" href="#method-references-the-self-type-in-its-parameters-or-return-type">Method references the <code>Self</code> type in its parameters or return type</a></h3>
<p>This happens when a trait has a method like the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

impl Trait for String {
    fn foo(&amp;self) -&gt; Self {
        "hi".to_owned()
    }
}

impl Trait for u8 {
    fn foo(&amp;self) -&gt; Self {
        1
    }
}
<span class="boring">}</span></code></pre></pre>
<p>(Note that <code>&amp;self</code> and <code>&amp;mut self</code> are okay, it's additional <code>Self</code> types which
cause this problem.)</p>
<p>In such a case, the compiler cannot predict the return type of <code>foo()</code> in a
situation like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self;
}

fn call_foo(x: Box&lt;dyn Trait&gt;) {
    let y = x.foo(); // What type is y?
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>If only some methods aren't dyn-compatible, you can add a <code>where Self: Sized</code>
bound on them to mark them as explicitly unavailable to trait objects. The
functionality will still be available to all other implementers, including
<code>Box&lt;dyn Trait&gt;</code> which is itself sized (assuming you <code>impl Trait for Box&lt;dyn Trait&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self) -&gt; Self where Self: Sized;
    // more functions
}
<span class="boring">}</span></code></pre></pre>
<p>Now, <code>foo()</code> can no longer be called on a trait object, but you will now be
allowed to make a trait object, and that will be able to call any dyn-compatible
methods. With such a bound, one can still call <code>foo()</code> on types implementing
that trait that aren't behind trait objects.</p>
<h3 id="method-has-generic-type-parameters"><a class="header" href="#method-has-generic-type-parameters">Method has generic type parameters</a></h3>
<p>As mentioned before, trait objects contain pointers to method tables. So, if we
have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo(&amp;self);
}

impl Trait for String {
    fn foo(&amp;self) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo(&amp;self) {
        // implementation 2
    }
}
// ...
<span class="boring">}</span></code></pre></pre>
<p>At compile time each implementation of <code>Trait</code> will produce a table containing
the various methods (and other items) related to the implementation, which will
be used as the virtual method table for a <code>dyn Trait</code> object derived from that
implementation.</p>
<p>This works fine, but when the method gains generic parameters, we can have a
problem.</p>
<p>Usually, generic parameters get <em>monomorphized</em>. For example, if I have</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(x: T) {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>The machine code for <code>foo::&lt;u8&gt;()</code>, <code>foo::&lt;bool&gt;()</code>, <code>foo::&lt;String&gt;()</code>, or any
other instantiation is different. Hence the compiler generates the
implementation on-demand. If you call <code>foo()</code> with a <code>bool</code> parameter, the
compiler will only generate code for <code>foo::&lt;bool&gt;()</code>. When we have additional
type parameters, the number of monomorphized implementations the compiler
generates does not grow drastically, since the compiler will only generate an
implementation if the function is called with fully concrete arguments
(i.e., arguments which do not contain any generic parameters).</p>
<p>However, with trait objects we have to make a table containing <em>every</em> object
that implements the trait. Now, if it has type parameters, we need to add
implementations for every type that implements the trait, and there could
theoretically be an infinite number of types.</p>
<p>For example, with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T);
    // more methods
}

impl Trait for String {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 1
    }
}

impl Trait for u8 {
    fn foo&lt;T&gt;(&amp;self, on: T) {
        // implementation 2
    }
}

// 8 more implementations
<span class="boring">}</span></code></pre></pre>
<p>Now, if we have the following code:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">trait Trait { fn foo&lt;T&gt;(&amp;self, on: T); }
</span><span class="boring">impl Trait for String { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for u8 { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">impl Trait for bool { fn foo&lt;T&gt;(&amp;self, on: T) {} }
</span><span class="boring">// etc.
</span>fn call_foo(thing: Box&lt;dyn Trait&gt;) {
    thing.foo(true); // this could be any one of the 8 types above
    thing.foo(1);
    thing.foo("hello");
}
<span class="boring">}</span></code></pre></pre>
<p>We don't just need to create a table of all implementations of all methods of
<code>Trait</code>, we need to create such a table, for each different type fed to
<code>foo()</code>. In this case this turns out to be (10 types implementing <code>Trait</code>)*(3
types being fed to <code>foo()</code>) = 30 implementations!</p>
<p>With real world traits these numbers can grow drastically.</p>
<p>To fix this, it is suggested to use a <code>where Self: Sized</code> bound similar to the
fix for the sub-error above if you do not intend to call the method with type
parameters:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Trait {
    fn foo&lt;T&gt;(&amp;self, on: T) where Self: Sized;
    // more methods
}
<span class="boring">}</span></code></pre></pre>
<p>If this is not an option, consider replacing the type parameter with another
trait object (e.g., if <code>T: OtherTrait</code>, use <code>on: Box&lt;dyn OtherTrait&gt;</code>). If the
number of types you intend to feed to this method is limited, consider manually
listing out the methods of different types.</p>
<h3 id="method-has-no-receiver"><a class="header" href="#method-has-no-receiver">Method has no receiver</a></h3>
<p>Methods that do not take a <code>self</code> parameter can't be called since there won't be
a way to get a pointer to the method table for them.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8;
}
<span class="boring">}</span></code></pre></pre>
<p>This could be called as <code>&lt;Foo as Foo&gt;::foo()</code>, which would not be able to pick
an implementation.</p>
<p>Adding a <code>Self: Sized</code> bound to these methods will generally make this compile.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo() -&gt; u8 where Self: Sized;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-contains-associated-constants"><a class="header" href="#trait-contains-associated-constants">Trait contains associated constants</a></h3>
<p>Just like static functions, associated constants aren't stored on the method
table. If the trait or any subtrait contain an associated constant, they are not
dyn compatible.</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    const X: i32;
}

impl dyn Foo {}
<span class="boring">}</span></code></pre></pre>
<p>A simple workaround is to use a helper method instead:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn x(&amp;self) -&gt; i32;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="trait-uses-self-as-a-type-parameter-in-the-supertrait-listing"><a class="header" href="#trait-uses-self-as-a-type-parameter-in-the-supertrait-listing">Trait uses <code>Self</code> as a type parameter in the supertrait listing</a></h3>
<p>This is similar to the second sub-error, but subtler. It happens in situations
like the following:</p>
<pre><pre class="playground"><code class="language-rust compile_fail E0038">trait Super&lt;A: ?Sized&gt; {}

trait Trait: Super&lt;Self&gt; {
}

struct Foo;

impl Super&lt;Foo&gt; for Foo{}

impl Trait for Foo {}

fn main() {
    let x: Box&lt;dyn Trait&gt;;
}</code></pre></pre>
<p>Here, the supertrait might have methods as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Super&lt;A: ?Sized&gt; {
    fn get_a(&amp;self) -&gt; &amp;A; // note that this is dyn-compatible!
}
<span class="boring">}</span></code></pre></pre>
<p>If the trait <code>Trait</code> was deriving from something like <code>Super&lt;String&gt;</code> or
<code>Super&lt;T&gt;</code> (where <code>Foo</code> itself is <code>Foo&lt;T&gt;</code>), this is okay, because given a type
<code>get_a()</code> will definitely return an object of that type.</p>
<p>However, if it derives from <code>Super&lt;Self&gt;</code>, even though <code>Super</code> is
dyn-compatible, the method <code>get_a()</code> would return an object of unknown type when
called on the function. <code>Self</code> type parameters let us make dyn-compatible traits
no longer compatible, so they are forbidden when specifying supertraits.</p>
<p>There's no easy fix for this. Generally, code will need to be refactored so that
you no longer need to derive from <code>Super&lt;Self&gt;</code>.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>Formerly known as "object-safe". <a href="#fr-1-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="E0034.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="E0040.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="E0034.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="E0040.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="error-index.js"></script>



    </div>
    </body>
</html>
