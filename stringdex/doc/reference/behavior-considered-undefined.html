<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Behavior considered undefined - The Rust Reference</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-3865ffda.css">
        <link rel="stylesheet" href="css/general-4c35105a.css">
        <link rel="stylesheet" href="css/chrome-c0e702bf.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference-94a8e8ad.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-3109fce4.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-4adb5027.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/behavior-considered-undefined.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="rule" id="r-undefined"><a class="rule-link" href="#r-undefined" title="undefined"><span>[undefined]</span/></a>
</div>
<h1 id="behavior-considered-undefined"><a class="header" href="#behavior-considered-undefined">Behavior considered undefined</a></h1>
<div class="rule" id="r-undefined.general"><a class="rule-link" href="#r-undefined.general" title="undefined.general"><span>[undefined<wbr>.general]</span/></a>
</div>
<p>Rust code is incorrect if it exhibits any of the behaviors in the following
list. This includes code within <code>unsafe</code> blocks and <code>unsafe</code> functions.
<code>unsafe</code> only means that avoiding undefined behavior is on the programmer; it
does not change anything about the fact that Rust programs must never cause
undefined behavior.</p>
<div class="rule" id="r-undefined.soundness"><a class="rule-link" href="#r-undefined.soundness" title="undefined.soundness"><span>[undefined<wbr>.soundness]</span/></a>
</div>
<p>It is the programmer’s responsibility when writing <code>unsafe</code> code to ensure that
any safe code interacting with the <code>unsafe</code> code cannot trigger these
behaviors. <code>unsafe</code> code that satisfies this property for any safe client is
called <em>sound</em>; if <code>unsafe</code> code can be misused by safe code to exhibit
undefined behavior, it is <em>unsound</em>.</p>
<div class="alert alert-warning">
<blockquote>
<p class="alert-title"><svg viewBox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>
<p>The following list is not exhaustive; it may grow or shrink. There is no formal model of Rust’s semantics for what is and is not allowed in unsafe code, so there may be more behavior considered unsafe. We also reserve the right to make some of the behavior in that list defined in the future. In other words, this list does not say that anything will <em>definitely</em> always be undefined in all future Rust version (but we might make such commitments for some list items in the future).</p>
<p>Please read the <a href="../nomicon/index.html">Rustonomicon</a> before writing unsafe code.</p>
</blockquote>
</div>
<div class="rule" id="r-undefined.race"><a class="rule-link" href="#r-undefined.race" title="undefined.race"><span>[undefined<wbr>.race]</span/></a>
</div>
<ul>
<li>Data races.</li>
</ul>
<div class="rule" id="r-undefined.pointer-access"><a class="rule-link" href="#r-undefined.pointer-access" title="undefined.pointer-access"><span>[undefined<wbr>.pointer-access]</span/></a>
</div>
<ul>
<li>Accessing (loading from or storing to) a place that is <a href="#dangling-pointers">dangling</a> or <a href="#places-based-on-misaligned-pointers">based on
a misaligned pointer</a>.</li>
</ul>
<div class="rule" id="r-undefined.place-projection"><a class="rule-link" href="#r-undefined.place-projection" title="undefined.place-projection"><span>[undefined<wbr>.place-projection]</span/></a>
</div>
<ul>
<li>Performing a place projection that violates the requirements of <a href="../std/primitive.pointer.html#method.offset">in-bounds
pointer arithmetic</a>. A place projection is a <a href="expressions/field-expr.html">field
expression</a>, a <a href="expressions/tuple-expr.html#tuple-indexing-expressions">tuple index expression</a>, or an
<a href="expressions/array-expr.html#array-and-slice-indexing-expressions">array/slice index expression</a>.</li>
</ul>
<div class="rule" id="r-undefined.alias"><a class="rule-link" href="#r-undefined.alias" title="undefined.alias"><span>[undefined<wbr>.alias]</span/></a>
</div>
<ul>
<li>
<p>Breaking the pointer aliasing rules. The exact aliasing rules are not determined yet, but here is an outline of the general principles:
<code>&amp;T</code> must point to memory that is not mutated while they are live (except for data inside an <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>),
and <code>&amp;mut T</code> must point to memory that is not read or written by any pointer not derived from the reference and that no other reference points to while they are live.
<code>Box&lt;T&gt;</code> is treated similar to <code>&amp;'static mut T</code> for the purpose of these rules.
The exact liveness duration is not specified, but some bounds exist:</p>
<ul>
<li>For references, the liveness duration is upper-bounded by the syntactic
lifetime assigned by the borrow checker; it cannot be live any <em>longer</em> than that lifetime.</li>
<li>Each time a reference or box is dereferenced or reborrowed, it is considered live.</li>
<li>Each time a reference or box is passed to or returned from a function, it is considered live.</li>
<li>When a reference (but not a <code>Box</code>!) is passed to a function, it is live at least as long as that function call, again except if the <code>&amp;T</code> contains an <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>.</li>
</ul>
<p>All this also applies when values of these types are passed in a (nested) field of a compound type, but not behind pointer indirections.</p>
</li>
</ul>
<div class="rule" id="r-undefined.immutable"><a class="rule-link" href="#r-undefined.immutable" title="undefined.immutable"><span>[undefined<wbr>.immutable]</span/></a>
</div>
<ul>
<li>
<p>Mutating immutable bytes.
All bytes reachable through a <a href="destructors.html#constant-promotion">const-promoted</a> expression are immutable, as well as bytes reachable through borrows in <code>static</code> and <code>const</code> initializers that have been <a href="destructors.html#temporary-lifetime-extension">lifetime-extended</a> to <code>'static</code>.
The bytes owned by an immutable binding or immutable <code>static</code> are immutable, unless those bytes are part of an <a href="../core/cell/struct.UnsafeCell.html"><code>UnsafeCell&lt;U&gt;</code></a>.</p>
<p>Moreover, the bytes <a href="#pointed-to-bytes">pointed to</a> by a shared reference, including transitively through other references (both shared and mutable) and <code>Box</code>es, are immutable; transitivity includes those references stored in fields of compound types.</p>
<p>A mutation is any write of more than 0 bytes which overlaps with any of the relevant bytes (even if that write does not change the memory contents).</p>
</li>
</ul>
<div class="rule" id="r-undefined.intrinsic"><a class="rule-link" href="#r-undefined.intrinsic" title="undefined.intrinsic"><span>[undefined<wbr>.intrinsic]</span/></a>
</div>
<ul>
<li>Invoking undefined behavior via compiler intrinsics.</li>
</ul>
<div class="rule" id="r-undefined.target-feature"><a class="rule-link" href="#r-undefined.target-feature" title="undefined.target-feature"><span>[undefined<wbr>.target-feature]</span/></a>
</div>
<ul>
<li>Executing code compiled with platform features that the current platform
does not support (see <a href="attributes/codegen.html#the-target_feature-attribute"><code>target_feature</code></a>), <em>except</em> if the platform explicitly documents this to be safe.</li>
</ul>
<div class="rule" id="r-undefined.call"><a class="rule-link" href="#r-undefined.call" title="undefined.call"><span>[undefined<wbr>.call]</span/></a>
</div>
<ul>
<li>Calling a function with the wrong <a href="items/external-blocks.html#abi">call ABI</a>, or unwinding past a stack frame that does not allow unwinding (e.g. by calling a <code>"C-unwind"</code> function imported or transmuted as a <code>"C"</code> function or function pointer).</li>
</ul>
<div class="rule" id="r-undefined.invalid"><a class="rule-link" href="#r-undefined.invalid" title="undefined.invalid"><span>[undefined<wbr>.invalid]</span/></a>
</div>
<ul>
<li>Producing an <a href="#invalid-values">invalid value</a>. “Producing” a
value happens any time a value is assigned to or read from a place, passed to
a function/primitive operation or returned from a function/primitive
operation.</li>
</ul>
<div class="rule" id="r-undefined.asm"><a class="rule-link" href="#r-undefined.asm" title="undefined.asm"><span>[undefined<wbr>.asm]</span/></a>
</div>
<ul>
<li>Incorrect use of inline assembly. For more details, refer to the <a href="inline-assembly.html#rules-for-inline-assembly">rules</a> to
follow when writing code that uses inline assembly.</li>
</ul>
<div class="rule" id="r-undefined.const-transmute-ptr2int"><a class="rule-link" href="#r-undefined.const-transmute-ptr2int" title="undefined.const-transmute-ptr2int"><span>[undefined<wbr>.const-transmute-ptr2int]</span/></a>
</div>
<ul>
<li><strong>In <a href="const_eval.html#const-context">const context</a></strong>: transmuting or otherwise
reinterpreting a pointer (reference, raw pointer, or function pointer) into
some allocated object as a non-pointer type (such as integers).
‘Reinterpreting’ refers to loading the pointer value at integer type without a
cast, e.g. by doing raw pointer casts or using a union.</li>
</ul>
<div class="rule" id="r-undefined.runtime"><a class="rule-link" href="#r-undefined.runtime" title="undefined.runtime"><span>[undefined<wbr>.runtime]</span/></a>
</div>
<ul>
<li>Violating assumptions of the Rust runtime. Most assumptions of the Rust runtime are currently not explicitly documented.
<ul>
<li>For assumptions specifically related to unwinding, see the <a href="panic.html#unwinding-across-ffi-boundaries">panic documentation</a>.</li>
<li>The runtime assumes that a Rust stack frame is not deallocated without executing destructors for local variables owned by the stack frame. This assumption can be violated by C functions like <code>longjmp</code>.</li>
</ul>
</li>
</ul>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewBox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p>Undefined behavior affects the entire program. For example, calling a function in C that exhibits undefined behavior of C means your entire program contains undefined behaviour that can also affect the Rust code. And vice versa, undefined behavior in Rust can cause adverse affects on code executed by any FFI calls to other languages.</p>
</blockquote>
</div>
<div class="rule" id="r-undefined.pointed-to"><a class="rule-link" href="#r-undefined.pointed-to" title="undefined.pointed-to"><span>[undefined<wbr>.pointed-to]</span/></a>
</div>
<h2 id="pointed-to-bytes"><a class="header" href="#pointed-to-bytes">Pointed-to bytes</a></h2>
<p>The span of bytes a pointer or reference “points to” is determined by the pointer value and the size of the pointee type (using <code>size_of_val</code>).</p>
<div class="rule" id="r-undefined.misaligned"><a class="rule-link" href="#r-undefined.misaligned" title="undefined.misaligned"><span>[undefined<wbr>.misaligned]</span/></a>
</div>
<h2 id="places-based-on-misaligned-pointers"><a class="header" href="#places-based-on-misaligned-pointers">Places based on misaligned pointers</a></h2>
<div class="rule" id="r-undefined.misaligned.general"><a class="rule-link" href="#r-undefined.misaligned.general" title="undefined.misaligned.general"><span>[undefined<wbr>.misaligned<wbr>.general]</span/></a>
</div>
<p>A place is said to be “based on a misaligned pointer” if the last <code>*</code> projection
during place computation was performed on a pointer that was not aligned for its
type. (If there is no <code>*</code> projection in the place expression, then this is
accessing the field of a local or <code>static</code> and rustc will guarantee proper alignment. If
there are multiple <code>*</code> projection, then each of them incurs a load of the
pointer-to-be-dereferenced itself from memory, and each of these loads is
subject to the alignment constraint. Note that some <code>*</code> projections can be
omitted in surface Rust syntax due to automatic dereferencing; we are
considering the fully expanded place expression here.)</p>
<p>For instance, if <code>ptr</code> has type <code>*const S</code> where <code>S</code> has an alignment of 8, then
<code>ptr</code> must be 8-aligned or else <code>(*ptr).f</code> is “based on an misaligned pointer”.
This is true even if the type of the field <code>f</code> is <code>u8</code> (i.e., a type with
alignment 1). In other words, the alignment requirement derives from the type of
the pointer that was dereferenced, <em>not</em> the type of the field that is being
accessed.</p>
<div class="rule" id="r-undefined.misaligned.load-store"><a class="rule-link" href="#r-undefined.misaligned.load-store" title="undefined.misaligned.load-store"><span>[undefined<wbr>.misaligned<wbr>.load-store]</span/></a>
</div>
<p>Note that a place based on a misaligned pointer only leads to Undefined Behavior
when it is loaded from or stored to.</p>
<div class="rule" id="r-undefined.misaligned.raw"><a class="rule-link" href="#r-undefined.misaligned.raw" title="undefined.misaligned.raw"><span>[undefined<wbr>.misaligned<wbr>.raw]</span/></a>
</div>
<p><code>&amp;raw const</code>/<code>&amp;raw mut</code> on such a place is allowed.</p>
<div class="rule" id="r-undefined.misaligned.reference"><a class="rule-link" href="#r-undefined.misaligned.reference" title="undefined.misaligned.reference"><span>[undefined<wbr>.misaligned<wbr>.reference]</span/></a>
</div>
<p><code>&amp;</code>/<code>&amp;mut</code> on a place requires the alignment of the field type (or
else the program would be “producing an invalid value”), which generally is a
less restrictive requirement than being based on an aligned pointer.</p>
<div class="rule" id="r-undefined.misaligned.packed"><a class="rule-link" href="#r-undefined.misaligned.packed" title="undefined.misaligned.packed"><span>[undefined<wbr>.misaligned<wbr>.packed]</span/></a>
</div>
<p>Taking a reference will lead to a compiler error in cases where the field type might be
more aligned than the type that contains it, i.e., <code>repr(packed)</code>. This means
that being based on an aligned pointer is always sufficient to ensure that the
new reference is aligned, but it is not always necessary.</p>
<div class="rule" id="r-undefined.dangling"><a class="rule-link" href="#r-undefined.dangling" title="undefined.dangling"><span>[undefined<wbr>.dangling]</span/></a>
</div>
<h2 id="dangling-pointers"><a class="header" href="#dangling-pointers">Dangling pointers</a></h2>
<div class="rule" id="r-undefined.dangling.general"><a class="rule-link" href="#r-undefined.dangling.general" title="undefined.dangling.general"><span>[undefined<wbr>.dangling<wbr>.general]</span/></a>
</div>
<p>A reference/pointer is “dangling” if not all of the bytes it
<a href="#pointed-to-bytes">points to</a> are part of the same live allocation (so in particular they all have to be
part of <em>some</em> allocation).</p>
<div class="rule" id="r-undefined.dangling.zero-size"><a class="rule-link" href="#r-undefined.dangling.zero-size" title="undefined.dangling.zero-size"><span>[undefined<wbr>.dangling<wbr>.zero-size]</span/></a>
</div>
<p>If the size is 0, then the pointer is trivially never “dangling”
(even if it is a null pointer).</p>
<div class="rule" id="r-undefined.dangling.dynamic-size"><a class="rule-link" href="#r-undefined.dangling.dynamic-size" title="undefined.dangling.dynamic-size"><span>[undefined<wbr>.dangling<wbr>.dynamic-size]</span/></a>
</div>
<p>Note that dynamically sized types (such as slices and strings) point to their
entire range, so it is important that the length metadata is never too large.</p>
<div class="rule" id="r-undefined.dangling.alloc-limit"><a class="rule-link" href="#r-undefined.dangling.alloc-limit" title="undefined.dangling.alloc-limit"><span>[undefined<wbr>.dangling<wbr>.alloc-limit]</span/></a>
</div>
<p>In particular, the dynamic size of a Rust value (as determined by <code>size_of_val</code>)
must never exceed <code>isize::MAX</code>, since it is impossible for a single allocation
to be larger than <code>isize::MAX</code>.</p>
<div class="rule" id="r-undefined.validity"><a class="rule-link" href="#r-undefined.validity" title="undefined.validity"><span>[undefined<wbr>.validity]</span/></a>
</div>
<h2 id="invalid-values"><a class="header" href="#invalid-values">Invalid values</a></h2>
<div class="rule" id="r-undefined.validity.general"><a class="rule-link" href="#r-undefined.validity.general" title="undefined.validity.general"><span>[undefined<wbr>.validity<wbr>.general]</span/></a>
</div>
<p>The Rust compiler assumes that all values produced during program execution are
“valid”, and producing an invalid value is hence immediate UB.</p>
<p>Whether a value is valid depends on the type:</p>
<div class="rule" id="r-undefined.validity.bool"><a class="rule-link" href="#r-undefined.validity.bool" title="undefined.validity.bool"><span>[undefined<wbr>.validity<wbr>.bool]</span/></a>
</div>
<ul>
<li>A <a href="types/boolean.html"><code>bool</code></a> value must be <code>false</code> (<code>0</code>) or <code>true</code> (<code>1</code>).</li>
</ul>
<div class="rule" id="r-undefined.validity.fn-pointer"><a class="rule-link" href="#r-undefined.validity.fn-pointer" title="undefined.validity.fn-pointer"><span>[undefined<wbr>.validity<wbr>.fn-pointer]</span/></a>
</div>
<ul>
<li>A <code>fn</code> pointer value must be non-null.</li>
</ul>
<div class="rule" id="r-undefined.validity.char"><a class="rule-link" href="#r-undefined.validity.char" title="undefined.validity.char"><span>[undefined<wbr>.validity<wbr>.char]</span/></a>
</div>
<ul>
<li>A <code>char</code> value must not be a surrogate (i.e., must not be in the range <code>0xD800..=0xDFFF</code>) and must be equal to or less than <code>char::MAX</code>.</li>
</ul>
<div class="rule" id="r-undefined.validity.never"><a class="rule-link" href="#r-undefined.validity.never" title="undefined.validity.never"><span>[undefined<wbr>.validity<wbr>.never]</span/></a>
</div>
<ul>
<li>A <code>!</code> value must never exist.</li>
</ul>
<div class="rule" id="r-undefined.validity.scalar"><a class="rule-link" href="#r-undefined.validity.scalar" title="undefined.validity.scalar"><span>[undefined<wbr>.validity<wbr>.scalar]</span/></a>
</div>
<ul>
<li>An integer (<code>i*</code>/<code>u*</code>), floating point value (<code>f*</code>), or raw pointer must be
initialized, i.e., must not be obtained from uninitialized memory.</li>
</ul>
<div class="rule" id="r-undefined.validity.str"><a class="rule-link" href="#r-undefined.validity.str" title="undefined.validity.str"><span>[undefined<wbr>.validity<wbr>.str]</span/></a>
</div>
<ul>
<li>A <code>str</code> value is treated like <code>[u8]</code>, i.e. it must be initialized.</li>
</ul>
<div class="rule" id="r-undefined.validity.enum"><a class="rule-link" href="#r-undefined.validity.enum" title="undefined.validity.enum"><span>[undefined<wbr>.validity<wbr>.enum]</span/></a>
</div>
<ul>
<li>An <code>enum</code> must have a valid discriminant, and all fields of the variant indicated by that discriminant must be valid at their respective type.</li>
</ul>
<div class="rule" id="r-undefined.validity.struct"><a class="rule-link" href="#r-undefined.validity.struct" title="undefined.validity.struct"><span>[undefined<wbr>.validity<wbr>.struct]</span/></a>
</div>
<ul>
<li>A <code>struct</code>, tuple, and array requires all fields/elements to be valid at their respective type.</li>
</ul>
<div class="rule" id="r-undefined.validity.union"><a class="rule-link" href="#r-undefined.validity.union" title="undefined.validity.union"><span>[undefined<wbr>.validity<wbr>.union]</span/></a>
</div>
<ul>
<li>For a <code>union</code>, the exact validity requirements are not decided yet.
Obviously, all values that can be created entirely in safe code are valid.
If the union has a zero-sized field, then every possible value is valid.
Further details are <a href="https://github.com/rust-lang/unsafe-code-guidelines/issues/438">still being debated</a>.</li>
</ul>
<div class="rule" id="r-undefined.validity.reference-box"><a class="rule-link" href="#r-undefined.validity.reference-box" title="undefined.validity.reference-box"><span>[undefined<wbr>.validity<wbr>.reference-box]</span/></a>
</div>
<ul>
<li>A reference or <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a> must be aligned and non-null, it cannot be <a href="#dangling-pointers">dangling</a>, and it must point to a valid value
(in case of dynamically sized types, using the actual dynamic type of the
pointee as determined by the metadata).
Note that the last point (about pointing to a valid value) remains a subject of some debate.</li>
</ul>
<div class="rule" id="r-undefined.validity.wide"><a class="rule-link" href="#r-undefined.validity.wide" title="undefined.validity.wide"><span>[undefined<wbr>.validity<wbr>.wide]</span/></a>
</div>
<ul>
<li>The metadata of a wide reference, <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, or raw pointer must match
the type of the unsized tail:
<ul>
<li><code>dyn Trait</code> metadata must be a pointer to a compiler-generated vtable for <code>Trait</code>.
(For raw pointers, this requirement remains a subject of some debate.)</li>
<li>Slice (<code>[T]</code>) metadata must be a valid <code>usize</code>.
Furthermore, for wide references and <a href="../alloc/boxed/struct.Box.html"><code>Box&lt;T&gt;</code></a>, slice metadata is invalid
if it makes the total size of the pointed-to value bigger than <code>isize::MAX</code>.</li>
</ul>
</li>
</ul>
<div class="rule" id="r-undefined.validity.valid-range"><a class="rule-link" href="#r-undefined.validity.valid-range" title="undefined.validity.valid-range"><span>[undefined<wbr>.validity<wbr>.valid-range]</span/></a>
</div>
<ul>
<li>
<p>If a type has a custom range of a valid values, then a valid value must be in that range.
In the standard library, this affects <a href="../core/ptr/non_null/struct.NonNull.html"><code>NonNull&lt;T&gt;</code></a> and <a href="../core/num/nonzero/struct.NonZero.html"><code>NonZero&lt;T&gt;</code></a>.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewBox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>
<p><code>rustc</code> achieves this with the unstable <code>rustc_layout_scalar_valid_range_*</code> attributes.</p>
</blockquote>
</div>
</li>
</ul>
<div class="rule" id="r-undefined.validity.undef"><a class="rule-link" href="#r-undefined.validity.undef" title="undefined.validity.undef"><span>[undefined<wbr>.validity<wbr>.undef]</span/></a>
</div>
<p><strong>Note:</strong> Uninitialized memory is also implicitly invalid for any type that has
a restricted set of valid values. In other words, the only cases in which
reading uninitialized memory is permitted are inside <code>union</code>s and in “padding”
(the gaps between the fields of a type).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="unsafe-keyword.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="unsafe-keyword.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="behavior-not-considered-unsafe.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-9aeb6ddf.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-9576a2db.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference-cfed9ca5.js"></script>



    </div>
    </body>
</html>
