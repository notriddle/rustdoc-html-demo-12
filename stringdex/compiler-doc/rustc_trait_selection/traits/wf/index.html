<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Core logic responsible for determining what it means for various type system primitives to be “well formed”. Actually checking whether these primitives are well formed is performed elsewhere (e.g. during type checking or item well formedness checking)."><title>rustc_trait_selection::traits::wf - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-528d32ef.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_trait_selection" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-dev" data-channel="nightly" data-search-js="search-e93015a6.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-1b37d467.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-c7770cbf.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module wf</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../rustc_trait_selection/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../../rustc_trait_selection/index.html">rustc_<wbr>trait_<wbr>selection</a><span class="version">1.91.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module wf</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rustc_<wbr>trait_<wbr>selection::<wbr>traits</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">rustc_trait_selection</a>::<wbr><a href="../index.html">traits</a></div><h1>Module <span>wf</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustc_trait_selection/traits/wf.rs.html#1-1104">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Core logic responsible for determining what it means for various type system
primitives to be “well formed”. Actually checking whether these primitives are
well formed is performed elsewhere (e.g. during type checking or item well formedness
checking).</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.WfPredicates.html" title="struct rustc_trait_selection::traits::wf::WfPredicates">WfPredicates</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Elaborate.html" title="enum rustc_trait_selection::traits::wf::Elaborate">Elaborate</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>Controls whether we “elaborate” supertraits and so forth on the WF
predicates. This is a kind of hack to address #43784. The
underlying problem in that issue was a trait structure like:</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.clause_obligations.html" title="fn rustc_trait_selection::traits::wf::clause_obligations">clause_<wbr>obligations</a></dt><dd>Returns the requirements for <code>clause</code> to be well-formed.</dd><dt><a class="fn" href="fn.extend_cause_with_original_assoc_item_obligation.html" title="fn rustc_trait_selection::traits::wf::extend_cause_with_original_assoc_item_obligation">extend_<wbr>cause_<wbr>with_<wbr>original_<wbr>assoc_<wbr>item_<wbr>obligation</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dd>Points the cause span of a super predicate at the relevant associated type.</dd><dt><a class="fn" href="fn.object_region_bounds.html" title="fn rustc_trait_selection::traits::wf::object_region_bounds">object_<wbr>region_<wbr>bounds</a></dt><dd>Given an object type like <code>SomeTrait + Send</code>, computes the lifetime
bounds that must hold on the elided self type. These are derived
from the declarations of <code>SomeTrait</code>, <code>Send</code>, and friends – if
they declare <code>trait SomeTrait : 'static</code>, for example, then
<code>'static</code> would appear in the list.</dd><dt><a class="fn" href="fn.obligations.html" title="fn rustc_trait_selection::traits::wf::obligations">obligations</a></dt><dd>Returns the set of obligations needed to make <code>arg</code> well-formed.
If <code>arg</code> contains unresolved inference variables, this may include
further WF obligations. However, if <code>arg</code> IS an unresolved
inference variable, returns <code>None</code>, because we are not able to
make any progress at all. This is to prevent cycles where we
say “?0 is WF if ?0 is WF”.</dd><dt><a class="fn" href="fn.trait_obligations.html" title="fn rustc_trait_selection::traits::wf::trait_obligations">trait_<wbr>obligations</a></dt><dd>Returns the obligations that make this trait reference
well-formed. For example, if there is a trait <code>Set</code> defined like
<code>trait Set&lt;K: Eq&gt;</code>, then the trait bound <code>Foo: Set&lt;Bar&gt;</code> is WF
if <code>Bar: Eq</code>.</dd><dt><a class="fn" href="fn.unnormalized_obligations.html" title="fn rustc_trait_selection::traits::wf::unnormalized_obligations">unnormalized_<wbr>obligations</a></dt><dd>Compute the predicates that are required for a type to be well-formed.</dd></dl></section></div></main></body></html>