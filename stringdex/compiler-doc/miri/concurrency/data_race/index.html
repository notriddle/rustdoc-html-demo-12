<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Implementation of a data-race detector using Lamport Timestamps / Vector clocks based on the Dynamic Race Detection for C++: https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf which does not report false-positives when fences are used, and gives better accuracy in presence of read-modify-write operations."><title>miri::concurrency::data_race - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-528d32ef.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="miri" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-dev" data-channel="nightly" data-search-js="search-e93015a6.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-1b37d467.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-c7770cbf.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module data_race</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../miri/index.html">miri</a><span class="version">1.91.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module data_<wbr>race</a></h2><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In miri::<wbr>concurrency</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">miri</a>::<wbr><a href="../index.html">concurrency</a></div><h1>Module <span>data_<wbr>race</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/miri/concurrency/data_race.rs.html#1-1970">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Implementation of a data-race detector using Lamport Timestamps / Vector clocks
based on the Dynamic Race Detection for C++:
<a href="https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf">https://www.doc.ic.ac.uk/~afd/homepages/papers/pdfs/2017/POPL.pdf</a>
which does not report false-positives when fences are used, and gives better
accuracy in presence of read-modify-write operations.</p>
<p>The implementation contains modifications to correctly model the changes to the memory model in C++20
regarding the weakening of release sequences: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0982r1.html</a>.
Relaxed stores now unconditionally block all currently active release sequences and so per-thread tracking of release
sequences is not needed.</p>
<p>The implementation also models races with memory allocation and deallocation via treating allocation and
deallocation as a type of write internally for detecting data-races.</p>
<p>Weak memory orders are explored but not all weak behaviours are exhibited, so it can still miss data-races
but should not report false-positives</p>
<p>Data-race definition from(<a href="https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races">https://en.cppreference.com/w/cpp/language/memory_model#Threads_and_data_races</a>):
a data race occurs between two memory accesses if they are on different threads, at least one operation
is non-atomic, at least one operation is a write and neither access happens-before the other. Read the link
for full definition.</p>
<p>This re-uses vector indexes for threads that are known to be unable to report data-races, this is valid
because it only re-uses vector indexes once all currently-active (not-terminated) threads have an internal
vector clock that happens-after the join operation of the candidate thread. Threads that have not been joined
on are not considered. Since the threadâ€™s vector clock will only increase and a data-race implies that
there is some index x where <code>clock[x] &gt; thread_clock</code>, when this is true <code>clock[candidate-idx] &gt; thread_clock</code>
can never hold and hence a data-race can never be reported in that vector index again.
This means that the thread-index can be safely re-used, starting on the next timestamp for the newly created
thread.</p>
<p>The timestamps used in the data-race detector assign each sequence of non-atomic operations
followed by a single atomic or concurrent operation a single timestamp.
Write, Read, Write, ThreadJoin will be represented by a single timestamp value on a thread.
This is because extra increment operations between the operations in the sequence are not
required for accurate reporting of data-race values.</p>
<p>As per the paper a threads timestamp is only incremented after a release operation is performed
so some atomic operations that only perform acquires do not increment the timestamp. Due to shared
code some atomic operations may increment the timestamp when not necessary but this has no effect
on the data-race detection code.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AtomicMemoryCellClocks.html" title="struct miri::concurrency::data_race::AtomicMemoryCellClocks">Atomic<wbr>Memory<wbr>Cell<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Externally stored memory cell clocks
explicitly to reduce memory usage for the
common case where no atomic operations
exists on the memory cell.</dd><dt><a class="struct" href="struct.DataRace.html" title="struct miri::concurrency::data_race::DataRace">Data<wbr>Race</a></dt><dd>Error returned by finding a data race
should be elaborated upon.</dd><dt><a class="struct" href="struct.FrameState.html" title="struct miri::concurrency::data_race::FrameState">Frame<wbr>State</a></dt><dd>Vector clock state for a stack frame (tracking the local variables
that do not have an allocation yet).</dd><dt><a class="struct" href="struct.GlobalState.html" title="struct miri::concurrency::data_race::GlobalState">Global<wbr>State</a></dt><dd>Global data-race detection state, contains the currently
executing thread as well as the vector clocks associated
with each of the threads.</dd><dt><a class="struct" href="struct.LocalClocks.html" title="struct miri::concurrency::data_race::LocalClocks">Local<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Stripped-down version of <a href="struct.MemoryCellClocks.html" title="struct miri::concurrency::data_race::MemoryCellClocks"><code>MemoryCellClocks</code></a> for the clocks we need to keep track
of in a local that does not yet have addressable memory â€“ and hence can only
be accessed from the thread its stack frame belongs to, and cannot be access atomically.</dd><dt><a class="struct" href="struct.MemoryCellClocks.html" title="struct miri::concurrency::data_race::MemoryCellClocks">Memory<wbr>Cell<wbr>Clocks</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Per-byte vector clock metadata for data-race detection.</dd><dt><a class="struct" href="struct.ThreadClockSet.html" title="struct miri::concurrency::data_race::ThreadClockSet">Thread<wbr>Clock<wbr>Set</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>The current set of vector clocks describing the state
of a thread, contains the happens-before clock and
additional metadata to model atomic fence operations.</dd><dt><a class="struct" href="struct.ThreadExtraState.html" title="struct miri::concurrency::data_race::ThreadExtraState">Thread<wbr>Extra<wbr>State</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dd>Extra metadata associated with a thread.</dd><dt><a class="struct" href="struct.VClockAlloc.html" title="struct miri::concurrency::data_race::VClockAlloc">VClock<wbr>Alloc</a></dt><dd>Vector clock metadata for a logical memory allocation.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AccessType.html" title="enum miri::concurrency::data_race::AccessType">Access<wbr>Type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="enum" href="enum.AtomicAccessType.html" title="enum miri::concurrency::data_race::AtomicAccessType">Atomic<wbr>Access<wbr>Type</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt><dt><a class="enum" href="enum.AtomicFenceOrd.html" title="enum miri::concurrency::data_race::AtomicFenceOrd">Atomic<wbr>Fence<wbr>Ord</a></dt><dd>Valid atomic fence orderings, subset of atomic::Ordering.</dd><dt><a class="enum" href="enum.AtomicReadOrd.html" title="enum miri::concurrency::data_race::AtomicReadOrd">Atomic<wbr>Read<wbr>Ord</a></dt><dd>Valid atomic read orderings, subset of atomic::Ordering.</dd><dt><a class="enum" href="enum.AtomicRwOrd.html" title="enum miri::concurrency::data_race::AtomicRwOrd">Atomic<wbr>RwOrd</a></dt><dd>Valid atomic read-write orderings, alias of atomic::Ordering (not non-exhaustive).</dd><dt><a class="enum" href="enum.AtomicWriteOrd.html" title="enum miri::concurrency::data_race::AtomicWriteOrd">Atomic<wbr>Write<wbr>Ord</a></dt><dd>Valid atomic write orderings, subset of atomic::Ordering.</dd><dt><a class="enum" href="enum.NaReadType.html" title="enum miri::concurrency::data_race::NaReadType">NaRead<wbr>Type</a></dt><dd>Type of a non-atomic read operation.</dd><dt><a class="enum" href="enum.NaWriteType.html" title="enum miri::concurrency::data_race::NaWriteType">NaWrite<wbr>Type</a></dt><dd>Type of a non-atomic write operation: allocating memory, non-atomic writes, and
deallocating memory are all treated as writes for the purpose of the data-race detector.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.EvalContextExt.html" title="trait miri::concurrency::data_race::EvalContextExt">Eval<wbr>Context<wbr>Ext</a></dt><dt><a class="trait" href="trait.EvalContextPrivExt.html" title="trait miri::concurrency::data_race::EvalContextPrivExt">Eval<wbr>Context<wbr>Priv<wbr>Ext</a><span title="Restricted Visibility">&nbsp;ðŸ”’</span> </dt></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">Â§</a></h2><dl class="item-table"><dt><a class="type" href="type.AllocState.html" title="type miri::concurrency::data_race::AllocState">Alloc<wbr>State</a></dt></dl></section></div></main></body></html>