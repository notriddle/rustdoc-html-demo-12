<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Canonicalization is the key to constructing a query in the middle of type inference. Ordinarily, it is not possible to store types from type inference in query keys, because they contain references to inference variables whose lifetimes are too short and so forth. Canonicalizing a value T1 using `canonicalize_query` produces two things:"><title>rustc_infer::infer::canonical - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-528d32ef.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rustc_infer" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-dev" data-channel="nightly" data-search-js="search-e93015a6.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-1b37d467.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-c7770cbf.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module canonical</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../rustc_infer/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-9a9549ea.svg" alt="logo"></a><h2><a href="../../../rustc_infer/index.html">rustc_<wbr>infer</a><span class="version">1.91.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module canonical</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In rustc_<wbr>infer::<wbr>infer</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">rustc_infer</a>::<wbr><a href="../index.html">infer</a></div><h1>Module <span>canonical</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/rustc_infer/infer/canonical/mod.rs.html#1-150">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><strong>Canonicalization</strong> is the key to constructing a query in the
middle of type inference. Ordinarily, it is not possible to store
types from type inference in query keys, because they contain
references to inference variables whose lifetimes are too short
and so forth. Canonicalizing a value T1 using <code>canonicalize_query</code>
produces two things:</p>
<ul>
<li>a value T2 where each unbound inference variable has been
replaced with a <strong>canonical variable</strong>;</li>
<li>a map M (of type <code>CanonicalVarValues</code>) from those canonical
variables back to the original.</li>
</ul>
<p>We can then do queries using T2. These will give back constraints
on the canonical variables which can be translated, using the map
M, into constraints in our source context. This process of
translating the results back is done by the
<code>instantiate_query_result</code> method.</p>
<p>For a more detailed look at what is happening here, check
out the <a href="https://rust-lang.github.io/chalk/book/canonical_queries/canonicalization.html">chapter in the rustc dev guide</a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="mod" href="canonicalizer/index.html" title="mod rustc_infer::infer::canonical::canonicalizer">canonicalizer</a><span title="Restricted Visibility">&nbsp;üîí</span> </dt><dd>This module contains the ‚Äúcanonicalizer‚Äù itself.</dd><dt><a class="mod" href="instantiate/index.html" title="mod rustc_infer::infer::canonical::instantiate">instantiate</a><span title="Restricted Visibility">&nbsp;üîí</span> </dt><dd>This module contains code to instantiate new values into a
<code>Canonical&lt;'tcx, T&gt;</code>.</dd><dt><a class="mod" href="ir/index.html" title="mod rustc_infer::infer::canonical::ir">ir</a></dt><dt><a class="mod" href="query_response/index.html" title="mod rustc_infer::infer::canonical::query_response">query_<wbr>response</a></dt><dd>This module contains the code to instantiate a ‚Äúquery result‚Äù, and
in particular to extract out the resulting region obligations and
encode them therein.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="struct" href="struct.CanonicalParamEnvCache.html" title="struct rustc_infer::infer::canonical::CanonicalParamEnvCache">Canonical<wbr>Param<wbr>EnvCache</a></dt><dt><a class="struct" href="struct.OriginalQueryValues.html" title="struct rustc_infer::infer::canonical::OriginalQueryValues">Original<wbr>Query<wbr>Values</a></dt><dd>When we canonicalize a value to form a query, we wind up replacing
various parts of it with canonical variables. This struct stores
those replaced bits to remember for when we process the query
result.</dd><dt><a class="struct" href="struct.QueryRegionConstraints.html" title="struct rustc_infer::infer::canonical::QueryRegionConstraints">Query<wbr>Region<wbr>Constraints</a></dt><dt><a class="struct" href="struct.QueryResponse.html" title="struct rustc_infer::infer::canonical::QueryResponse">Query<wbr>Response</a></dt><dd>After we execute a query with a canonicalized key, we get back a
<code>Canonical&lt;QueryResponse&lt;..&gt;&gt;</code>. You can use
<code>instantiate_query_result</code> to access the data in this result.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="enum" href="enum.CanonicalTyVarKind.html" title="enum rustc_infer::infer::canonical::CanonicalTyVarKind">Canonical<wbr>TyVar<wbr>Kind</a></dt><dd>Rust actually has more than one category of type variables;
notably, the type variables we create for literals (e.g., 22 or
22.) can only be instantiated with integral/float types (e.g.,
usize or f32). In order to faithfully reproduce a type, we need to
know what set of types a given type variable can be unified with.</dd><dt><a class="enum" href="enum.Certainty.html" title="enum rustc_infer::infer::canonical::Certainty">Certainty</a></dt><dd>Indicates whether or not we were able to prove the query to be
true.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="trait" href="trait.CanonicalExt.html" title="trait rustc_infer::infer::canonical::CanonicalExt">Canonical<wbr>Ext</a></dt><dd>FIXME(-Znext-solver): This or public because it is shared with the
new trait solver implementation. We should deduplicate canonicalization.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">¬ß</a></h2><dl class="item-table"><dt><a class="type" href="type.Canonical.html" title="type rustc_infer::infer::canonical::Canonical">Canonical</a></dt><dt><a class="type" href="type.CanonicalQueryInput.html" title="type rustc_infer::infer::canonical::CanonicalQueryInput">Canonical<wbr>Query<wbr>Input</a></dt><dt><a class="type" href="type.CanonicalQueryResponse.html" title="type rustc_infer::infer::canonical::CanonicalQueryResponse">Canonical<wbr>Query<wbr>Response</a></dt><dt><a class="type" href="type.CanonicalVarKind.html" title="type rustc_infer::infer::canonical::CanonicalVarKind">Canonical<wbr>VarKind</a></dt><dt><a class="type" href="type.CanonicalVarKinds.html" title="type rustc_infer::infer::canonical::CanonicalVarKinds">Canonical<wbr>VarKinds</a></dt><dt><a class="type" href="type.CanonicalVarValues.html" title="type rustc_infer::infer::canonical::CanonicalVarValues">Canonical<wbr>VarValues</a></dt><dt><a class="type" href="type.QueryOutlivesConstraint.html" title="type rustc_infer::infer::canonical::QueryOutlivesConstraint">Query<wbr>Outlives<wbr>Constraint</a></dt></dl></section></div></main></body></html>