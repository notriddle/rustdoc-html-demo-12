<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `hir` mod in crate `rustc_hir`."><title>rustc_hir::hir - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-b5d4dc93.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="rustc_hir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-dev" data-channel="nightly" data-search-js="search-1a4373a8.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-1b37d467.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-c7770cbf.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module hir</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../rustc_hir/index.html">rustc_<wbr>hir</a><span class="version">1.91.0-dev</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module hir</a></h2><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="../index.html">In crate rustc_<wbr>hir</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">rustc_hir</a></div><h1>Module <span>hir</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/rustc_hir/hir.rs.html#2-4978">Source</a> </span></div><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="size_asserts/index.html" title="mod rustc_hir::hir::size_asserts">size_<wbr>asserts</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.expect_methods_self.html" title="macro rustc_hir::hir::expect_methods_self">expect_<wbr>methods_<wbr>self</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="macro" href="macro.expect_methods_self_kind.html" title="macro rustc_hir::hir::expect_methods_self_kind">expect_<wbr>methods_<wbr>self_<wbr>kind</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AnonConst.html" title="struct rustc_hir::hir::AnonConst">Anon<wbr>Const</a></dt><dd>A constant (expression) that’s not an item or associated item,
but needs its own <code>DefId</code> for type-checking, const-eval, etc.
These are usually found nested inside types (e.g., array lengths)
or expressions (e.g., repeat counts), and also used to define
explicit discriminant values for enum variants.</dd><dt><a class="struct" href="struct.Arm.html" title="struct rustc_hir::hir::Arm">Arm</a></dt><dd>Represents a single arm of a <code>match</code> expression, e.g.
<code>&lt;pat&gt; (if &lt;guard&gt;) =&gt; &lt;body&gt;</code>.</dd><dt><a class="struct" href="struct.AssocItemConstraint.html" title="struct rustc_hir::hir::AssocItemConstraint">Assoc<wbr>Item<wbr>Constraint</a></dt><dd>A constraint on an associated item.</dd><dt><a class="struct" href="struct.AttrId.html" title="struct rustc_hir::hir::AttrId">AttrId</a></dt><dt><a class="struct" href="struct.AttrItem.html" title="struct rustc_hir::hir::AttrItem">Attr<wbr>Item</a></dt><dt><a class="struct" href="struct.AttrPath.html" title="struct rustc_hir::hir::AttrPath">Attr<wbr>Path</a></dt><dt><a class="struct" href="struct.AttributeMap.html" title="struct rustc_hir::hir::AttributeMap">Attribute<wbr>Map</a></dt><dd>Attributes owned by a HIR owner.</dd><dt><a class="struct" href="struct.BindingMode.html" title="struct rustc_hir::hir::BindingMode">Binding<wbr>Mode</a></dt><dd>The mode of a binding (<code>mut</code>, <code>ref mut</code>, etc).
Used for both the explicit binding annotations given in the HIR for a binding
and the final binding mode that we infer after type inference/match ergonomics.
<code>.0</code> is the by-reference mode (<code>ref</code>, <code>ref mut</code>, or by value),
<code>.1</code> is the mutability of the binding.</dd><dt><a class="struct" href="struct.Block.html" title="struct rustc_hir::hir::Block">Block</a></dt><dd>A block of statements <code>{ .. }</code>, which may have a label (in this case the
<code>targeted_by_break</code> field will be <code>true</code>) and may be <code>unsafe</code> by means of
the <code>rules</code> being anything but <code>DefaultBlock</code>.</dd><dt><a class="struct" href="struct.Body.html" title="struct rustc_hir::hir::Body">Body</a></dt><dd>The body of a function, closure, or constant value. In the case of
a function, the body contains not only the function body itself
(which is an expression), but also the argument patterns, since
those are something that the caller doesn’t really care about.</dd><dt><a class="struct" href="struct.BodyId.html" title="struct rustc_hir::hir::BodyId">BodyId</a></dt><dt><a class="struct" href="struct.Closure.html" title="struct rustc_hir::hir::Closure">Closure</a></dt><dt><a class="struct" href="struct.ConstArg.html" title="struct rustc_hir::hir::ConstArg">Const<wbr>Arg</a></dt><dd>A constant that enters the type system, used for arguments to const generics (e.g. array lengths).</dd><dt><a class="struct" href="struct.ConstBlock.html" title="struct rustc_hir::hir::ConstBlock">Const<wbr>Block</a></dt><dd>An inline constant expression <code>const { something }</code>.</dd><dt><a class="struct" href="struct.Crate.html" title="struct rustc_hir::hir::Crate">Crate</a></dt><dd>The top-level data structure that stores the entire contents of
the crate currently being compiled.</dd><dt><a class="struct" href="struct.DelimArgs.html" title="struct rustc_hir::hir::DelimArgs">Delim<wbr>Args</a></dt><dd>Delimited arguments, as used in <code>#[attr()/[]/{}]</code> or <code>mac!()/[]/{}</code>.</dd><dt><a class="struct" href="struct.Destination.html" title="struct rustc_hir::hir::Destination">Destination</a></dt><dt><a class="struct" href="struct.DotDotPos.html" title="struct rustc_hir::hir::DotDotPos">DotDot<wbr>Pos</a></dt><dt><a class="struct" href="struct.EnumDef.html" title="struct rustc_hir::hir::EnumDef">EnumDef</a></dt><dt><a class="struct" href="struct.Expr.html" title="struct rustc_hir::hir::Expr">Expr</a></dt><dd>An expression.</dd><dt><a class="struct" href="struct.ExprField.html" title="struct rustc_hir::hir::ExprField">Expr<wbr>Field</a></dt><dt><a class="struct" href="struct.FieldDef.html" title="struct rustc_hir::hir::FieldDef">Field<wbr>Def</a></dt><dt><a class="struct" href="struct.FnDecl.html" title="struct rustc_hir::hir::FnDecl">FnDecl</a></dt><dd>Represents the header (not the body) of a function declaration.</dd><dt><a class="struct" href="struct.FnHeader.html" title="struct rustc_hir::hir::FnHeader">FnHeader</a></dt><dt><a class="struct" href="struct.FnPtrTy.html" title="struct rustc_hir::hir::FnPtrTy">FnPtrTy</a></dt><dt><a class="struct" href="struct.FnSig.html" title="struct rustc_hir::hir::FnSig">FnSig</a></dt><dd>Represents a function’s signature in a trait declaration,
trait implementation, or a free function.</dd><dt><a class="struct" href="struct.ForeignItem.html" title="struct rustc_hir::hir::ForeignItem">Foreign<wbr>Item</a></dt><dt><a class="struct" href="struct.ForeignItemId.html" title="struct rustc_hir::hir::ForeignItemId">Foreign<wbr>Item<wbr>Id</a></dt><dt><a class="struct" href="struct.GenericArgs.html" title="struct rustc_hir::hir::GenericArgs">Generic<wbr>Args</a></dt><dd>The generic arguments and associated item constraints of a path segment.</dd><dt><a class="struct" href="struct.GenericParam.html" title="struct rustc_hir::hir::GenericParam">Generic<wbr>Param</a></dt><dt><a class="struct" href="struct.GenericParamCount.html" title="struct rustc_hir::hir::GenericParamCount">Generic<wbr>Param<wbr>Count</a></dt><dt><a class="struct" href="struct.Generics.html" title="struct rustc_hir::hir::Generics">Generics</a></dt><dd>Represents lifetimes and type parameters attached to a declaration
of a function, enum, trait, etc.</dd><dt><a class="struct" href="struct.HashIgnoredAttrId.html" title="struct rustc_hir::hir::HashIgnoredAttrId">Hash<wbr>Ignored<wbr>Attr<wbr>Id</a></dt><dd>The derived implementation of <a href="../../rustc_macros/derive.HashStable_Generic.html" title="derive rustc_macros::HashStable_Generic"><code>HashStable_Generic</code></a> on <a href="enum.Attribute.html" title="enum rustc_hir::hir::Attribute"><code>Attribute</code></a>s shouldn’t hash
<a href="struct.AttrId.html" title="struct rustc_hir::hir::AttrId"><code>AttrId</code></a>s. By wrapping them in this, we make sure we never do.</dd><dt><a class="struct" href="struct.Impl.html" title="struct rustc_hir::hir::Impl">Impl</a></dt><dd>Represents an impl block declaration.</dd><dt><a class="struct" href="struct.ImplItem.html" title="struct rustc_hir::hir::ImplItem">Impl<wbr>Item</a></dt><dd>Represents an associated item within an impl block.</dd><dt><a class="struct" href="struct.ImplItemId.html" title="struct rustc_hir::hir::ImplItemId">Impl<wbr>Item<wbr>Id</a></dt><dt><a class="struct" href="struct.InferArg.html" title="struct rustc_hir::hir::InferArg">Infer<wbr>Arg</a></dt><dt><a class="struct" href="struct.InlineAsm.html" title="struct rustc_hir::hir::InlineAsm">Inline<wbr>Asm</a></dt><dt><a class="struct" href="struct.Item.html" title="struct rustc_hir::hir::Item">Item</a></dt><dd>An item</dd><dt><a class="struct" href="struct.ItemId.html" title="struct rustc_hir::hir::ItemId">ItemId</a></dt><dt><a class="struct" href="struct.LetExpr.html" title="struct rustc_hir::hir::LetExpr">LetExpr</a></dt><dd>Represents a <code>let &lt;pat&gt;[: &lt;ty&gt;] = &lt;expr&gt;</code> expression (not a <a href="struct.LetStmt.html" title="struct rustc_hir::hir::LetStmt"><code>LetStmt</code></a>), occurring in an <code>if-let</code>
or <code>let-else</code>, evaluating to a boolean. Typically the pattern is refutable.</dd><dt><a class="struct" href="struct.LetStmt.html" title="struct rustc_hir::hir::LetStmt">LetStmt</a></dt><dd>Represents a <code>let</code> statement (i.e., <code>let &lt;pat&gt;:&lt;ty&gt; = &lt;init&gt;;</code>).</dd><dt><a class="struct" href="struct.Lifetime.html" title="struct rustc_hir::hir::Lifetime">Lifetime</a></dt><dd>A lifetime. The valid field combinations are non-obvious and not all
combinations are possible. The following example shows some of
them. See also the comments on <code>LifetimeKind</code> and <code>LifetimeSource</code>.</dd><dt><a class="struct" href="struct.MetaItemLit.html" title="struct rustc_hir::hir::MetaItemLit">Meta<wbr>Item<wbr>Lit</a></dt><dd>A literal in a meta item.</dd><dt><a class="struct" href="struct.Mod.html" title="struct rustc_hir::hir::Mod">Mod</a></dt><dt><a class="struct" href="struct.ModSpans.html" title="struct rustc_hir::hir::ModSpans">ModSpans</a></dt><dt><a class="struct" href="struct.MutTy.html" title="struct rustc_hir::hir::MutTy">MutTy</a></dt><dt><a class="struct" href="struct.OpaqueTy.html" title="struct rustc_hir::hir::OpaqueTy">Opaque<wbr>Ty</a></dt><dt><a class="struct" href="struct.OwnerInfo.html" title="struct rustc_hir::hir::OwnerInfo">Owner<wbr>Info</a></dt><dd>Full information resulting from lowering an AST node.</dd><dt><a class="struct" href="struct.OwnerNodes.html" title="struct rustc_hir::hir::OwnerNodes">Owner<wbr>Nodes</a></dt><dd>Map of all HIR nodes inside the current owner.
These nodes are mapped by <code>ItemLocalId</code> alongside the index of their parent node.
The HIR tree, including bodies, is pre-hashed.</dd><dt><a class="struct" href="struct.Param.html" title="struct rustc_hir::hir::Param">Param</a></dt><dd>Represents a parameter in a function header.</dd><dt><a class="struct" href="struct.ParentedNode.html" title="struct rustc_hir::hir::ParentedNode">Parented<wbr>Node</a></dt><dd>HIR node coupled with its parent’s id in the same HIR owner.</dd><dt><a class="struct" href="struct.Pat.html" title="struct rustc_hir::hir::Pat">Pat</a></dt><dt><a class="struct" href="struct.PatExpr.html" title="struct rustc_hir::hir::PatExpr">PatExpr</a></dt><dt><a class="struct" href="struct.PatField.html" title="struct rustc_hir::hir::PatField">PatField</a></dt><dd>A single field in a struct pattern.</dd><dt><a class="struct" href="struct.Path.html" title="struct rustc_hir::hir::Path">Path</a></dt><dd>A <code>Path</code> is essentially Rust’s notion of a name; for instance,
<code>std::cmp::PartialEq</code>. It’s represented as a sequence of identifiers,
along with a bunch of supporting information.</dd><dt><a class="struct" href="struct.PathSegment.html" title="struct rustc_hir::hir::PathSegment">Path<wbr>Segment</a></dt><dd>A segment of a path: an identifier, an optional lifetime, and a set of
types.</dd><dt><a class="struct" href="struct.PolyTraitRef.html" title="struct rustc_hir::hir::PolyTraitRef">Poly<wbr>Trait<wbr>Ref</a></dt><dt><a class="struct" href="struct.PreciseCapturingNonLifetimeArg.html" title="struct rustc_hir::hir::PreciseCapturingNonLifetimeArg">Precise<wbr>Capturing<wbr>NonLifetime<wbr>Arg</a></dt><dd>We need to have a <a href="enum.Node.html" title="enum rustc_hir::hir::Node"><code>Node</code></a> for the <a href="../hir_id/struct.HirId.html" title="struct rustc_hir::hir_id::HirId"><code>HirId</code></a> that we attach the type/const param
resolution to. Lifetimes don’t have this problem, and for them, it’s actually
kind of detrimental to use a custom node type versus just using <a href="struct.Lifetime.html" title="struct rustc_hir::hir::Lifetime"><code>Lifetime</code></a>,
since resolve_bound_vars operates on <code>Lifetime</code>s.</dd><dt><a class="struct" href="struct.Stmt.html" title="struct rustc_hir::hir::Stmt">Stmt</a></dt><dd>A statement.</dd><dt><a class="struct" href="struct.TraitBoundModifiers.html" title="struct rustc_hir::hir::TraitBoundModifiers">Trait<wbr>Bound<wbr>Modifiers</a></dt><dd>The modifiers on a trait bound.</dd><dt><a class="struct" href="struct.TraitCandidate.html" title="struct rustc_hir::hir::TraitCandidate">Trait<wbr>Candidate</a></dt><dt><a class="struct" href="struct.TraitItem.html" title="struct rustc_hir::hir::TraitItem">Trait<wbr>Item</a></dt><dd>Represents an item declaration within a trait declaration,
possibly including a default implementation. A trait item is
either required (meaning it doesn’t have an implementation, just a
signature) or provided (meaning it has a default implementation).</dd><dt><a class="struct" href="struct.TraitItemId.html" title="struct rustc_hir::hir::TraitItemId">Trait<wbr>Item<wbr>Id</a></dt><dt><a class="struct" href="struct.TraitRef.html" title="struct rustc_hir::hir::TraitRef">Trait<wbr>Ref</a></dt><dd>References to traits in impls.</dd><dt><a class="struct" href="struct.Ty.html" title="struct rustc_hir::hir::Ty">Ty</a></dt><dd>Represents a type in the <code>HIR</code>.</dd><dt><a class="struct" href="struct.TyPat.html" title="struct rustc_hir::hir::TyPat">TyPat</a></dt><dt><a class="struct" href="struct.UnsafeBinderTy.html" title="struct rustc_hir::hir::UnsafeBinderTy">Unsafe<wbr>Binder<wbr>Ty</a></dt><dt><a class="struct" href="struct.Upvar.html" title="struct rustc_hir::hir::Upvar">Upvar</a></dt><dd>A variable captured by a closure.</dd><dt><a class="struct" href="struct.Variant.html" title="struct rustc_hir::hir::Variant">Variant</a></dt><dt><a class="struct" href="struct.WhereBoundPredicate.html" title="struct rustc_hir::hir::WhereBoundPredicate">Where<wbr>Bound<wbr>Predicate</a></dt><dd>A type bound (e.g., <code>for&lt;'c&gt; Foo: Send + Clone + 'c</code>).</dd><dt><a class="struct" href="struct.WhereEqPredicate.html" title="struct rustc_hir::hir::WhereEqPredicate">Where<wbr>EqPredicate</a></dt><dd>An equality predicate (e.g., <code>T = int</code>); currently unsupported.</dd><dt><a class="struct" href="struct.WherePredicate.html" title="struct rustc_hir::hir::WherePredicate">Where<wbr>Predicate</a></dt><dd>A single predicate in a where-clause.</dd><dt><a class="struct" href="struct.WhereRegionPredicate.html" title="struct rustc_hir::hir::WhereRegionPredicate">Where<wbr>Region<wbr>Predicate</a></dt><dd>A lifetime predicate (e.g., <code>'a: 'b + 'c</code>).</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.AmbigArg.html" title="enum rustc_hir::hir::AmbigArg">Ambig<wbr>Arg</a></dt><dd>An uninhabited enum used to make <code>Infer</code> variants on <a href="struct.Ty.html" title="struct rustc_hir::hir::Ty"><code>Ty</code></a> and <a href="struct.ConstArg.html" title="struct rustc_hir::hir::ConstArg"><code>ConstArg</code></a> be
unreachable. Zero-Variant enums are guaranteed to have the same layout as the never
type.</dd><dt><a class="enum" href="enum.AngleBrackets.html" title="enum rustc_hir::hir::AngleBrackets">Angle<wbr>Brackets</a></dt><dt><a class="enum" href="enum.AssignOpKind.html" title="enum rustc_hir::hir::AssignOpKind">Assign<wbr>OpKind</a></dt><dt><a class="enum" href="enum.AssocItemConstraintKind.html" title="enum rustc_hir::hir::AssocItemConstraintKind">Assoc<wbr>Item<wbr>Constraint<wbr>Kind</a></dt><dd>The kind of <a href="struct.AssocItemConstraint.html" title="struct rustc_hir::hir::AssocItemConstraint">associated item constraint</a>.</dd><dt><a class="enum" href="enum.AttrArgs.html" title="enum rustc_hir::hir::AttrArgs">Attr<wbr>Args</a></dt><dd>Arguments passed to an attribute macro.</dd><dt><a class="enum" href="enum.AttrStyle.html" title="enum rustc_hir::hir::AttrStyle">Attr<wbr>Style</a></dt><dd>Distinguishes between <code>Attribute</code>s that decorate items and Attributes that
are contained as statements within items. These two cases need to be
distinguished for pretty-printing.</dd><dt><a class="enum" href="enum.Attribute.html" title="enum rustc_hir::hir::Attribute">Attribute</a></dt><dt><a class="enum" href="enum.BinOpKind.html" title="enum rustc_hir::hir::BinOpKind">BinOp<wbr>Kind</a></dt><dt><a class="enum" href="enum.BlockCheckMode.html" title="enum rustc_hir::hir::BlockCheckMode">Block<wbr>Check<wbr>Mode</a></dt><dt><a class="enum" href="enum.BodyOwnerKind.html" title="enum rustc_hir::hir::BodyOwnerKind">Body<wbr>Owner<wbr>Kind</a></dt><dt><a class="enum" href="enum.BorrowKind.html" title="enum rustc_hir::hir::BorrowKind">Borrow<wbr>Kind</a></dt><dd>The kind of borrow in an <code>AddrOf</code> expression,
e.g., <code>&amp;place</code> or <code>&amp;raw const place</code>.</dd><dt><a class="enum" href="enum.BoundConstness.html" title="enum rustc_hir::hir::BoundConstness">Bound<wbr>Constness</a></dt><dd>The constness of a trait bound.</dd><dt><a class="enum" href="enum.BoundPolarity.html" title="enum rustc_hir::hir::BoundPolarity">Bound<wbr>Polarity</a></dt><dd>The polarity of a trait bound.</dd><dt><a class="enum" href="enum.ByRef.html" title="enum rustc_hir::hir::ByRef">ByRef</a></dt><dt><a class="enum" href="enum.CaptureBy.html" title="enum rustc_hir::hir::CaptureBy">Capture<wbr>By</a></dt><dd>A capture clause used in closures and <code>async</code> blocks.</dd><dt><a class="enum" href="enum.ClosureBinder.html" title="enum rustc_hir::hir::ClosureBinder">Closure<wbr>Binder</a></dt><dd>Represents <code>for&lt;...&gt;</code> binder before a closure</dd><dt><a class="enum" href="enum.ClosureKind.html" title="enum rustc_hir::hir::ClosureKind">Closure<wbr>Kind</a></dt><dt><a class="enum" href="enum.ConstArgKind.html" title="enum rustc_hir::hir::ConstArgKind">Const<wbr>ArgKind</a></dt><dd>See <a href="struct.ConstArg.html" title="struct rustc_hir::hir::ConstArg"><code>ConstArg</code></a>.</dd><dt><a class="enum" href="enum.ConstContext.html" title="enum rustc_hir::hir::ConstContext">Const<wbr>Context</a></dt><dd>The kind of an item that requires const-checking.</dd><dt><a class="enum" href="enum.Constness.html" title="enum rustc_hir::hir::Constness">Constness</a></dt><dt><a class="enum" href="enum.CoroutineDesugaring.html" title="enum rustc_hir::hir::CoroutineDesugaring">Coroutine<wbr>Desugaring</a></dt><dt><a class="enum" href="enum.CoroutineKind.html" title="enum rustc_hir::hir::CoroutineKind">Coroutine<wbr>Kind</a></dt><dd>The type of source expression that caused this coroutine to be created.</dd><dt><a class="enum" href="enum.CoroutineSource.html" title="enum rustc_hir::hir::CoroutineSource">Coroutine<wbr>Source</a></dt><dd>In the case of a coroutine created as part of an async/gen construct,
which kind of async/gen construct caused it to be created?</dd><dt><a class="enum" href="enum.Defaultness.html" title="enum rustc_hir::hir::Defaultness">Defaultness</a></dt><dt><a class="enum" href="enum.ExprKind.html" title="enum rustc_hir::hir::ExprKind">Expr<wbr>Kind</a></dt><dt><a class="enum" href="enum.FnRetTy.html" title="enum rustc_hir::hir::FnRetTy">FnRetTy</a></dt><dt><a class="enum" href="enum.ForeignItemKind.html" title="enum rustc_hir::hir::ForeignItemKind">Foreign<wbr>Item<wbr>Kind</a></dt><dd>An item within an <code>extern</code> block.</dd><dt><a class="enum" href="enum.GenericArg.html" title="enum rustc_hir::hir::GenericArg">Generic<wbr>Arg</a></dt><dt><a class="enum" href="enum.GenericArgsParentheses.html" title="enum rustc_hir::hir::GenericArgsParentheses">Generic<wbr>Args<wbr>Parentheses</a></dt><dt><a class="enum" href="enum.GenericBound.html" title="enum rustc_hir::hir::GenericBound">Generic<wbr>Bound</a></dt><dt><a class="enum" href="enum.GenericParamKind.html" title="enum rustc_hir::hir::GenericParamKind">Generic<wbr>Param<wbr>Kind</a></dt><dt><a class="enum" href="enum.GenericParamSource.html" title="enum rustc_hir::hir::GenericParamSource">Generic<wbr>Param<wbr>Source</a></dt><dd>Records where the generic parameter originated from.</dd><dt><a class="enum" href="enum.HeaderSafety.html" title="enum rustc_hir::hir::HeaderSafety">Header<wbr>Safety</a></dt><dd>The actual safety specified in syntax. We may treat
its safety different within the type system to create a
“sound by default” system that needs checking this enum
explicitly to allow unsafe operations.</dd><dt><a class="enum" href="enum.ImplItemKind.html" title="enum rustc_hir::hir::ImplItemKind">Impl<wbr>Item<wbr>Kind</a></dt><dd>Represents various kinds of content within an <code>impl</code>.</dd><dt><a class="enum" href="enum.ImplPolarity.html" title="enum rustc_hir::hir::ImplPolarity">Impl<wbr>Polarity</a></dt><dt><a class="enum" href="enum.ImplicitSelfKind.html" title="enum rustc_hir::hir::ImplicitSelfKind">Implicit<wbr>Self<wbr>Kind</a></dt><dd>Represents what type of implicit self a function has, if any.</dd><dt><a class="enum" href="enum.InferDelegationKind.html" title="enum rustc_hir::hir::InferDelegationKind">Infer<wbr>Delegation<wbr>Kind</a></dt><dt><a class="enum" href="enum.InlineAsmOperand.html" title="enum rustc_hir::hir::InlineAsmOperand">Inline<wbr>AsmOperand</a></dt><dt><a class="enum" href="enum.IsAsync.html" title="enum rustc_hir::hir::IsAsync">IsAsync</a></dt><dt><a class="enum" href="enum.IsAuto.html" title="enum rustc_hir::hir::IsAuto">IsAuto</a></dt><dd>Is the trait definition an auto trait?</dd><dt><a class="enum" href="enum.ItemKind.html" title="enum rustc_hir::hir::ItemKind">Item<wbr>Kind</a></dt><dt><a class="enum" href="enum.LifetimeKind.html" title="enum rustc_hir::hir::LifetimeKind">Lifetime<wbr>Kind</a></dt><dt><a class="enum" href="enum.LifetimeParamKind.html" title="enum rustc_hir::hir::LifetimeParamKind">Lifetime<wbr>Param<wbr>Kind</a></dt><dt><a class="enum" href="enum.LifetimeSource.html" title="enum rustc_hir::hir::LifetimeSource">Lifetime<wbr>Source</a></dt><dt><a class="enum" href="enum.LifetimeSyntax.html" title="enum rustc_hir::hir::LifetimeSyntax">Lifetime<wbr>Syntax</a></dt><dt><a class="enum" href="enum.LocalSource.html" title="enum rustc_hir::hir::LocalSource">Local<wbr>Source</a></dt><dd>Hints at the original code for a let statement.</dd><dt><a class="enum" href="enum.LoopIdError.html" title="enum rustc_hir::hir::LoopIdError">Loop<wbr>IdError</a></dt><dt><a class="enum" href="enum.LoopSource.html" title="enum rustc_hir::hir::LoopSource">Loop<wbr>Source</a></dt><dd>The loop type that yielded an <code>ExprKind::Loop</code>.</dd><dt><a class="enum" href="enum.MatchSource.html" title="enum rustc_hir::hir::MatchSource">Match<wbr>Source</a></dt><dd>Hints at the original code for a <code>match _ { .. }</code>.</dd><dt><a class="enum" href="enum.MaybeOwner.html" title="enum rustc_hir::hir::MaybeOwner">Maybe<wbr>Owner</a></dt><dt><a class="enum" href="enum.MetaItemInner.html" title="enum rustc_hir::hir::MetaItemInner">Meta<wbr>Item<wbr>Inner</a></dt><dd>Values inside meta item lists.</dd><dt><a class="enum" href="enum.MissingLifetimeKind.html" title="enum rustc_hir::hir::MissingLifetimeKind">Missing<wbr>Lifetime<wbr>Kind</a></dt><dt><a class="enum" href="enum.Movability.html" title="enum rustc_hir::hir::Movability">Movability</a></dt><dd>The movability of a coroutine / closure literal:
whether a coroutine contains self-references, causing it to be <code>!Unpin</code>.</dd><dt><a class="enum" href="enum.Mutability.html" title="enum rustc_hir::hir::Mutability">Mutability</a></dt><dt><a class="enum" href="enum.Node.html" title="enum rustc_hir::hir::Node">Node</a></dt><dt><a class="enum" href="enum.OpaqueTyOrigin.html" title="enum rustc_hir::hir::OpaqueTyOrigin">Opaque<wbr>TyOrigin</a></dt><dd>From whence the opaque type came.</dd><dt><a class="enum" href="enum.OwnerNode.html" title="enum rustc_hir::hir::OwnerNode">Owner<wbr>Node</a></dt><dt><a class="enum" href="enum.ParamName.html" title="enum rustc_hir::hir::ParamName">Param<wbr>Name</a></dt><dt><a class="enum" href="enum.PatExprKind.html" title="enum rustc_hir::hir::PatExprKind">PatExpr<wbr>Kind</a></dt><dt><a class="enum" href="enum.PatKind.html" title="enum rustc_hir::hir::PatKind">PatKind</a></dt><dt><a class="enum" href="enum.PreciseCapturingArgKind.html" title="enum rustc_hir::hir::PreciseCapturingArgKind">Precise<wbr>Capturing<wbr>ArgKind</a></dt><dt><a class="enum" href="enum.PredicateOrigin.html" title="enum rustc_hir::hir::PredicateOrigin">Predicate<wbr>Origin</a></dt><dt><a class="enum" href="enum.PrimTy.html" title="enum rustc_hir::hir::PrimTy">PrimTy</a></dt><dd>Not represented directly in the AST; referred to by name through a <code>ty_path</code>.</dd><dt><a class="enum" href="enum.QPath.html" title="enum rustc_hir::hir::QPath">QPath</a></dt><dd>Represents an optionally <code>Self</code>-qualified value/type path or associated extension.</dd><dt><a class="enum" href="enum.RangeEnd.html" title="enum rustc_hir::hir::RangeEnd">Range<wbr>End</a></dt><dt><a class="enum" href="enum.RpitContext.html" title="enum rustc_hir::hir::RpitContext">Rpit<wbr>Context</a></dt><dt><a class="enum" href="enum.Safety.html" title="enum rustc_hir::hir::Safety">Safety</a></dt><dt><a class="enum" href="enum.StmtKind.html" title="enum rustc_hir::hir::StmtKind">Stmt<wbr>Kind</a></dt><dd>The contents of a statement.</dd><dt><a class="enum" href="enum.StructTailExpr.html" title="enum rustc_hir::hir::StructTailExpr">Struct<wbr>Tail<wbr>Expr</a></dt><dt><a class="enum" href="enum.Term.html" title="enum rustc_hir::hir::Term">Term</a></dt><dt><a class="enum" href="enum.TraitFn.html" title="enum rustc_hir::hir::TraitFn">TraitFn</a></dt><dd>Represents a trait method’s body (or just argument names).</dd><dt><a class="enum" href="enum.TraitItemKind.html" title="enum rustc_hir::hir::TraitItemKind">Trait<wbr>Item<wbr>Kind</a></dt><dd>Represents a trait method or associated constant or type</dd><dt><a class="enum" href="enum.TyKind.html" title="enum rustc_hir::hir::TyKind">TyKind</a></dt><dd>The various kinds of types recognized by the compiler.</dd><dt><a class="enum" href="enum.TyPatKind.html" title="enum rustc_hir::hir::TyPatKind">TyPat<wbr>Kind</a></dt><dt><a class="enum" href="enum.UnOp.html" title="enum rustc_hir::hir::UnOp">UnOp</a></dt><dd>Unary operator.</dd><dt><a class="enum" href="enum.UnsafeSource.html" title="enum rustc_hir::hir::UnsafeSource">Unsafe<wbr>Source</a></dt><dt><a class="enum" href="enum.UseKind.html" title="enum rustc_hir::hir::UseKind">UseKind</a></dt><dt><a class="enum" href="enum.VariantData.html" title="enum rustc_hir::hir::VariantData">Variant<wbr>Data</a></dt><dd>Fields and constructor IDs of enum variants and structs.</dd><dt><a class="enum" href="enum.WherePredicateKind.html" title="enum rustc_hir::hir::WherePredicateKind">Where<wbr>Predicate<wbr>Kind</a></dt><dd>The kind of a single predicate in a where-clause.</dd><dt><a class="enum" href="enum.YieldSource.html" title="enum rustc_hir::hir::YieldSource">Yield<wbr>Source</a></dt><dd>The yield kind that caused an <code>ExprKind::Yield</code>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.expect_failed.html" title="fn rustc_hir::hir::expect_failed">expect_<wbr>failed</a><span title="Restricted Visibility">&nbsp;🔒</span> </dt><dt><a class="fn" href="fn.expr_needs_parens.html" title="fn rustc_hir::hir::expr_needs_parens">expr_<wbr>needs_<wbr>parens</a></dt><dd>Checks if the specified expression needs parentheses for prefix
or postfix suggestions to be valid.
For example, <code>a + b</code> requires parentheses to suggest <code>&amp;(a + b)</code>,
but just <code>a</code> does not.
Similarly, <code>(a + b).c()</code> also requires parentheses.
This should not be used for other types of suggestions.</dd><dt><a class="fn" href="fn.is_range_literal.html" title="fn rustc_hir::hir::is_range_literal">is_<wbr>range_<wbr>literal</a></dt><dd>Checks if the specified expression is a built-in range literal.
(See: <code>LoweringContext::lower_expr()</code>).</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.AssignOp.html" title="type rustc_hir::hir::AssignOp">Assign<wbr>Op</a></dt><dt><a class="type" href="type.BinOp.html" title="type rustc_hir::hir::BinOp">BinOp</a></dt><dt><a class="type" href="type.GenericBounds.html" title="type rustc_hir::hir::GenericBounds">Generic<wbr>Bounds</a></dt><dt><a class="type" href="type.Lit.html" title="type rustc_hir::hir::Lit">Lit</a></dt><dd>A literal.</dd><dt><a class="type" href="type.PreciseCapturingArg.html" title="type rustc_hir::hir::PreciseCapturingArg">Precise<wbr>Capturing<wbr>Arg</a></dt><dt><a class="type" href="type.UsePath.html" title="type rustc_hir::hir::UsePath">UsePath</a></dt><dd>Up to three resolutions for type, value and macro namespaces.</dd></dl></section></div></main></body></html>